import {
  Directive,
  LitElement,
  PartType,
  _$LH,
  css,
  defaultConverter,
  directive,
  html,
  noChange,
  notEqual,
  nothing,
  render,
  styleMap,
  svg,
  unsafeCSS,
  unsafeHTML
} from "./chunk-DPSKPH4K.js";
import {
  useCopilotKit
} from "./chunk-WLWBUVD6.js";
import {
  external_exports
} from "./chunk-4RP4FUON.js";
import "./chunk-G72OX5PG.js";
import "./chunk-MNN7MA6Z.js";
import "./chunk-FCSS27DJ.js";
import "./chunk-J4GKOW34.js";
import {
  require_jsx_runtime
} from "./chunk-YPFTA7T3.js";
import "./chunk-RKPRDNAF.js";
import {
  require_react
} from "./chunk-2EQJD3K3.js";
import {
  __export,
  __privateAdd,
  __privateGet,
  __privateIn,
  __privateMethod,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-ISKIE5KO.js";

// node_modules/signal-polyfill/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateIn2 = (member, obj) => {
  if (Object(obj) !== obj)
    throw TypeError('Cannot use the "in" operator on this value');
  return member.has(obj);
};
var __privateAdd2 = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod2 = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
function defaultEquals(a2, b) {
  return Object.is(a2, b);
}
var activeConsumer = null;
var inNotificationPhase = false;
var epoch = 1;
var SIGNAL = Symbol("SIGNAL");
function setActiveConsumer(consumer) {
  const prev = activeConsumer;
  activeConsumer = consumer;
  return prev;
}
function getActiveConsumer() {
  return activeConsumer;
}
function isInNotificationPhase() {
  return inNotificationPhase;
}
var REACTIVE_NODE = {
  version: 0,
  lastCleanEpoch: 0,
  dirty: false,
  producerNode: void 0,
  producerLastReadVersion: void 0,
  producerIndexOfThis: void 0,
  nextProducerIndex: 0,
  liveConsumerNode: void 0,
  liveConsumerIndexOfThis: void 0,
  consumerAllowSignalWrites: false,
  consumerIsAlwaysLive: false,
  producerMustRecompute: () => false,
  producerRecomputeValue: () => {
  },
  consumerMarkedDirty: () => {
  },
  consumerOnSignalRead: () => {
  }
};
function producerAccessed(node) {
  if (inNotificationPhase) {
    throw new Error(
      typeof ngDevMode !== "undefined" && ngDevMode ? `Assertion error: signal read during notification phase` : ""
    );
  }
  if (activeConsumer === null) {
    return;
  }
  activeConsumer.consumerOnSignalRead(node);
  const idx = activeConsumer.nextProducerIndex++;
  assertConsumerNode(activeConsumer);
  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {
    if (consumerIsLive(activeConsumer)) {
      const staleProducer = activeConsumer.producerNode[idx];
      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);
    }
  }
  if (activeConsumer.producerNode[idx] !== node) {
    activeConsumer.producerNode[idx] = node;
    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;
  }
  activeConsumer.producerLastReadVersion[idx] = node.version;
}
function producerIncrementEpoch() {
  epoch++;
}
function producerUpdateValueVersion(node) {
  if (!node.dirty && node.lastCleanEpoch === epoch) {
    return;
  }
  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {
    node.dirty = false;
    node.lastCleanEpoch = epoch;
    return;
  }
  node.producerRecomputeValue(node);
  node.dirty = false;
  node.lastCleanEpoch = epoch;
}
function producerNotifyConsumers(node) {
  if (node.liveConsumerNode === void 0) {
    return;
  }
  const prev = inNotificationPhase;
  inNotificationPhase = true;
  try {
    for (const consumer of node.liveConsumerNode) {
      if (!consumer.dirty) {
        consumerMarkDirty(consumer);
      }
    }
  } finally {
    inNotificationPhase = prev;
  }
}
function producerUpdatesAllowed() {
  return (activeConsumer == null ? void 0 : activeConsumer.consumerAllowSignalWrites) !== false;
}
function consumerMarkDirty(node) {
  var _a3;
  node.dirty = true;
  producerNotifyConsumers(node);
  (_a3 = node.consumerMarkedDirty) == null ? void 0 : _a3.call(node.wrapper ?? node);
}
function consumerBeforeComputation(node) {
  node && (node.nextProducerIndex = 0);
  return setActiveConsumer(node);
}
function consumerAfterComputation(node, prevConsumer) {
  setActiveConsumer(prevConsumer);
  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {
    return;
  }
  if (consumerIsLive(node)) {
    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  while (node.producerNode.length > node.nextProducerIndex) {
    node.producerNode.pop();
    node.producerLastReadVersion.pop();
    node.producerIndexOfThis.pop();
  }
}
function consumerPollProducersForChange(node) {
  assertConsumerNode(node);
  for (let i = 0; i < node.producerNode.length; i++) {
    const producer = node.producerNode[i];
    const seenVersion = node.producerLastReadVersion[i];
    if (seenVersion !== producer.version) {
      return true;
    }
    producerUpdateValueVersion(producer);
    if (seenVersion !== producer.version) {
      return true;
    }
  }
  return false;
}
function producerAddLiveConsumer(node, consumer, indexOfThis) {
  var _a3;
  assertProducerNode(node);
  assertConsumerNode(node);
  if (node.liveConsumerNode.length === 0) {
    (_a3 = node.watched) == null ? void 0 : _a3.call(node.wrapper);
    for (let i = 0; i < node.producerNode.length; i++) {
      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);
    }
  }
  node.liveConsumerIndexOfThis.push(indexOfThis);
  return node.liveConsumerNode.push(consumer) - 1;
}
function producerRemoveLiveConsumerAtIndex(node, idx) {
  var _a3;
  assertProducerNode(node);
  assertConsumerNode(node);
  if (typeof ngDevMode !== "undefined" && ngDevMode && idx >= node.liveConsumerNode.length) {
    throw new Error(
      `Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`
    );
  }
  if (node.liveConsumerNode.length === 1) {
    (_a3 = node.unwatched) == null ? void 0 : _a3.call(node.wrapper);
    for (let i = 0; i < node.producerNode.length; i++) {
      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
    }
  }
  const lastIdx = node.liveConsumerNode.length - 1;
  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];
  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];
  node.liveConsumerNode.length--;
  node.liveConsumerIndexOfThis.length--;
  if (idx < node.liveConsumerNode.length) {
    const idxProducer = node.liveConsumerIndexOfThis[idx];
    const consumer = node.liveConsumerNode[idx];
    assertConsumerNode(consumer);
    consumer.producerIndexOfThis[idxProducer] = idx;
  }
}
function consumerIsLive(node) {
  var _a3;
  return node.consumerIsAlwaysLive || (((_a3 = node == null ? void 0 : node.liveConsumerNode) == null ? void 0 : _a3.length) ?? 0) > 0;
}
function assertConsumerNode(node) {
  node.producerNode ?? (node.producerNode = []);
  node.producerIndexOfThis ?? (node.producerIndexOfThis = []);
  node.producerLastReadVersion ?? (node.producerLastReadVersion = []);
}
function assertProducerNode(node) {
  node.liveConsumerNode ?? (node.liveConsumerNode = []);
  node.liveConsumerIndexOfThis ?? (node.liveConsumerIndexOfThis = []);
}
function computedGet(node) {
  producerUpdateValueVersion(node);
  producerAccessed(node);
  if (node.value === ERRORED) {
    throw node.error;
  }
  return node.value;
}
function createComputed(computation) {
  const node = Object.create(COMPUTED_NODE);
  node.computation = computation;
  const computed = () => computedGet(node);
  computed[SIGNAL] = node;
  return computed;
}
var UNSET = Symbol("UNSET");
var COMPUTING = Symbol("COMPUTING");
var ERRORED = Symbol("ERRORED");
var COMPUTED_NODE = (() => {
  return {
    ...REACTIVE_NODE,
    value: UNSET,
    dirty: true,
    error: null,
    equal: defaultEquals,
    producerMustRecompute(node) {
      return node.value === UNSET || node.value === COMPUTING;
    },
    producerRecomputeValue(node) {
      if (node.value === COMPUTING) {
        throw new Error("Detected cycle in computations.");
      }
      const oldValue = node.value;
      node.value = COMPUTING;
      const prevConsumer = consumerBeforeComputation(node);
      let newValue;
      let wasEqual = false;
      try {
        newValue = node.computation.call(node.wrapper);
        const oldOk = oldValue !== UNSET && oldValue !== ERRORED;
        wasEqual = oldOk && node.equal.call(node.wrapper, oldValue, newValue);
      } catch (err) {
        newValue = ERRORED;
        node.error = err;
      } finally {
        consumerAfterComputation(node, prevConsumer);
      }
      if (wasEqual) {
        node.value = oldValue;
        return;
      }
      node.value = newValue;
      node.version++;
    }
  };
})();
function defaultThrowError() {
  throw new Error();
}
var throwInvalidWriteToSignalErrorFn = defaultThrowError;
function throwInvalidWriteToSignalError() {
  throwInvalidWriteToSignalErrorFn();
}
function createSignal(initialValue) {
  const node = Object.create(SIGNAL_NODE);
  node.value = initialValue;
  const getter = () => {
    producerAccessed(node);
    return node.value;
  };
  getter[SIGNAL] = node;
  return getter;
}
function signalGetFn() {
  producerAccessed(this);
  return this.value;
}
function signalSetFn(node, newValue) {
  if (!producerUpdatesAllowed()) {
    throwInvalidWriteToSignalError();
  }
  if (!node.equal.call(node.wrapper, node.value, newValue)) {
    node.value = newValue;
    signalValueChanged(node);
  }
}
var SIGNAL_NODE = (() => {
  return {
    ...REACTIVE_NODE,
    equal: defaultEquals,
    value: void 0
  };
})();
function signalValueChanged(node) {
  node.version++;
  producerIncrementEpoch();
  producerNotifyConsumers(node);
}
var NODE = Symbol("node");
var Signal;
((Signal2) => {
  var _a3, _brand, brand_fn, _b2, _brand2, brand_fn2;
  class State2 {
    constructor(initialValue, options = {}) {
      __privateAdd2(this, _brand);
      __publicField2(this, _a3);
      const ref2 = createSignal(initialValue);
      const node = ref2[SIGNAL];
      this[NODE] = node;
      node.wrapper = this;
      if (options) {
        const equals = options.equals;
        if (equals) {
          node.equal = equals;
        }
        node.watched = options[Signal2.subtle.watched];
        node.unwatched = options[Signal2.subtle.unwatched];
      }
    }
    get() {
      if (!(0, Signal2.isState)(this))
        throw new TypeError("Wrong receiver type for Signal.State.prototype.get");
      return signalGetFn.call(this[NODE]);
    }
    set(newValue) {
      if (!(0, Signal2.isState)(this))
        throw new TypeError("Wrong receiver type for Signal.State.prototype.set");
      if (isInNotificationPhase()) {
        throw new Error("Writes to signals not permitted during Watcher callback");
      }
      const ref2 = this[NODE];
      signalSetFn(ref2, newValue);
    }
  }
  _a3 = NODE;
  _brand = /* @__PURE__ */ new WeakSet();
  brand_fn = function() {
  };
  Signal2.isState = (s) => typeof s === "object" && __privateIn2(_brand, s);
  Signal2.State = State2;
  class Computed2 {
    // Create a Signal which evaluates to the value returned by the callback.
    // Callback is called with this signal as the parameter.
    constructor(computation, options) {
      __privateAdd2(this, _brand2);
      __publicField2(this, _b2);
      const ref2 = createComputed(computation);
      const node = ref2[SIGNAL];
      node.consumerAllowSignalWrites = true;
      this[NODE] = node;
      node.wrapper = this;
      if (options) {
        const equals = options.equals;
        if (equals) {
          node.equal = equals;
        }
        node.watched = options[Signal2.subtle.watched];
        node.unwatched = options[Signal2.subtle.unwatched];
      }
    }
    get() {
      if (!(0, Signal2.isComputed)(this))
        throw new TypeError("Wrong receiver type for Signal.Computed.prototype.get");
      return computedGet(this[NODE]);
    }
  }
  _b2 = NODE;
  _brand2 = /* @__PURE__ */ new WeakSet();
  brand_fn2 = function() {
  };
  Signal2.isComputed = (c) => typeof c === "object" && __privateIn2(_brand2, c);
  Signal2.Computed = Computed2;
  ((subtle2) => {
    var _a22, _brand3, brand_fn3, _assertSignals, assertSignals_fn;
    function untrack(cb) {
      let output;
      let prevActiveConsumer = null;
      try {
        prevActiveConsumer = setActiveConsumer(null);
        output = cb();
      } finally {
        setActiveConsumer(prevActiveConsumer);
      }
      return output;
    }
    subtle2.untrack = untrack;
    function introspectSources(sink) {
      var _a32;
      if (!(0, Signal2.isComputed)(sink) && !(0, Signal2.isWatcher)(sink)) {
        throw new TypeError("Called introspectSources without a Computed or Watcher argument");
      }
      return ((_a32 = sink[NODE].producerNode) == null ? void 0 : _a32.map((n) => n.wrapper)) ?? [];
    }
    subtle2.introspectSources = introspectSources;
    function introspectSinks(signal) {
      var _a32;
      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {
        throw new TypeError("Called introspectSinks without a Signal argument");
      }
      return ((_a32 = signal[NODE].liveConsumerNode) == null ? void 0 : _a32.map((n) => n.wrapper)) ?? [];
    }
    subtle2.introspectSinks = introspectSinks;
    function hasSinks(signal) {
      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {
        throw new TypeError("Called hasSinks without a Signal argument");
      }
      const liveConsumerNode = signal[NODE].liveConsumerNode;
      if (!liveConsumerNode)
        return false;
      return liveConsumerNode.length > 0;
    }
    subtle2.hasSinks = hasSinks;
    function hasSources(signal) {
      if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isWatcher)(signal)) {
        throw new TypeError("Called hasSources without a Computed or Watcher argument");
      }
      const producerNode = signal[NODE].producerNode;
      if (!producerNode)
        return false;
      return producerNode.length > 0;
    }
    subtle2.hasSources = hasSources;
    class Watcher {
      // When a (recursive) source of Watcher is written to, call this callback,
      // if it hasn't already been called since the last `watch` call.
      // No signals may be read or written during the notify.
      constructor(notify) {
        __privateAdd2(this, _brand3);
        __privateAdd2(this, _assertSignals);
        __publicField2(this, _a22);
        let node = Object.create(REACTIVE_NODE);
        node.wrapper = this;
        node.consumerMarkedDirty = notify;
        node.consumerIsAlwaysLive = true;
        node.consumerAllowSignalWrites = false;
        node.producerNode = [];
        this[NODE] = node;
      }
      // Add these signals to the Watcher's set, and set the watcher to run its
      // notify callback next time any signal in the set (or one of its dependencies) changes.
      // Can be called with no arguments just to reset the "notified" state, so that
      // the notify callback will be invoked again.
      watch(...signals) {
        if (!(0, Signal2.isWatcher)(this)) {
          throw new TypeError("Called unwatch without Watcher receiver");
        }
        __privateMethod2(this, _assertSignals, assertSignals_fn).call(this, signals);
        const node = this[NODE];
        node.dirty = false;
        const prev = setActiveConsumer(node);
        for (const signal of signals) {
          producerAccessed(signal[NODE]);
        }
        setActiveConsumer(prev);
      }
      // Remove these signals from the watched set (e.g., for an effect which is disposed)
      unwatch(...signals) {
        if (!(0, Signal2.isWatcher)(this)) {
          throw new TypeError("Called unwatch without Watcher receiver");
        }
        __privateMethod2(this, _assertSignals, assertSignals_fn).call(this, signals);
        const node = this[NODE];
        assertConsumerNode(node);
        for (let i = node.producerNode.length - 1; i >= 0; i--) {
          if (signals.includes(node.producerNode[i].wrapper)) {
            producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);
            const lastIdx = node.producerNode.length - 1;
            node.producerNode[i] = node.producerNode[lastIdx];
            node.producerIndexOfThis[i] = node.producerIndexOfThis[lastIdx];
            node.producerNode.length--;
            node.producerIndexOfThis.length--;
            node.nextProducerIndex--;
            if (i < node.producerNode.length) {
              const idxConsumer = node.producerIndexOfThis[i];
              const producer = node.producerNode[i];
              assertProducerNode(producer);
              producer.liveConsumerIndexOfThis[idxConsumer] = i;
            }
          }
        }
      }
      // Returns the set of computeds in the Watcher's set which are still yet
      // to be re-evaluated
      getPending() {
        if (!(0, Signal2.isWatcher)(this)) {
          throw new TypeError("Called getPending without Watcher receiver");
        }
        const node = this[NODE];
        return node.producerNode.filter((n) => n.dirty).map((n) => n.wrapper);
      }
    }
    _a22 = NODE;
    _brand3 = /* @__PURE__ */ new WeakSet();
    brand_fn3 = function() {
    };
    _assertSignals = /* @__PURE__ */ new WeakSet();
    assertSignals_fn = function(signals) {
      for (const signal of signals) {
        if (!(0, Signal2.isComputed)(signal) && !(0, Signal2.isState)(signal)) {
          throw new TypeError("Called watch/unwatch without a Computed or State argument");
        }
      }
    };
    Signal2.isWatcher = (w) => __privateIn2(_brand3, w);
    subtle2.Watcher = Watcher;
    function currentComputed() {
      var _a32;
      return (_a32 = getActiveConsumer()) == null ? void 0 : _a32.wrapper;
    }
    subtle2.currentComputed = currentComputed;
    subtle2.watched = Symbol("watched");
    subtle2.unwatched = Symbol("unwatched");
  })(Signal2.subtle || (Signal2.subtle = {}));
})(Signal || (Signal = {}));

// node_modules/@lit-labs/signals/development/lib/signal-watcher.js
var signalWatcherBrand = Symbol("SignalWatcherBrand");
var elementFinalizationRegistry = new FinalizationRegistry(({ watcher: watcher2, signal }) => {
  watcher2.unwatch(signal);
});
var elementForWatcher = /* @__PURE__ */ new WeakMap();
function SignalWatcher(Base) {
  if (Base[signalWatcherBrand] === true) {
    console.warn("SignalWatcher should not be applied to the same class more than once.");
    return Base;
  }
  class SignalWatcher2 extends Base {
    constructor() {
      super(...arguments);
      this.__forceUpdateSignal = new Signal.State(0);
      this.__forcingUpdate = false;
      this.__doFullRender = true;
      this.__pendingWatches = /* @__PURE__ */ new Set();
    }
    __watch() {
      if (this.__watcher !== void 0) {
        return;
      }
      this.__performUpdateSignal = new Signal.Computed(() => {
        this.__forceUpdateSignal.get();
        super.performUpdate();
      });
      const watcher2 = this.__watcher = new Signal.subtle.Watcher(function() {
        const el = elementForWatcher.get(this);
        if (el === void 0) {
          return;
        }
        if (el.__forcingUpdate === false) {
          el.requestUpdate();
        }
        this.watch();
      });
      elementForWatcher.set(watcher2, this);
      elementFinalizationRegistry.register(this, {
        watcher: watcher2,
        signal: this.__performUpdateSignal
      });
      watcher2.watch(this.__performUpdateSignal);
    }
    __unwatch() {
      if (this.__watcher === void 0) {
        return;
      }
      this.__watcher.unwatch(this.__performUpdateSignal);
      this.__performUpdateSignal = void 0;
      this.__watcher = void 0;
    }
    performUpdate() {
      if (!this.isUpdatePending) {
        return;
      }
      this.__watch();
      this.__forcingUpdate = true;
      this.__forceUpdateSignal.set(this.__forceUpdateSignal.get() + 1);
      this.__forcingUpdate = false;
      this.__performUpdateSignal.get();
    }
    update(changedProperties) {
      try {
        if (this.__doFullRender) {
          this.__doFullRender = false;
          super.update(changedProperties);
        } else {
          this.__pendingWatches.forEach((d) => d.commit());
        }
      } finally {
        this.isUpdatePending = false;
        this.__pendingWatches.clear();
      }
    }
    requestUpdate(name, oldValue, options) {
      this.__doFullRender = true;
      super.requestUpdate(name, oldValue, options);
    }
    connectedCallback() {
      super.connectedCallback();
      this.requestUpdate();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      queueMicrotask(() => {
        if (this.isConnected === false) {
          this.__unwatch();
        }
      });
    }
    /**
     * Enqueues an update caused by a signal change observed by a watch()
     * directive.
     *
     * Note: the method is not part of the public API and is subject to change.
     * In particular, it may be removed if the watch() directive is updated to
     * work with standalone lit-html templates.
     *
     * @internal
     */
    _updateWatchDirective(d) {
      this.__pendingWatches.add(d);
      const shouldRender = this.__doFullRender;
      this.requestUpdate();
      this.__doFullRender = shouldRender;
    }
    /**
     * Clears a watch() directive from the set of pending watches.
     *
     * Note: the method is not part of the public API and is subject to change.
     *
     * @internal
     */
    _clearWatchDirective(d) {
      this.__pendingWatches.delete(d);
    }
  }
  return SignalWatcher2;
}

// node_modules/lit-html/development/directive-helpers.js
var { _ChildPart: ChildPart } = _$LH;
var ENABLE_SHADYDOM_NOPATCH = true;
var _a, _b;
var wrap = ENABLE_SHADYDOM_NOPATCH && ((_a = window.ShadyDOM) == null ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) == null ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
var isSingleExpression = (part) => part.strings === void 0;
var createMarker = () => document.createComment("");
var insertPart = (containerPart, refPart, part) => {
  var _a3;
  const container = wrap(containerPart._$startNode).parentNode;
  const refNode = refPart === void 0 ? containerPart._$endNode : refPart._$startNode;
  if (part === void 0) {
    const startNode = wrap(container).insertBefore(createMarker(), refNode);
    const endNode = wrap(container).insertBefore(createMarker(), refNode);
    part = new ChildPart(startNode, endNode, containerPart, containerPart.options);
  } else {
    const endNode = wrap(part._$endNode).nextSibling;
    const oldParent = part._$parent;
    const parentChanged = oldParent !== containerPart;
    if (parentChanged) {
      (_a3 = part._$reparentDisconnectables) == null ? void 0 : _a3.call(part, containerPart);
      part._$parent = containerPart;
      let newConnectionState;
      if (part._$notifyConnectionChanged !== void 0 && (newConnectionState = containerPart._$isConnected) !== oldParent._$isConnected) {
        part._$notifyConnectionChanged(newConnectionState);
      }
    }
    if (endNode !== refNode || parentChanged) {
      let start = part._$startNode;
      while (start !== endNode) {
        const n = wrap(start).nextSibling;
        wrap(container).insertBefore(start, refNode);
        start = n;
      }
    }
  }
  return part;
};
var setChildPartValue = (part, value, directiveParent = part) => {
  part._$setValue(value, directiveParent);
  return part;
};
var RESET_VALUE = {};
var setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
var getCommittedValue = (part) => part._$committedValue;
var removePart = (part) => {
  part._$clear();
  part._$startNode.remove();
};

// node_modules/lit-html/development/async-directive.js
var DEV_MODE = true;
var notifyChildrenConnectedChanged = (parent, isConnected) => {
  var _a3;
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    (_a3 = obj["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _a3.call(obj, isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
var removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while ((children == null ? void 0 : children.size) === 0);
};
var addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i = fromPartIndex; i < value.length; i++) {
        notifyChildrenConnectedChanged(value[i], false);
        removeDisconnectableFromParent(value[i]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
var installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ?? (obj._$notifyConnectionChanged = notifyChildPartConnectedChanged);
    obj._$reparentDisconnectables ?? (obj._$reparentDisconnectables = reparentDisconnectables);
  }
};
var AsyncDirective = class extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    var _a3, _b2;
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        (_a3 = this.reconnected) == null ? void 0 : _a3.call(this);
      } else {
        (_b2 = this.disconnected) == null ? void 0 : _b2.call(this);
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (DEV_MODE && this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/@lit-labs/signals/development/lib/watch.js
var WatchDirective = class extends AsyncDirective {
  __watch() {
    if (this.__watcher !== void 0) {
      return;
    }
    this.__computed = new Signal.Computed(() => {
      var _a3;
      return (_a3 = this.__signal) === null || _a3 === void 0 ? void 0 : _a3.get();
    });
    const watcher2 = this.__watcher = new Signal.subtle.Watcher(() => {
      var _a3;
      (_a3 = this.__host) === null || _a3 === void 0 ? void 0 : _a3._updateWatchDirective(this);
      watcher2.watch();
    });
    watcher2.watch(this.__computed);
  }
  __unwatch() {
    var _a3;
    if (this.__watcher !== void 0) {
      this.__watcher.unwatch(this.__computed);
      this.__computed = void 0;
      this.__watcher = void 0;
      (_a3 = this.__host) === null || _a3 === void 0 ? void 0 : _a3._clearWatchDirective(this);
    }
  }
  commit() {
    this.setValue(Signal.subtle.untrack(() => {
      var _a3;
      return (_a3 = this.__computed) === null || _a3 === void 0 ? void 0 : _a3.get();
    }));
  }
  render(signal) {
    return Signal.subtle.untrack(() => signal.get());
  }
  update(part, [signal]) {
    var _a3, _b2;
    (_a3 = this.__host) !== null && _a3 !== void 0 ? _a3 : this.__host = (_b2 = part.options) === null || _b2 === void 0 ? void 0 : _b2.host;
    if (signal !== this.__signal && this.__signal !== void 0) {
      this.__unwatch();
    }
    this.__signal = signal;
    this.__watch();
    return Signal.subtle.untrack(() => this.__computed.get());
  }
  disconnected() {
    this.__unwatch();
  }
  reconnected() {
    this.__watch();
  }
};
var watch = directive(WatchDirective);

// node_modules/@lit-labs/signals/development/lib/html-tag.js
var withWatch = (coreTag) => (strings, ...values) => {
  return coreTag(strings, ...values.map((v) => v instanceof Signal.State || v instanceof Signal.Computed ? watch(v) : v));
};
var html2 = withWatch(html);
var svg2 = withWatch(svg);

// node_modules/@lit-labs/signals/development/index.js
var State = Signal.State;
var Computed = Signal.Computed;

// node_modules/@lit/context/development/lib/context-request-event.js
var ContextRequestEvent = class extends Event {
  /**
   *
   * @param context the context key to request
   * @param contextTarget the original context target of the requester
   * @param callback the callback that should be invoked when the context with the specified key is available
   * @param subscribe when, true indicates we want to subscribe to future updates
   */
  constructor(context, contextTarget, callback, subscribe) {
    super("context-request", { bubbles: true, composed: true });
    this.context = context;
    this.contextTarget = contextTarget;
    this.callback = callback;
    this.subscribe = subscribe ?? false;
  }
};

// node_modules/@lit/context/development/lib/create-context.js
function createContext(key) {
  return key;
}

// node_modules/@lit/context/development/lib/controllers/context-consumer.js
var ContextConsumer = class {
  constructor(host, contextOrOptions, callback, subscribe) {
    this.subscribe = false;
    this.provided = false;
    this.value = void 0;
    this._callback = (value, unsubscribe) => {
      if (this.unsubscribe) {
        if (this.unsubscribe !== unsubscribe) {
          this.provided = false;
          this.unsubscribe();
        }
        if (!this.subscribe) {
          this.unsubscribe();
        }
      }
      this.value = value;
      this.host.requestUpdate();
      if (!this.provided || this.subscribe) {
        this.provided = true;
        if (this.callback) {
          this.callback(value, unsubscribe);
        }
      }
      this.unsubscribe = unsubscribe;
    };
    this.host = host;
    if (contextOrOptions.context !== void 0) {
      const options = contextOrOptions;
      this.context = options.context;
      this.callback = options.callback;
      this.subscribe = options.subscribe ?? false;
    } else {
      this.context = contextOrOptions;
      this.callback = callback;
      this.subscribe = subscribe ?? false;
    }
    this.host.addController(this);
  }
  hostConnected() {
    this.dispatchRequest();
  }
  hostDisconnected() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = void 0;
    }
  }
  dispatchRequest() {
    this.host.dispatchEvent(new ContextRequestEvent(this.context, this.host, this._callback, this.subscribe));
  }
};

// node_modules/@lit/context/development/lib/value-notifier.js
var ValueNotifier = class {
  get value() {
    return this._value;
  }
  set value(v) {
    this.setValue(v);
  }
  setValue(v, force = false) {
    const update = force || !Object.is(v, this._value);
    this._value = v;
    if (update) {
      this.updateObservers();
    }
  }
  constructor(defaultValue) {
    this.subscriptions = /* @__PURE__ */ new Map();
    this.updateObservers = () => {
      for (const [callback, { disposer }] of this.subscriptions) {
        callback(this._value, disposer);
      }
    };
    if (defaultValue !== void 0) {
      this.value = defaultValue;
    }
  }
  addCallback(callback, consumerHost, subscribe) {
    if (!subscribe) {
      callback(this.value);
      return;
    }
    if (!this.subscriptions.has(callback)) {
      this.subscriptions.set(callback, {
        disposer: () => {
          this.subscriptions.delete(callback);
        },
        consumerHost
      });
    }
    const { disposer } = this.subscriptions.get(callback);
    callback(this.value, disposer);
  }
  clearCallbacks() {
    this.subscriptions.clear();
  }
};

// node_modules/@lit/context/development/lib/controllers/context-provider.js
var ContextProviderEvent = class extends Event {
  /**
   *
   * @param context the context which this provider can provide
   * @param contextTarget the original context target of the provider
   */
  constructor(context, contextTarget) {
    super("context-provider", { bubbles: true, composed: true });
    this.context = context;
    this.contextTarget = contextTarget;
  }
};
var ContextProvider = class extends ValueNotifier {
  constructor(host, contextOrOptions, initialValue) {
    var _a3, _b2;
    super(contextOrOptions.context !== void 0 ? contextOrOptions.initialValue : initialValue);
    this.onContextRequest = (ev) => {
      if (ev.context !== this.context) {
        return;
      }
      const consumerHost = ev.contextTarget ?? ev.composedPath()[0];
      if (consumerHost === this.host) {
        return;
      }
      ev.stopPropagation();
      this.addCallback(ev.callback, consumerHost, ev.subscribe);
    };
    this.onProviderRequest = (ev) => {
      if (ev.context !== this.context) {
        return;
      }
      const childProviderHost = ev.contextTarget ?? ev.composedPath()[0];
      if (childProviderHost === this.host) {
        return;
      }
      const seen = /* @__PURE__ */ new Set();
      for (const [callback, { consumerHost }] of this.subscriptions) {
        if (seen.has(callback)) {
          continue;
        }
        seen.add(callback);
        consumerHost.dispatchEvent(new ContextRequestEvent(this.context, consumerHost, callback, true));
      }
      ev.stopPropagation();
    };
    this.host = host;
    if (contextOrOptions.context !== void 0) {
      this.context = contextOrOptions.context;
    } else {
      this.context = contextOrOptions;
    }
    this.attachListeners();
    (_b2 = (_a3 = this.host).addController) == null ? void 0 : _b2.call(_a3, this);
  }
  attachListeners() {
    this.host.addEventListener("context-request", this.onContextRequest);
    this.host.addEventListener("context-provider", this.onProviderRequest);
  }
  hostConnected() {
    this.host.dispatchEvent(new ContextProviderEvent(this.context, this.host));
  }
};

// node_modules/@lit/context/development/lib/decorators/provide.js
function provide({ context }) {
  return ((protoOrTarget, nameOrContext) => {
    const controllerMap = /* @__PURE__ */ new WeakMap();
    if (typeof nameOrContext === "object") {
      return {
        get() {
          return protoOrTarget.get.call(this);
        },
        set(value) {
          controllerMap.get(this).setValue(value);
          return protoOrTarget.set.call(this, value);
        },
        init(value) {
          controllerMap.set(this, new ContextProvider(this, { context, initialValue: value }));
          return value;
        }
      };
    } else {
      protoOrTarget.constructor.addInitializer((element) => {
        controllerMap.set(element, new ContextProvider(element, { context }));
      });
      const descriptor = Object.getOwnPropertyDescriptor(protoOrTarget, nameOrContext);
      let newDescriptor;
      if (descriptor === void 0) {
        const valueMap = /* @__PURE__ */ new WeakMap();
        newDescriptor = {
          get() {
            return valueMap.get(this);
          },
          set(value) {
            controllerMap.get(this).setValue(value);
            valueMap.set(this, value);
          },
          configurable: true,
          enumerable: true
        };
      } else {
        const oldSetter = descriptor.set;
        newDescriptor = {
          ...descriptor,
          set(value) {
            controllerMap.get(this).setValue(value);
            oldSetter == null ? void 0 : oldSetter.call(this, value);
          }
        };
      }
      Object.defineProperty(protoOrTarget, nameOrContext, newDescriptor);
      return;
    }
  });
}

// node_modules/@lit/context/development/lib/decorators/consume.js
function consume({ context, subscribe }) {
  return ((protoOrTarget, nameOrContext) => {
    if (typeof nameOrContext === "object") {
      nameOrContext.addInitializer(function() {
        new ContextConsumer(this, {
          context,
          callback: (value) => {
            protoOrTarget.set.call(this, value);
          },
          subscribe
        });
      });
    } else {
      protoOrTarget.constructor.addInitializer((element) => {
        new ContextConsumer(element, {
          context,
          callback: (value) => {
            element[nameOrContext] = value;
          },
          subscribe
        });
      });
    }
  });
}

// node_modules/@lit/reactive-element/development/decorators/custom-element.js
var customElement = (tagName) => (classOrTarget, context) => {
  if (context !== void 0) {
    context.addInitializer(() => {
      customElements.define(tagName, classOrTarget);
    });
  } else {
    customElements.define(tagName, classOrTarget);
  }
};

// node_modules/@lit/reactive-element/development/decorators/property.js
var DEV_MODE2 = true;
var issueWarning;
if (DEV_MODE2) {
  globalThis.litIssuedWarnings ?? (globalThis.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning = (code2, warning) => {
    warning += ` See https://lit.dev/msg/${code2} for more information.`;
    if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code2)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
}
var legacyProperty = (options, proto, name) => {
  const hasOwnProperty = proto.hasOwnProperty(name);
  proto.constructor.createProperty(name, options);
  return hasOwnProperty ? Object.getOwnPropertyDescriptor(proto, name) : void 0;
};
var defaultPropertyDeclaration = {
  attribute: true,
  type: String,
  converter: defaultConverter,
  reflect: false,
  hasChanged: notEqual
};
var standardProperty = (options = defaultPropertyDeclaration, target, context) => {
  const { kind, metadata } = context;
  if (DEV_MODE2 && metadata == null) {
    issueWarning("missing-class-metadata", `The class ${target} is missing decorator metadata. This could mean that you're using a compiler that supports decorators but doesn't support decorator metadata, such as TypeScript 5.1. Please update your compiler.`);
  }
  let properties = globalThis.litPropertyMetadata.get(metadata);
  if (properties === void 0) {
    globalThis.litPropertyMetadata.set(metadata, properties = /* @__PURE__ */ new Map());
  }
  if (kind === "setter") {
    options = Object.create(options);
    options.wrapped = true;
  }
  properties.set(context.name, options);
  if (kind === "accessor") {
    const { name } = context;
    return {
      set(v) {
        const oldValue = target.get.call(this);
        target.set.call(this, v);
        this.requestUpdate(name, oldValue, options, true, v);
      },
      init(v) {
        if (v !== void 0) {
          this._$changeProperty(name, void 0, options, v);
        }
        return v;
      }
    };
  } else if (kind === "setter") {
    const { name } = context;
    return function(value) {
      const oldValue = this[name];
      target.call(this, value);
      this.requestUpdate(name, oldValue, options, true, value);
    };
  }
  throw new Error(`Unsupported decorator location: ${kind}`);
};
function property(options) {
  return (protoOrTarget, nameOrContext) => {
    return typeof nameOrContext === "object" ? standardProperty(options, protoOrTarget, nameOrContext) : legacyProperty(options, protoOrTarget, nameOrContext);
  };
}

// node_modules/@lit/reactive-element/development/decorators/state.js
function state(options) {
  return property({
    ...options,
    // Add both `state` and `attribute` because we found a third party
    // controller that is keying off of PropertyOptions.state to determine
    // whether a field is a private internal property or not.
    state: true,
    attribute: false
  });
}

// node_modules/@lit/reactive-element/development/decorators/base.js
var desc = (obj, name, descriptor) => {
  descriptor.configurable = true;
  descriptor.enumerable = true;
  if (
    // We check for Reflect.decorate each time, in case the zombiefill
    // is applied via lazy loading some Angular code.
    Reflect.decorate && typeof name !== "object"
  ) {
    Object.defineProperty(obj, name, descriptor);
  }
  return descriptor;
};

// node_modules/@lit/reactive-element/development/decorators/query.js
var DEV_MODE3 = true;
var issueWarning2;
if (DEV_MODE3) {
  globalThis.litIssuedWarnings ?? (globalThis.litIssuedWarnings = /* @__PURE__ */ new Set());
  issueWarning2 = (code2, warning) => {
    warning += code2 ? ` See https://lit.dev/msg/${code2} for more information.` : "";
    if (!globalThis.litIssuedWarnings.has(warning) && !globalThis.litIssuedWarnings.has(code2)) {
      console.warn(warning);
      globalThis.litIssuedWarnings.add(warning);
    }
  };
}
function query(selector, cache) {
  return ((protoOrTarget, nameOrContext, descriptor) => {
    const doQuery = (el) => {
      var _a3;
      const result = ((_a3 = el.renderRoot) == null ? void 0 : _a3.querySelector(selector)) ?? null;
      if (DEV_MODE3 && result === null && cache && !el.hasUpdated) {
        const name = typeof nameOrContext === "object" ? nameOrContext.name : nameOrContext;
        issueWarning2("", `@query'd field ${JSON.stringify(String(name))} with the 'cache' flag set for selector '${selector}' has been accessed before the first update and returned null. This is expected if the renderRoot tree has not been provided beforehand (e.g. via Declarative Shadow DOM). Therefore the value hasn't been cached.`);
      }
      return result;
    };
    if (cache) {
      const { get, set: set2 } = typeof nameOrContext === "object" ? protoOrTarget : descriptor ?? (() => {
        const key = DEV_MODE3 ? Symbol(`${String(nameOrContext)} (@query() cache)`) : Symbol();
        return {
          get() {
            return this[key];
          },
          set(v) {
            this[key] = v;
          }
        };
      })();
      return desc(protoOrTarget, nameOrContext, {
        get() {
          let result = get.call(this);
          if (result === void 0) {
            result = doQuery(this);
            if (result !== null || this.hasUpdated) {
              set2.call(this, result);
            }
          }
          return result;
        }
      });
    } else {
      return desc(protoOrTarget, nameOrContext, {
        get() {
          return doQuery(this);
        }
      });
    }
  });
}

// node_modules/@a2ui/lit/dist/src/0.8/ui/ui.js
var ui_exports = {};
__export(ui_exports, {
  Audio: () => Audio,
  Button: () => Button,
  Card: () => Card,
  Checkbox: () => Checkbox,
  Column: () => Column,
  ComponentRegistry: () => ComponentRegistry,
  Context: () => theme_exports,
  DateTimeInput: () => DateTimeInput,
  Divider: () => Divider,
  Icon: () => Icon,
  Image: () => Image,
  List: () => List,
  Modal: () => Modal,
  MultipleChoice: () => MultipleChoice,
  Root: () => Root,
  Row: () => Row,
  Slider: () => Slider,
  Surface: () => Surface,
  Tabs: () => Tabs,
  Text: () => Text,
  TextField: () => TextField,
  Utils: () => utils_exports,
  Video: () => Video,
  componentRegistry: () => componentRegistry,
  instanceOf: () => instanceOf,
  registerCustomComponents: () => registerCustomComponents
});

// node_modules/lit-html/development/directives/map.js
function* map(items, f) {
  if (items !== void 0) {
    let i = 0;
    for (const value of items) {
      yield f(value, i++);
    }
  }
}

// node_modules/signal-utils/dist/subtle/microtask-effect.ts.js
var pending = false;
var watcher = new Signal.subtle.Watcher(() => {
  if (!pending) {
    pending = true;
    queueMicrotask(() => {
      pending = false;
      flushPending();
    });
  }
});
function flushPending() {
  for (const signal of watcher.getPending()) {
    signal.get();
  }
  watcher.watch();
}
function effect(cb) {
  let c = new Signal.Computed(() => cb());
  watcher.watch(c);
  c.get();
  return () => {
    watcher.unwatch(c);
  };
}

// node_modules/@a2ui/lit/dist/src/0.8/ui/context/theme.js
var theme_exports = {};
__export(theme_exports, {
  themeContext: () => themeContext
});
var themeContext = createContext("A2UITheme");

// node_modules/@a2ui/lit/dist/src/0.8/styles/index.js
var styles_exports = {};
__export(styles_exports, {
  appendToAll: () => appendToAll,
  createThemeStyles: () => createThemeStyles,
  merge: () => merge,
  structuralStyles: () => structuralStyles,
  toProp: () => toProp
});

// node_modules/@a2ui/lit/dist/src/0.8/styles/behavior.js
var opacityBehavior = `
  &:not([disabled]) {
    cursor: pointer;
    opacity: var(--opacity, 0);
    transition: opacity var(--speed, 0.2s) cubic-bezier(0, 0, 0.3, 1);

    &:hover,
    &:focus {
      opacity: 1;
    }
  }`;
var behavior = `
  ${new Array(21).fill(0).map((_, idx) => {
  return `.behavior-ho-${idx * 5} {
          --opacity: ${idx / 20};
          ${opacityBehavior}
        }`;
}).join("\n")}

  .behavior-o-s {
    overflow: scroll;
  }

  .behavior-o-a {
    overflow: auto;
  }

  .behavior-o-h {
    overflow: hidden;
  }

  .behavior-sw-n {
    scrollbar-width: none;
  }
`;

// node_modules/@a2ui/lit/dist/src/0.8/styles/shared.js
var grid = 4;

// node_modules/@a2ui/lit/dist/src/0.8/styles/border.js
var border = `
  ${new Array(25).fill(0).map((_, idx) => {
  return `
        .border-bw-${idx} { border-width: ${idx}px; }
        .border-btw-${idx} { border-top-width: ${idx}px; }
        .border-bbw-${idx} { border-bottom-width: ${idx}px; }
        .border-blw-${idx} { border-left-width: ${idx}px; }
        .border-brw-${idx} { border-right-width: ${idx}px; }

        .border-ow-${idx} { outline-width: ${idx}px; }
        .border-br-${idx} { border-radius: ${idx * grid}px; overflow: hidden;}`;
}).join("\n")}

  .border-br-50pc {
    border-radius: 50%;
  }

  .border-bs-s {
    border-style: solid;
  }
`;

// node_modules/@a2ui/lit/dist/src/0.8/types/colors.js
var shades = [
  0,
  5,
  10,
  15,
  20,
  25,
  30,
  35,
  40,
  50,
  60,
  70,
  80,
  90,
  95,
  98,
  99,
  100
];

// node_modules/@a2ui/lit/dist/src/0.8/styles/utils.js
function merge(...classes) {
  const styles = {};
  for (const clazz of classes) {
    for (const [key, val] of Object.entries(clazz)) {
      const prefix = key.split("-").with(-1, "").join("-");
      const existingKeys = Object.keys(styles).filter((key2) => key2.startsWith(prefix));
      for (const existingKey of existingKeys) {
        delete styles[existingKey];
      }
      styles[key] = val;
    }
  }
  return styles;
}
function appendToAll(target, exclusions, ...classes) {
  const updatedTarget = structuredClone(target);
  for (const clazz of classes) {
    for (const key of Object.keys(clazz)) {
      const prefix = key.split("-").with(-1, "").join("-");
      for (const [tagName, classesToAdd] of Object.entries(updatedTarget)) {
        if (exclusions.includes(tagName)) {
          continue;
        }
        let found = false;
        for (let t = 0; t < classesToAdd.length; t++) {
          if (classesToAdd[t].startsWith(prefix)) {
            found = true;
            classesToAdd[t] = key;
          }
        }
        if (!found) {
          classesToAdd.push(key);
        }
      }
    }
  }
  return updatedTarget;
}
function createThemeStyles(palettes) {
  const styles = {};
  for (const palette of Object.values(palettes)) {
    for (const [key, val] of Object.entries(palette)) {
      const prop = toProp(key);
      styles[prop] = val;
    }
  }
  return styles;
}
function toProp(key) {
  if (key.startsWith("nv")) {
    return `--nv-${key.slice(2)}`;
  }
  return `--${key[0]}-${key.slice(1)}`;
}

// node_modules/@a2ui/lit/dist/src/0.8/styles/colors.js
var color = (src) => `
    ${src.map((key) => {
  const inverseKey = getInverseKey(key);
  return `.color-bc-${key} { border-color: light-dark(var(${toProp(key)}), var(${toProp(inverseKey)})); }`;
}).join("\n")}

    ${src.map((key) => {
  const inverseKey = getInverseKey(key);
  const vals = [
    `.color-bgc-${key} { background-color: light-dark(var(${toProp(key)}), var(${toProp(inverseKey)})); }`,
    `.color-bbgc-${key}::backdrop { background-color: light-dark(var(${toProp(key)}), var(${toProp(inverseKey)})); }`
  ];
  for (let o = 0.1; o < 1; o += 0.1) {
    vals.push(`.color-bbgc-${key}_${(o * 100).toFixed(0)}::backdrop {
            background-color: light-dark(oklch(from var(${toProp(key)}) l c h / calc(alpha * ${o.toFixed(1)})), oklch(from var(${toProp(inverseKey)}) l c h / calc(alpha * ${o.toFixed(1)})) );
          }
        `);
  }
  return vals.join("\n");
}).join("\n")}

  ${src.map((key) => {
  const inverseKey = getInverseKey(key);
  return `.color-c-${key} { color: light-dark(var(${toProp(key)}), var(${toProp(inverseKey)})); }`;
}).join("\n")}
  `;
var getInverseKey = (key) => {
  const match2 = key.match(/^([a-z]+)(\d+)$/);
  if (!match2)
    return key;
  const [, prefix, shadeStr] = match2;
  const shade = parseInt(shadeStr, 10);
  const target = 100 - shade;
  const inverseShade = shades.reduce((prev, curr) => Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev);
  return `${prefix}${inverseShade}`;
};
var keyFactory = (prefix) => {
  return shades.map((v) => `${prefix}${v}`);
};
var colors = [
  color(keyFactory("p")),
  color(keyFactory("s")),
  color(keyFactory("t")),
  color(keyFactory("n")),
  color(keyFactory("nv")),
  color(keyFactory("e")),
  `
    .color-bgc-transparent {
      background-color: transparent;
    }

    :host {
      color-scheme: var(--color-scheme);
    }
  `
];

// node_modules/@a2ui/lit/dist/src/0.8/styles/icons.js
var icons = `
  .g-icon {
    font-family: "Material Symbols Outlined", "Google Symbols";
    font-weight: normal;
    font-style: normal;
    font-display: optional;
    font-size: 20px;
    width: 1em;
    height: 1em;
    user-select: none;
    line-height: 1;
    letter-spacing: normal;
    text-transform: none;
    display: inline-block;
    white-space: nowrap;
    word-wrap: normal;
    direction: ltr;
    -webkit-font-feature-settings: "liga";
    -webkit-font-smoothing: antialiased;
    overflow: hidden;

    font-variation-settings: "FILL" 0, "wght" 300, "GRAD" 0, "opsz" 48,
      "ROND" 100;

    &.filled {
      font-variation-settings: "FILL" 1, "wght" 300, "GRAD" 0, "opsz" 48,
        "ROND" 100;
    }

    &.filled-heavy {
      font-variation-settings: "FILL" 1, "wght" 700, "GRAD" 0, "opsz" 48,
        "ROND" 100;
    }
  }
`;

// node_modules/@a2ui/lit/dist/src/0.8/styles/layout.js
var layout = `
  :host {
    ${new Array(16).fill(0).map((_, idx) => {
  return `--g-${idx + 1}: ${(idx + 1) * grid}px;`;
}).join("\n")}
  }

  ${new Array(49).fill(0).map((_, index) => {
  const idx = index - 24;
  const lbl = idx < 0 ? `n${Math.abs(idx)}` : idx.toString();
  return `
        .layout-p-${lbl} { --padding: ${idx * grid}px; padding: var(--padding); }
        .layout-pt-${lbl} { padding-top: ${idx * grid}px; }
        .layout-pr-${lbl} { padding-right: ${idx * grid}px; }
        .layout-pb-${lbl} { padding-bottom: ${idx * grid}px; }
        .layout-pl-${lbl} { padding-left: ${idx * grid}px; }

        .layout-m-${lbl} { --margin: ${idx * grid}px; margin: var(--margin); }
        .layout-mt-${lbl} { margin-top: ${idx * grid}px; }
        .layout-mr-${lbl} { margin-right: ${idx * grid}px; }
        .layout-mb-${lbl} { margin-bottom: ${idx * grid}px; }
        .layout-ml-${lbl} { margin-left: ${idx * grid}px; }

        .layout-t-${lbl} { top: ${idx * grid}px; }
        .layout-r-${lbl} { right: ${idx * grid}px; }
        .layout-b-${lbl} { bottom: ${idx * grid}px; }
        .layout-l-${lbl} { left: ${idx * grid}px; }`;
}).join("\n")}

  ${new Array(25).fill(0).map((_, idx) => {
  return `
        .layout-g-${idx} { gap: ${idx * grid}px; }`;
}).join("\n")}

  ${new Array(8).fill(0).map((_, idx) => {
  return `
        .layout-grd-col${idx + 1} { grid-template-columns: ${"1fr ".repeat(idx + 1).trim()}; }`;
}).join("\n")}

  .layout-pos-a {
    position: absolute;
  }

  .layout-pos-rel {
    position: relative;
  }

  .layout-dsp-none {
    display: none;
  }

  .layout-dsp-block {
    display: block;
  }

  .layout-dsp-grid {
    display: grid;
  }

  .layout-dsp-iflex {
    display: inline-flex;
  }

  .layout-dsp-flexvert {
    display: flex;
    flex-direction: column;
  }

  .layout-dsp-flexhor {
    display: flex;
    flex-direction: row;
  }

  .layout-fw-w {
    flex-wrap: wrap;
  }

  .layout-al-fs {
    align-items: start;
  }

  .layout-al-fe {
    align-items: end;
  }

  .layout-al-c {
    align-items: center;
  }

  .layout-as-n {
    align-self: normal;
  }

  .layout-js-c {
    justify-self: center;
  }

  .layout-sp-c {
    justify-content: center;
  }

  .layout-sp-ev {
    justify-content: space-evenly;
  }

  .layout-sp-bt {
    justify-content: space-between;
  }

  .layout-sp-s {
    justify-content: start;
  }

  .layout-sp-e {
    justify-content: end;
  }

  .layout-ji-e {
    justify-items: end;
  }

  .layout-r-none {
    resize: none;
  }

  .layout-fs-c {
    field-sizing: content;
  }

  .layout-fs-n {
    field-sizing: none;
  }

  .layout-flx-0 {
    flex: 0 0 auto;
  }

  .layout-flx-1 {
    flex: 1 0 auto;
  }

  .layout-c-s {
    contain: strict;
  }

  /** Widths **/

  ${new Array(10).fill(0).map((_, idx) => {
  const weight = (idx + 1) * 10;
  return `.layout-w-${weight} { width: ${weight}%; max-width: ${weight}%; }`;
}).join("\n")}

  ${new Array(16).fill(0).map((_, idx) => {
  const weight = idx * grid;
  return `.layout-wp-${idx} { width: ${weight}px; }`;
}).join("\n")}

  /** Heights **/

  ${new Array(10).fill(0).map((_, idx) => {
  const height = (idx + 1) * 10;
  return `.layout-h-${height} { height: ${height}%; }`;
}).join("\n")}

  ${new Array(16).fill(0).map((_, idx) => {
  const height = idx * grid;
  return `.layout-hp-${idx} { height: ${height}px; }`;
}).join("\n")}

  .layout-el-cv {
    & img,
    & video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      margin: 0;
    }
  }

  .layout-ar-sq {
    aspect-ratio: 1 / 1;
  }

  .layout-ex-fb {
    margin: calc(var(--padding) * -1) 0 0 calc(var(--padding) * -1);
    width: calc(100% + var(--padding) * 2);
    height: calc(100% + var(--padding) * 2);
  }
`;

// node_modules/@a2ui/lit/dist/src/0.8/styles/opacity.js
var opacity = `
  ${new Array(21).fill(0).map((_, idx) => {
  return `.opacity-el-${idx * 5} { opacity: ${idx / 20}; }`;
}).join("\n")}
`;

// node_modules/@a2ui/lit/dist/src/0.8/styles/type.js
var type = `
  :host {
    --default-font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    --default-font-family-mono: "Courier New", Courier, monospace;
  }

  .typography-f-s {
    font-family: var(--font-family, var(--default-font-family));
    font-optical-sizing: auto;
    font-variation-settings: "slnt" 0, "wdth" 100, "GRAD" 0;
  }

  .typography-f-sf {
    font-family: var(--font-family-flex, var(--default-font-family));
    font-optical-sizing: auto;
  }

  .typography-f-c {
    font-family: var(--font-family-mono, var(--default-font-family));
    font-optical-sizing: auto;
    font-variation-settings: "slnt" 0, "wdth" 100, "GRAD" 0;
  }

  .typography-v-r {
    font-variation-settings: "slnt" 0, "wdth" 100, "GRAD" 0, "ROND" 100;
  }

  .typography-ta-s {
    text-align: start;
  }

  .typography-ta-c {
    text-align: center;
  }

  .typography-fs-n {
    font-style: normal;
  }

  .typography-fs-i {
    font-style: italic;
  }

  .typography-sz-ls {
    font-size: 11px;
    line-height: 16px;
  }

  .typography-sz-lm {
    font-size: 12px;
    line-height: 16px;
  }

  .typography-sz-ll {
    font-size: 14px;
    line-height: 20px;
  }

  .typography-sz-bs {
    font-size: 12px;
    line-height: 16px;
  }

  .typography-sz-bm {
    font-size: 14px;
    line-height: 20px;
  }

  .typography-sz-bl {
    font-size: 16px;
    line-height: 24px;
  }

  .typography-sz-ts {
    font-size: 14px;
    line-height: 20px;
  }

  .typography-sz-tm {
    font-size: 16px;
    line-height: 24px;
  }

  .typography-sz-tl {
    font-size: 22px;
    line-height: 28px;
  }

  .typography-sz-hs {
    font-size: 24px;
    line-height: 32px;
  }

  .typography-sz-hm {
    font-size: 28px;
    line-height: 36px;
  }

  .typography-sz-hl {
    font-size: 32px;
    line-height: 40px;
  }

  .typography-sz-ds {
    font-size: 36px;
    line-height: 44px;
  }

  .typography-sz-dm {
    font-size: 45px;
    line-height: 52px;
  }

  .typography-sz-dl {
    font-size: 57px;
    line-height: 64px;
  }

  .typography-ws-p {
    white-space: pre-line;
  }

  .typography-ws-nw {
    white-space: nowrap;
  }

  .typography-td-none {
    text-decoration: none;
  }

  /** Weights **/

  ${new Array(9).fill(0).map((_, idx) => {
  const weight = (idx + 1) * 100;
  return `.typography-w-${weight} { font-weight: ${weight}; }`;
}).join("\n")}
`;

// node_modules/@a2ui/lit/dist/src/0.8/styles/index.js
var structuralStyles = [
  behavior,
  border,
  colors,
  icons,
  layout,
  opacity,
  type
].flat(Infinity).join("\n");

// node_modules/@a2ui/lit/dist/src/0.8/ui/styles.js
var structuralStyles2 = unsafeCSS(structuralStyles);

// node_modules/@a2ui/lit/dist/src/0.8/ui/component-registry.js
var ComponentRegistry = class {
  constructor() {
    this.registry = /* @__PURE__ */ new Map();
  }
  register(typeName, constructor, tagName) {
    if (!/^[a-zA-Z0-9]+$/.test(typeName)) {
      throw new Error(`[Registry] Invalid typeName '${typeName}'. Must be alphanumeric.`);
    }
    this.registry.set(typeName, constructor);
    const actualTagName = tagName || `a2ui-custom-${typeName.toLowerCase()}`;
    const existingName = customElements.getName(constructor);
    if (existingName) {
      if (existingName !== actualTagName) {
        throw new Error(`Component ${typeName} is already registered as ${existingName}, but requested as ${actualTagName}.`);
      }
      return;
    }
    if (!customElements.get(actualTagName)) {
      customElements.define(actualTagName, constructor);
    }
  }
  get(typeName) {
    return this.registry.get(typeName);
  }
};
var componentRegistry = new ComponentRegistry();

// node_modules/@a2ui/lit/dist/src/0.8/ui/root.js
var __runInitializers = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var Root = (() => {
  var _surfaceId_accessor_storage, _component_accessor_storage, _theme_accessor_storage, _childComponents_accessor_storage, _processor_accessor_storage, _dataContextPath_accessor_storage, _enableCustomElements_accessor_storage, _weight, _lightDomEffectDisposer, _a3;
  let _classDecorators = [customElement("a2ui-root")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = SignalWatcher(LitElement);
  let _instanceExtraInitializers = [];
  let _surfaceId_decorators;
  let _surfaceId_initializers = [];
  let _surfaceId_extraInitializers = [];
  let _component_decorators;
  let _component_initializers = [];
  let _component_extraInitializers = [];
  let _theme_decorators;
  let _theme_initializers = [];
  let _theme_extraInitializers = [];
  let _childComponents_decorators;
  let _childComponents_initializers = [];
  let _childComponents_extraInitializers = [];
  let _processor_decorators;
  let _processor_initializers = [];
  let _processor_extraInitializers = [];
  let _dataContextPath_decorators;
  let _dataContextPath_initializers = [];
  let _dataContextPath_extraInitializers = [];
  let _enableCustomElements_decorators;
  let _enableCustomElements_initializers = [];
  let _enableCustomElements_extraInitializers = [];
  let _set_weight_decorators;
  var Root2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _surfaceId_accessor_storage, (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _surfaceId_initializers, null)));
      __privateAdd(this, _component_accessor_storage, (__runInitializers(this, _surfaceId_extraInitializers), __runInitializers(this, _component_initializers, null)));
      __privateAdd(this, _theme_accessor_storage, (__runInitializers(this, _component_extraInitializers), __runInitializers(this, _theme_initializers, void 0)));
      __privateAdd(this, _childComponents_accessor_storage, (__runInitializers(this, _theme_extraInitializers), __runInitializers(this, _childComponents_initializers, null)));
      __privateAdd(this, _processor_accessor_storage, (__runInitializers(this, _childComponents_extraInitializers), __runInitializers(this, _processor_initializers, null)));
      __privateAdd(this, _dataContextPath_accessor_storage, (__runInitializers(this, _processor_extraInitializers), __runInitializers(this, _dataContextPath_initializers, "")));
      __privateAdd(this, _enableCustomElements_accessor_storage, (__runInitializers(this, _dataContextPath_extraInitializers), __runInitializers(this, _enableCustomElements_initializers, false)));
      __privateAdd(this, _weight, (__runInitializers(this, _enableCustomElements_extraInitializers), 1));
      /**
       * Holds the cleanup function for our effect.
       * We need this to stop the effect when the component is disconnected.
       */
      __privateAdd(this, _lightDomEffectDisposer, null);
    }
    get surfaceId() {
      return __privateGet(this, _surfaceId_accessor_storage);
    }
    set surfaceId(value) {
      __privateSet(this, _surfaceId_accessor_storage, value);
    }
    get component() {
      return __privateGet(this, _component_accessor_storage);
    }
    set component(value) {
      __privateSet(this, _component_accessor_storage, value);
    }
    get theme() {
      return __privateGet(this, _theme_accessor_storage);
    }
    set theme(value) {
      __privateSet(this, _theme_accessor_storage, value);
    }
    get childComponents() {
      return __privateGet(this, _childComponents_accessor_storage);
    }
    set childComponents(value) {
      __privateSet(this, _childComponents_accessor_storage, value);
    }
    get processor() {
      return __privateGet(this, _processor_accessor_storage);
    }
    set processor(value) {
      __privateSet(this, _processor_accessor_storage, value);
    }
    get dataContextPath() {
      return __privateGet(this, _dataContextPath_accessor_storage);
    }
    set dataContextPath(value) {
      __privateSet(this, _dataContextPath_accessor_storage, value);
    }
    get enableCustomElements() {
      return __privateGet(this, _enableCustomElements_accessor_storage);
    }
    set enableCustomElements(value) {
      __privateSet(this, _enableCustomElements_accessor_storage, value);
    }
    set weight(weight) {
      __privateSet(this, _weight, weight);
      this.style.setProperty("--weight", `${weight}`);
    }
    get weight() {
      return __privateGet(this, _weight);
    }
    willUpdate(changedProperties) {
      if (changedProperties.has("childComponents")) {
        if (__privateGet(this, _lightDomEffectDisposer)) {
          __privateGet(this, _lightDomEffectDisposer).call(this);
        }
        __privateSet(this, _lightDomEffectDisposer, effect(() => {
          const allChildren = this.childComponents ?? null;
          const lightDomTemplate = this.renderComponentTree(allChildren);
          render(lightDomTemplate, this, { host: this });
        }));
      }
    }
    /**
     * Clean up the effect when the component is removed from the DOM.
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      if (__privateGet(this, _lightDomEffectDisposer)) {
        __privateGet(this, _lightDomEffectDisposer).call(this);
      }
    }
    /**
     * Turns the SignalMap into a renderable TemplateResult for Lit.
     */
    renderComponentTree(components) {
      if (!components) {
        return nothing;
      }
      if (!Array.isArray(components)) {
        return nothing;
      }
      return html` ${map(components, (component) => {
        if (this.enableCustomElements) {
          const registeredCtor = componentRegistry.get(component.type);
          const elCtor = registeredCtor || customElements.get(component.type);
          if (elCtor) {
            const node = component;
            const el = new elCtor();
            el.id = node.id;
            if (node.slotName) {
              el.slot = node.slotName;
            }
            el.component = node;
            el.weight = node.weight ?? "initial";
            el.processor = this.processor;
            el.surfaceId = this.surfaceId;
            el.dataContextPath = node.dataContextPath ?? "/";
            for (const [prop, val] of Object.entries(component.properties)) {
              el[prop] = val;
            }
            return html`${el}`;
          }
        }
        switch (component.type) {
          case "List": {
            const node = component;
            const childComponents = node.properties.children;
            return html`<a2ui-list
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .direction=${node.properties.direction ?? "vertical"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .childComponents=${childComponents}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-list>`;
          }
          case "Card": {
            const node = component;
            let childComponents = node.properties.children;
            if (!childComponents && node.properties.child) {
              childComponents = [node.properties.child];
            }
            return html`<a2ui-card
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .childComponents=${childComponents}
            .dataContextPath=${node.dataContextPath ?? ""}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-card>`;
          }
          case "Column": {
            const node = component;
            return html`<a2ui-column
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .childComponents=${node.properties.children ?? null}
            .dataContextPath=${node.dataContextPath ?? ""}
            .alignment=${node.properties.alignment ?? "stretch"}
            .distribution=${node.properties.distribution ?? "start"}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-column>`;
          }
          case "Row": {
            const node = component;
            return html`<a2ui-row
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .childComponents=${node.properties.children ?? null}
            .dataContextPath=${node.dataContextPath ?? ""}
            .alignment=${node.properties.alignment ?? "stretch"}
            .distribution=${node.properties.distribution ?? "start"}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-row>`;
          }
          case "Image": {
            const node = component;
            return html`<a2ui-image
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .url=${node.properties.url ?? null}
            .dataContextPath=${node.dataContextPath ?? ""}
            .usageHint=${node.properties.usageHint}
            .fit=${node.properties.fit}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-image>`;
          }
          case "Icon": {
            const node = component;
            return html`<a2ui-icon
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .name=${node.properties.name ?? null}
            .dataContextPath=${node.dataContextPath ?? ""}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-icon>`;
          }
          case "AudioPlayer": {
            const node = component;
            return html`<a2ui-audioplayer
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .url=${node.properties.url ?? null}
            .dataContextPath=${node.dataContextPath ?? ""}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-audioplayer>`;
          }
          case "Button": {
            const node = component;
            return html`<a2ui-button
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath ?? ""}
            .action=${node.properties.action}
            .childComponents=${[node.properties.child]}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-button>`;
          }
          case "Text": {
            const node = component;
            return html`<a2ui-text
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .model=${this.processor}
            .surfaceId=${this.surfaceId}
            .processor=${this.processor}
            .dataContextPath=${node.dataContextPath}
            .text=${node.properties.text}
            .usageHint=${node.properties.usageHint}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-text>`;
          }
          case "CheckBox": {
            const node = component;
            return html`<a2ui-checkbox
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath ?? ""}
            .label=${node.properties.label}
            .value=${node.properties.value}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-checkbox>`;
          }
          case "DateTimeInput": {
            const node = component;
            return html`<a2ui-datetimeinput
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath ?? ""}
            .enableDate=${node.properties.enableDate ?? true}
            .enableTime=${node.properties.enableTime ?? true}
            .outputFormat=${node.properties.outputFormat}
            .value=${node.properties.value}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-datetimeinput>`;
          }
          case "Divider": {
            const node = component;
            return html`<a2ui-divider
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .thickness=${node.properties.thickness}
            .axis=${node.properties.axis}
            .color=${node.properties.color}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-divider>`;
          }
          case "MultipleChoice": {
            const node = component;
            return html`<a2ui-multiplechoice
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .options=${node.properties.options}
            .maxAllowedSelections=${node.properties.maxAllowedSelections}
            .selections=${node.properties.selections}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-multiplechoice>`;
          }
          case "Slider": {
            const node = component;
            return html`<a2ui-slider
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .value=${node.properties.value}
            .minValue=${node.properties.minValue}
            .maxValue=${node.properties.maxValue}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-slider>`;
          }
          case "TextField": {
            const node = component;
            return html`<a2ui-textfield
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .label=${node.properties.label}
            .text=${node.properties.text}
            .type=${node.properties.type}
            .validationRegexp=${node.properties.validationRegexp}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-textfield>`;
          }
          case "Video": {
            const node = component;
            return html`<a2ui-video
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .url=${node.properties.url}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-video>`;
          }
          case "Tabs": {
            const node = component;
            const titles = [];
            const childComponents = [];
            if (node.properties.tabItems) {
              for (const item of node.properties.tabItems) {
                titles.push(item.title);
                childComponents.push(item.child);
              }
            }
            return html`<a2ui-tabs
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .titles=${titles}
            .childComponents=${childComponents}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-tabs>`;
          }
          case "Modal": {
            const node = component;
            const childComponents = [
              node.properties.entryPointChild,
              node.properties.contentChild
            ];
            node.properties.entryPointChild.slotName = "entry";
            return html`<a2ui-modal
            id=${node.id}
            slot=${node.slotName ? node.slotName : nothing}
            .component=${node}
            .weight=${node.weight ?? "initial"}
            .processor=${this.processor}
            .surfaceId=${this.surfaceId}
            .dataContextPath=${node.dataContextPath}
            .childComponents=${childComponents}
            .enableCustomElements=${this.enableCustomElements}
          ></a2ui-modal>`;
          }
          default: {
            return this.renderCustomComponent(component);
          }
        }
      })}`;
    }
    renderCustomComponent(component) {
      if (!this.enableCustomElements) {
        return;
      }
      const node = component;
      const registeredCtor = componentRegistry.get(component.type);
      const elCtor = registeredCtor || customElements.get(component.type);
      if (!elCtor) {
        return html`Unknown element ${component.type}`;
      }
      const el = new elCtor();
      el.id = node.id;
      if (node.slotName) {
        el.slot = node.slotName;
      }
      el.component = node;
      el.weight = node.weight ?? "initial";
      el.processor = this.processor;
      el.surfaceId = this.surfaceId;
      el.dataContextPath = node.dataContextPath ?? "/";
      for (const [prop, val] of Object.entries(component.properties)) {
        el[prop] = val;
      }
      return html`${el}`;
    }
    render() {
      return html`<slot></slot>`;
    }
  }, _surfaceId_accessor_storage = new WeakMap(), _component_accessor_storage = new WeakMap(), _theme_accessor_storage = new WeakMap(), _childComponents_accessor_storage = new WeakMap(), _processor_accessor_storage = new WeakMap(), _dataContextPath_accessor_storage = new WeakMap(), _enableCustomElements_accessor_storage = new WeakMap(), _weight = new WeakMap(), _lightDomEffectDisposer = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _surfaceId_decorators = [property()];
    _component_decorators = [property()];
    _theme_decorators = [consume({ context: themeContext })];
    _childComponents_decorators = [property({ attribute: false })];
    _processor_decorators = [property({ attribute: false })];
    _dataContextPath_decorators = [property()];
    _enableCustomElements_decorators = [property()];
    _set_weight_decorators = [property()];
    __esDecorate(_a3, null, _surfaceId_decorators, { kind: "accessor", name: "surfaceId", static: false, private: false, access: { has: (obj) => "surfaceId" in obj, get: (obj) => obj.surfaceId, set: (obj, value) => {
      obj.surfaceId = value;
    } }, metadata: _metadata }, _surfaceId_initializers, _surfaceId_extraInitializers);
    __esDecorate(_a3, null, _component_decorators, { kind: "accessor", name: "component", static: false, private: false, access: { has: (obj) => "component" in obj, get: (obj) => obj.component, set: (obj, value) => {
      obj.component = value;
    } }, metadata: _metadata }, _component_initializers, _component_extraInitializers);
    __esDecorate(_a3, null, _theme_decorators, { kind: "accessor", name: "theme", static: false, private: false, access: { has: (obj) => "theme" in obj, get: (obj) => obj.theme, set: (obj, value) => {
      obj.theme = value;
    } }, metadata: _metadata }, _theme_initializers, _theme_extraInitializers);
    __esDecorate(_a3, null, _childComponents_decorators, { kind: "accessor", name: "childComponents", static: false, private: false, access: { has: (obj) => "childComponents" in obj, get: (obj) => obj.childComponents, set: (obj, value) => {
      obj.childComponents = value;
    } }, metadata: _metadata }, _childComponents_initializers, _childComponents_extraInitializers);
    __esDecorate(_a3, null, _processor_decorators, { kind: "accessor", name: "processor", static: false, private: false, access: { has: (obj) => "processor" in obj, get: (obj) => obj.processor, set: (obj, value) => {
      obj.processor = value;
    } }, metadata: _metadata }, _processor_initializers, _processor_extraInitializers);
    __esDecorate(_a3, null, _dataContextPath_decorators, { kind: "accessor", name: "dataContextPath", static: false, private: false, access: { has: (obj) => "dataContextPath" in obj, get: (obj) => obj.dataContextPath, set: (obj, value) => {
      obj.dataContextPath = value;
    } }, metadata: _metadata }, _dataContextPath_initializers, _dataContextPath_extraInitializers);
    __esDecorate(_a3, null, _enableCustomElements_decorators, { kind: "accessor", name: "enableCustomElements", static: false, private: false, access: { has: (obj) => "enableCustomElements" in obj, get: (obj) => obj.enableCustomElements, set: (obj, value) => {
      obj.enableCustomElements = value;
    } }, metadata: _metadata }, _enableCustomElements_initializers, _enableCustomElements_extraInitializers);
    __esDecorate(_a3, null, _set_weight_decorators, { kind: "setter", name: "weight", static: false, private: false, access: { has: (obj) => "weight" in obj, set: (obj, value) => {
      obj.weight = value;
    } }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Root2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      :host {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 80%;
      }
    `
  ], __runInitializers(_classThis, _classExtraInitializers), _a3);
  return Root2 = _classThis;
})();

// node_modules/lit-html/development/directives/class-map.js
var ClassMapDirective = class extends Directive {
  constructor(partInfo) {
    var _a3;
    super(partInfo);
    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== "class" || ((_a3 = partInfo.strings) == null ? void 0 : _a3.length) > 2) {
      throw new Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
  }
  render(classInfo) {
    return " " + Object.keys(classInfo).filter((key) => classInfo[key]).join(" ") + " ";
  }
  update(part, [classInfo]) {
    var _a3, _b2;
    if (this._previousClasses === void 0) {
      this._previousClasses = /* @__PURE__ */ new Set();
      if (part.strings !== void 0) {
        this._staticClasses = new Set(part.strings.join(" ").split(/\s/).filter((s) => s !== ""));
      }
      for (const name in classInfo) {
        if (classInfo[name] && !((_a3 = this._staticClasses) == null ? void 0 : _a3.has(name))) {
          this._previousClasses.add(name);
        }
      }
      return this.render(classInfo);
    }
    const classList = part.element.classList;
    for (const name of this._previousClasses) {
      if (!(name in classInfo)) {
        classList.remove(name);
        this._previousClasses.delete(name);
      }
    }
    for (const name in classInfo) {
      const value = !!classInfo[name];
      if (value !== this._previousClasses.has(name) && !((_b2 = this._staticClasses) == null ? void 0 : _b2.has(name))) {
        if (value) {
          classList.add(name);
          this._previousClasses.add(name);
        } else {
          classList.remove(name);
          this._previousClasses.delete(name);
        }
      }
    }
    return noChange;
  }
};
var classMap = directive(ClassMapDirective);

// node_modules/@a2ui/lit/dist/src/0.8/data/guards.js
var guards_exports = {};
__export(guards_exports, {
  isComponentArrayReference: () => isComponentArrayReference,
  isObject: () => isObject,
  isPath: () => isPath,
  isResolvedAudioPlayer: () => isResolvedAudioPlayer,
  isResolvedButton: () => isResolvedButton,
  isResolvedCard: () => isResolvedCard,
  isResolvedCheckbox: () => isResolvedCheckbox,
  isResolvedColumn: () => isResolvedColumn,
  isResolvedDateTimeInput: () => isResolvedDateTimeInput,
  isResolvedDivider: () => isResolvedDivider,
  isResolvedIcon: () => isResolvedIcon,
  isResolvedImage: () => isResolvedImage,
  isResolvedList: () => isResolvedList,
  isResolvedModal: () => isResolvedModal,
  isResolvedMultipleChoice: () => isResolvedMultipleChoice,
  isResolvedRow: () => isResolvedRow,
  isResolvedSlider: () => isResolvedSlider,
  isResolvedTabs: () => isResolvedTabs,
  isResolvedText: () => isResolvedText,
  isResolvedTextField: () => isResolvedTextField,
  isResolvedVideo: () => isResolvedVideo,
  isValueMap: () => isValueMap
});
function isValueMap(value) {
  return isObject(value) && "key" in value;
}
function isPath(key, value) {
  return key === "path" && typeof value === "string";
}
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isComponentArrayReference(value) {
  if (!isObject(value))
    return false;
  return "explicitList" in value || "template" in value;
}
function isStringValue(value) {
  return isObject(value) && ("path" in value || "literal" in value && typeof value.literal === "string" || "literalString" in value);
}
function isNumberValue(value) {
  return isObject(value) && ("path" in value || "literal" in value && typeof value.literal === "number" || "literalNumber" in value);
}
function isBooleanValue(value) {
  return isObject(value) && ("path" in value || "literal" in value && typeof value.literal === "boolean" || "literalBoolean" in value);
}
function isAnyComponentNode(value) {
  if (!isObject(value))
    return false;
  const hasBaseKeys = "id" in value && "type" in value && "properties" in value;
  if (!hasBaseKeys)
    return false;
  return true;
}
function isResolvedAudioPlayer(props) {
  return isObject(props) && "url" in props && isStringValue(props.url);
}
function isResolvedButton(props) {
  return isObject(props) && "child" in props && isAnyComponentNode(props.child) && "action" in props;
}
function isResolvedCard(props) {
  if (!isObject(props))
    return false;
  if (!("child" in props)) {
    if (!("children" in props)) {
      return false;
    } else {
      return Array.isArray(props.children) && props.children.every(isAnyComponentNode);
    }
  }
  return isAnyComponentNode(props.child);
}
function isResolvedCheckbox(props) {
  return isObject(props) && "label" in props && isStringValue(props.label) && "value" in props && isBooleanValue(props.value);
}
function isResolvedColumn(props) {
  return isObject(props) && "children" in props && Array.isArray(props.children) && props.children.every(isAnyComponentNode);
}
function isResolvedDateTimeInput(props) {
  return isObject(props) && "value" in props && isStringValue(props.value);
}
function isResolvedDivider(props) {
  return isObject(props);
}
function isResolvedImage(props) {
  return isObject(props) && "url" in props && isStringValue(props.url);
}
function isResolvedIcon(props) {
  return isObject(props) && "name" in props && isStringValue(props.name);
}
function isResolvedList(props) {
  return isObject(props) && "children" in props && Array.isArray(props.children) && props.children.every(isAnyComponentNode);
}
function isResolvedModal(props) {
  return isObject(props) && "entryPointChild" in props && isAnyComponentNode(props.entryPointChild) && "contentChild" in props && isAnyComponentNode(props.contentChild);
}
function isResolvedMultipleChoice(props) {
  return isObject(props) && "selections" in props;
}
function isResolvedRow(props) {
  return isObject(props) && "children" in props && Array.isArray(props.children) && props.children.every(isAnyComponentNode);
}
function isResolvedSlider(props) {
  return isObject(props) && "value" in props && isNumberValue(props.value);
}
function isResolvedTabItem(item) {
  return isObject(item) && "title" in item && isStringValue(item.title) && "child" in item && isAnyComponentNode(item.child);
}
function isResolvedTabs(props) {
  return isObject(props) && "tabItems" in props && Array.isArray(props.tabItems) && props.tabItems.every(isResolvedTabItem);
}
function isResolvedText(props) {
  return isObject(props) && "text" in props && isStringValue(props.text);
}
function isResolvedTextField(props) {
  return isObject(props) && "label" in props && isStringValue(props.label);
}
function isResolvedVideo(props) {
  return isObject(props) && "url" in props && isStringValue(props.url);
}

// node_modules/@a2ui/lit/dist/src/0.8/data/model-processor.js
var _mapCtor, _arrayCtor, _setCtor, _objCtor, _surfaces, _A2uiMessageProcessor_instances, parseIfJsonString_fn, convertKeyValueArrayToMap_fn, setDataByPath_fn, normalizePath_fn, getDataByPath_fn, getOrCreateSurface_fn, handleBeginRendering_fn, handleSurfaceUpdate_fn, handleDataModelUpdate_fn, handleDeleteSurface_fn, rebuildComponentTree_fn, findValueKey_fn, buildNodeRecursive_fn, resolvePropertyValue_fn;
var _A2uiMessageProcessor = class _A2uiMessageProcessor {
  constructor(opts = { mapCtor: Map, arrayCtor: Array, setCtor: Set, objCtor: Object }) {
    __privateAdd(this, _A2uiMessageProcessor_instances);
    __privateAdd(this, _mapCtor, Map);
    __privateAdd(this, _arrayCtor, Array);
    __privateAdd(this, _setCtor, Set);
    __privateAdd(this, _objCtor, Object);
    __privateAdd(this, _surfaces);
    this.opts = opts;
    __privateSet(this, _arrayCtor, opts.arrayCtor);
    __privateSet(this, _mapCtor, opts.mapCtor);
    __privateSet(this, _setCtor, opts.setCtor);
    __privateSet(this, _objCtor, opts.objCtor);
    __privateSet(this, _surfaces, new opts.mapCtor());
  }
  getSurfaces() {
    return __privateGet(this, _surfaces);
  }
  clearSurfaces() {
    __privateGet(this, _surfaces).clear();
  }
  processMessages(messages) {
    for (const message of messages) {
      if (message.beginRendering) {
        __privateMethod(this, _A2uiMessageProcessor_instances, handleBeginRendering_fn).call(this, message.beginRendering, message.beginRendering.surfaceId);
      }
      if (message.surfaceUpdate) {
        __privateMethod(this, _A2uiMessageProcessor_instances, handleSurfaceUpdate_fn).call(this, message.surfaceUpdate, message.surfaceUpdate.surfaceId);
      }
      if (message.dataModelUpdate) {
        __privateMethod(this, _A2uiMessageProcessor_instances, handleDataModelUpdate_fn).call(this, message.dataModelUpdate, message.dataModelUpdate.surfaceId);
      }
      if (message.deleteSurface) {
        __privateMethod(this, _A2uiMessageProcessor_instances, handleDeleteSurface_fn).call(this, message.deleteSurface);
      }
    }
  }
  /**
   * Retrieves the data for a given component node and a relative path string.
   * This correctly handles the special `.` path, which refers to the node's
   * own data context.
   */
  getData(node, relativePath, surfaceId = _A2uiMessageProcessor.DEFAULT_SURFACE_ID) {
    const surface = __privateMethod(this, _A2uiMessageProcessor_instances, getOrCreateSurface_fn).call(this, surfaceId);
    if (!surface)
      return null;
    let finalPath;
    if (relativePath === "." || relativePath === "") {
      finalPath = node.dataContextPath ?? "/";
    } else {
      finalPath = this.resolvePath(relativePath, node.dataContextPath);
    }
    return __privateMethod(this, _A2uiMessageProcessor_instances, getDataByPath_fn).call(this, surface.dataModel, finalPath);
  }
  setData(node, relativePath, value, surfaceId = _A2uiMessageProcessor.DEFAULT_SURFACE_ID) {
    if (!node) {
      console.warn("No component node set");
      return;
    }
    const surface = __privateMethod(this, _A2uiMessageProcessor_instances, getOrCreateSurface_fn).call(this, surfaceId);
    if (!surface)
      return;
    let finalPath;
    if (relativePath === "." || relativePath === "") {
      finalPath = node.dataContextPath ?? "/";
    } else {
      finalPath = this.resolvePath(relativePath, node.dataContextPath);
    }
    __privateMethod(this, _A2uiMessageProcessor_instances, setDataByPath_fn).call(this, surface.dataModel, finalPath, value);
  }
  resolvePath(path, dataContextPath) {
    if (path.startsWith("/")) {
      return path;
    }
    if (dataContextPath && dataContextPath !== "/") {
      return dataContextPath.endsWith("/") ? `${dataContextPath}${path}` : `${dataContextPath}/${path}`;
    }
    return `/${path}`;
  }
};
_mapCtor = new WeakMap();
_arrayCtor = new WeakMap();
_setCtor = new WeakMap();
_objCtor = new WeakMap();
_surfaces = new WeakMap();
_A2uiMessageProcessor_instances = new WeakSet();
parseIfJsonString_fn = function(value) {
  if (typeof value !== "string") {
    return value;
  }
  const trimmedValue = value.trim();
  if (trimmedValue.startsWith("{") && trimmedValue.endsWith("}") || trimmedValue.startsWith("[") && trimmedValue.endsWith("]")) {
    try {
      return JSON.parse(value);
    } catch (e) {
      console.warn(`Failed to parse potential JSON string: "${value.substring(0, 50)}..."`, e);
      return value;
    }
  }
  return value;
};
/**
 * Converts a specific array format [{key: "...", value_string: "..."}, ...]
 * into a standard Map. It also attempts to parse any string values that
 * appear to be stringified JSON.
 */
convertKeyValueArrayToMap_fn = function(arr) {
  const map3 = new (__privateGet(this, _mapCtor))();
  for (const item of arr) {
    if (!isObject(item) || !("key" in item))
      continue;
    const key = item.key;
    const valueKey = __privateMethod(this, _A2uiMessageProcessor_instances, findValueKey_fn).call(this, item);
    if (!valueKey)
      continue;
    let value = item[valueKey];
    if (valueKey === "valueMap" && Array.isArray(value)) {
      value = __privateMethod(this, _A2uiMessageProcessor_instances, convertKeyValueArrayToMap_fn).call(this, value);
    } else if (typeof value === "string") {
      value = __privateMethod(this, _A2uiMessageProcessor_instances, parseIfJsonString_fn).call(this, value);
    }
    __privateMethod(this, _A2uiMessageProcessor_instances, setDataByPath_fn).call(this, map3, key, value);
  }
  return map3;
};
setDataByPath_fn = function(root, path, value) {
  if (Array.isArray(value) && (value.length === 0 || isObject(value[0]) && "key" in value[0])) {
    if (value.length === 1 && isObject(value[0]) && value[0].key === ".") {
      const item = value[0];
      const valueKey = __privateMethod(this, _A2uiMessageProcessor_instances, findValueKey_fn).call(this, item);
      if (valueKey) {
        value = item[valueKey];
        if (valueKey === "valueMap" && Array.isArray(value)) {
          value = __privateMethod(this, _A2uiMessageProcessor_instances, convertKeyValueArrayToMap_fn).call(this, value);
        } else if (typeof value === "string") {
          value = __privateMethod(this, _A2uiMessageProcessor_instances, parseIfJsonString_fn).call(this, value);
        }
      } else {
        value = __privateMethod(this, _A2uiMessageProcessor_instances, convertKeyValueArrayToMap_fn).call(this, value);
      }
    } else {
      value = __privateMethod(this, _A2uiMessageProcessor_instances, convertKeyValueArrayToMap_fn).call(this, value);
    }
  }
  const segments = __privateMethod(this, _A2uiMessageProcessor_instances, normalizePath_fn).call(this, path).split("/").filter((s) => s);
  if (segments.length === 0) {
    if (value instanceof Map || isObject(value)) {
      if (!(value instanceof Map) && isObject(value)) {
        value = new (__privateGet(this, _mapCtor))(Object.entries(value));
      }
      root.clear();
      for (const [key, v] of value.entries()) {
        root.set(key, v);
      }
    } else {
      console.error("Cannot set root of DataModel to a non-Map value.");
    }
    return;
  }
  let current = root;
  for (let i = 0; i < segments.length - 1; i++) {
    const segment = segments[i];
    let target;
    if (current instanceof Map) {
      target = current.get(segment);
    } else if (Array.isArray(current) && /^\d+$/.test(segment)) {
      target = current[parseInt(segment, 10)];
    }
    if (target === void 0 || typeof target !== "object" || target === null) {
      target = new (__privateGet(this, _mapCtor))();
      if (current instanceof __privateGet(this, _mapCtor)) {
        current.set(segment, target);
      } else if (Array.isArray(current)) {
        current[parseInt(segment, 10)] = target;
      }
    }
    current = target;
  }
  const finalSegment = segments[segments.length - 1];
  const storedValue = value;
  if (current instanceof __privateGet(this, _mapCtor)) {
    current.set(finalSegment, storedValue);
  } else if (Array.isArray(current) && /^\d+$/.test(finalSegment)) {
    current[parseInt(finalSegment, 10)] = storedValue;
  }
};
/**
 * Normalizes a path string into a consistent, slash-delimited format.
 * Converts bracket notation and dot notation in a two-pass.
 * e.g., "bookRecommendations[0].title" -> "/bookRecommendations/0/title"
 * e.g., "book.0.title" -> "/book/0/title"
 */
normalizePath_fn = function(path) {
  const dotPath = path.replace(/\[(\d+)\]/g, ".$1");
  const segments = dotPath.split(".");
  return "/" + segments.filter((s) => s.length > 0).join("/");
};
getDataByPath_fn = function(root, path) {
  const segments = __privateMethod(this, _A2uiMessageProcessor_instances, normalizePath_fn).call(this, path).split("/").filter((s) => s);
  let current = root;
  for (const segment of segments) {
    if (current === void 0 || current === null)
      return null;
    if (current instanceof Map) {
      current = current.get(segment);
    } else if (Array.isArray(current) && /^\d+$/.test(segment)) {
      current = current[parseInt(segment, 10)];
    } else if (isObject(current)) {
      current = current[segment];
    } else {
      return null;
    }
  }
  return current;
};
getOrCreateSurface_fn = function(surfaceId) {
  let surface = __privateGet(this, _surfaces).get(surfaceId);
  if (!surface) {
    surface = new (__privateGet(this, _objCtor))({
      rootComponentId: null,
      componentTree: null,
      dataModel: new (__privateGet(this, _mapCtor))(),
      components: new (__privateGet(this, _mapCtor))(),
      styles: new (__privateGet(this, _objCtor))()
    });
    __privateGet(this, _surfaces).set(surfaceId, surface);
  }
  return surface;
};
handleBeginRendering_fn = function(message, surfaceId) {
  const surface = __privateMethod(this, _A2uiMessageProcessor_instances, getOrCreateSurface_fn).call(this, surfaceId);
  surface.rootComponentId = message.root;
  surface.styles = message.styles ?? {};
  __privateMethod(this, _A2uiMessageProcessor_instances, rebuildComponentTree_fn).call(this, surface);
};
handleSurfaceUpdate_fn = function(message, surfaceId) {
  const surface = __privateMethod(this, _A2uiMessageProcessor_instances, getOrCreateSurface_fn).call(this, surfaceId);
  for (const component of message.components) {
    surface.components.set(component.id, component);
  }
  __privateMethod(this, _A2uiMessageProcessor_instances, rebuildComponentTree_fn).call(this, surface);
};
handleDataModelUpdate_fn = function(message, surfaceId) {
  const surface = __privateMethod(this, _A2uiMessageProcessor_instances, getOrCreateSurface_fn).call(this, surfaceId);
  const path = message.path ?? "/";
  __privateMethod(this, _A2uiMessageProcessor_instances, setDataByPath_fn).call(this, surface.dataModel, path, message.contents);
  __privateMethod(this, _A2uiMessageProcessor_instances, rebuildComponentTree_fn).call(this, surface);
};
handleDeleteSurface_fn = function(message) {
  __privateGet(this, _surfaces).delete(message.surfaceId);
};
/**
 * Starts at the root component of the surface and builds out the tree
 * recursively. This process involves resolving all properties of the child
 * components, and expanding on any explicit children lists or templates
 * found in the structure.
 *
 * @param surface The surface to be built.
 */
rebuildComponentTree_fn = function(surface) {
  if (!surface.rootComponentId) {
    surface.componentTree = null;
    return;
  }
  const visited = new (__privateGet(this, _setCtor))();
  surface.componentTree = __privateMethod(this, _A2uiMessageProcessor_instances, buildNodeRecursive_fn).call(this, surface.rootComponentId, surface, visited, "/", "");
};
/** Finds a value key in a map. */
findValueKey_fn = function(value) {
  return Object.keys(value).find((k) => k.startsWith("value"));
};
/**
 * Builds out the nodes recursively.
 */
buildNodeRecursive_fn = function(baseComponentId, surface, visited, dataContextPath, idSuffix = "") {
  const fullId = `${baseComponentId}${idSuffix}`;
  const { components } = surface;
  if (!components.has(baseComponentId)) {
    return null;
  }
  if (visited.has(fullId)) {
    throw new Error(`Circular dependency for component "${fullId}".`);
  }
  visited.add(fullId);
  const componentData = components.get(baseComponentId);
  const componentProps = componentData.component ?? {};
  const componentType = Object.keys(componentProps)[0];
  const unresolvedProperties = componentProps[componentType];
  const resolvedProperties = new (__privateGet(this, _objCtor))();
  if (isObject(unresolvedProperties)) {
    for (const [key, value] of Object.entries(unresolvedProperties)) {
      resolvedProperties[key] = __privateMethod(this, _A2uiMessageProcessor_instances, resolvePropertyValue_fn).call(this, value, surface, visited, dataContextPath, idSuffix);
    }
  }
  visited.delete(fullId);
  const baseNode = {
    id: fullId,
    dataContextPath,
    weight: componentData.weight ?? "initial"
  };
  switch (componentType) {
    case "Text":
      if (!isResolvedText(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Text",
        properties: resolvedProperties
      });
    case "Image":
      if (!isResolvedImage(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Image",
        properties: resolvedProperties
      });
    case "Icon":
      if (!isResolvedIcon(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Icon",
        properties: resolvedProperties
      });
    case "Video":
      if (!isResolvedVideo(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Video",
        properties: resolvedProperties
      });
    case "AudioPlayer":
      if (!isResolvedAudioPlayer(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "AudioPlayer",
        properties: resolvedProperties
      });
    case "Row":
      if (!isResolvedRow(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Row",
        properties: resolvedProperties
      });
    case "Column":
      if (!isResolvedColumn(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Column",
        properties: resolvedProperties
      });
    case "List":
      if (!isResolvedList(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "List",
        properties: resolvedProperties
      });
    case "Card":
      if (!isResolvedCard(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Card",
        properties: resolvedProperties
      });
    case "Tabs":
      if (!isResolvedTabs(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Tabs",
        properties: resolvedProperties
      });
    case "Divider":
      if (!isResolvedDivider(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Divider",
        properties: resolvedProperties
      });
    case "Modal":
      if (!isResolvedModal(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Modal",
        properties: resolvedProperties
      });
    case "Button":
      if (!isResolvedButton(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Button",
        properties: resolvedProperties
      });
    case "CheckBox":
      if (!isResolvedCheckbox(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "CheckBox",
        properties: resolvedProperties
      });
    case "TextField":
      if (!isResolvedTextField(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "TextField",
        properties: resolvedProperties
      });
    case "DateTimeInput":
      if (!isResolvedDateTimeInput(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "DateTimeInput",
        properties: resolvedProperties
      });
    case "MultipleChoice":
      if (!isResolvedMultipleChoice(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "MultipleChoice",
        properties: resolvedProperties
      });
    case "Slider":
      if (!isResolvedSlider(resolvedProperties)) {
        throw new Error(`Invalid data; expected ${componentType}`);
      }
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: "Slider",
        properties: resolvedProperties
      });
    default:
      return new (__privateGet(this, _objCtor))({
        ...baseNode,
        type: componentType,
        properties: resolvedProperties
      });
  }
};
/**
 * Recursively resolves an individual property value. If a property indicates
 * a child node (a string that matches a component ID), an explicitList of
 * children, or a template, these will be built out here.
 */
resolvePropertyValue_fn = function(value, surface, visited, dataContextPath, idSuffix = "") {
  if (typeof value === "string" && surface.components.has(value)) {
    return __privateMethod(this, _A2uiMessageProcessor_instances, buildNodeRecursive_fn).call(this, value, surface, visited, dataContextPath, idSuffix);
  }
  if (isComponentArrayReference(value)) {
    if (value.explicitList) {
      return value.explicitList.map((id) => __privateMethod(this, _A2uiMessageProcessor_instances, buildNodeRecursive_fn).call(this, id, surface, visited, dataContextPath, idSuffix));
    }
    if (value.template) {
      const fullDataPath = this.resolvePath(value.template.dataBinding, dataContextPath);
      const data = __privateMethod(this, _A2uiMessageProcessor_instances, getDataByPath_fn).call(this, surface.dataModel, fullDataPath);
      const template = value.template;
      if (Array.isArray(data)) {
        return data.map((_, index) => {
          const parentIndices = dataContextPath.split("/").filter((segment) => /^\d+$/.test(segment));
          const newIndices = [...parentIndices, index];
          const newSuffix = `:${newIndices.join(":")}`;
          const childDataContextPath = `${fullDataPath}/${index}`;
          return __privateMethod(this, _A2uiMessageProcessor_instances, buildNodeRecursive_fn).call(
            this,
            template.componentId,
            // baseId
            surface,
            visited,
            childDataContextPath,
            newSuffix
          );
        });
      }
      const mapCtor = __privateGet(this, _mapCtor);
      if (data instanceof mapCtor) {
        return Array.from(data.keys(), (key) => {
          const newSuffix = `:${key}`;
          const childDataContextPath = `${fullDataPath}/${key}`;
          return __privateMethod(this, _A2uiMessageProcessor_instances, buildNodeRecursive_fn).call(
            this,
            template.componentId,
            // baseId
            surface,
            visited,
            childDataContextPath,
            newSuffix
          );
        });
      }
      return new (__privateGet(this, _arrayCtor))();
    }
  }
  if (Array.isArray(value)) {
    return value.map((item) => __privateMethod(this, _A2uiMessageProcessor_instances, resolvePropertyValue_fn).call(this, item, surface, visited, dataContextPath, idSuffix));
  }
  if (isObject(value)) {
    const newObj = new (__privateGet(this, _objCtor))();
    for (const [key, propValue] of Object.entries(value)) {
      let propertyValue = propValue;
      if (isPath(key, propValue) && dataContextPath !== "/") {
        propertyValue = propValue.replace(/^\.?\/item/, "").replace(/^\.?\/text/, "").replace(/^\.?\/label/, "").replace(/^\.?\//, "");
        newObj[key] = propertyValue;
        continue;
      }
      newObj[key] = __privateMethod(this, _A2uiMessageProcessor_instances, resolvePropertyValue_fn).call(this, propertyValue, surface, visited, dataContextPath, idSuffix);
    }
    return newObj;
  }
  return value;
};
_A2uiMessageProcessor.DEFAULT_SURFACE_ID = "@default";
var A2uiMessageProcessor = _A2uiMessageProcessor;

// node_modules/@a2ui/lit/dist/src/0.8/ui/audio.js
var __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers2 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Audio = (() => {
  var _url_accessor_storage, __this_instances, renderAudio_fn, _a3;
  let _classDecorators = [customElement("a2ui-audioplayer")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _url_decorators;
  let _url_initializers = [];
  let _url_extraInitializers = [];
  var Audio2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _url_accessor_storage, __runInitializers2(this, _url_initializers, null));
      __runInitializers2(this, _url_extraInitializers);
    }
    get url() {
      return __privateGet(this, _url_accessor_storage);
    }
    set url(value) {
      __privateSet(this, _url_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.AudioPlayer)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.AudioPlayer) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.AudioPlayer) : nothing}
    >
      ${__privateMethod(this, __this_instances, renderAudio_fn).call(this)}
    </section>`;
    }
  }, _url_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderAudio_fn = function() {
    if (!this.url) {
      return nothing;
    }
    if (this.url && typeof this.url === "object") {
      if ("literalString" in this.url) {
        return html`<audio controls src=${this.url.literalString} />`;
      } else if ("literal" in this.url) {
        return html`<audio controls src=${this.url.literal} />`;
      } else if (this.url && "path" in this.url && this.url.path) {
        if (!this.processor || !this.component) {
          return html`(no processor)`;
        }
        const audioUrl = this.processor.getData(this.component, this.url.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (!audioUrl) {
          return html`Invalid audio URL`;
        }
        if (typeof audioUrl !== "string") {
          return html`Invalid audio URL`;
        }
        return html`<audio controls src=${audioUrl} />`;
      }
    }
    return html`(empty)`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _url_decorators = [property()];
    __esDecorate2(_a3, null, _url_decorators, { kind: "accessor", name: "url", static: false, private: false, access: { has: (obj) => "url" in obj, get: (obj) => obj.url, set: (obj, value) => {
      obj.url = value;
    } }, metadata: _metadata }, _url_initializers, _url_extraInitializers);
    __esDecorate2(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Audio2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      audio {
        display: block;
        width: 100%;
      }
    `
  ], __runInitializers2(_classThis, _classExtraInitializers), _a3);
  return Audio2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/events/events.js
var events_exports = {};
__export(events_exports, {
  StateEvent: () => StateEvent
});
var eventInit = {
  bubbles: true,
  cancelable: true,
  composed: true
};
var _StateEvent = class _StateEvent extends CustomEvent {
  constructor(payload) {
    super(_StateEvent.eventName, { detail: payload, ...eventInit });
    this.payload = payload;
  }
};
_StateEvent.eventName = "a2uiaction";
var StateEvent = _StateEvent;

// node_modules/@a2ui/lit/dist/src/0.8/ui/button.js
var __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers3 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Button = (() => {
  var _action_accessor_storage, _a3;
  let _classDecorators = [customElement("a2ui-button")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _action_decorators;
  let _action_initializers = [];
  let _action_extraInitializers = [];
  var Button2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _action_accessor_storage, __runInitializers3(this, _action_initializers, null));
      __runInitializers3(this, _action_extraInitializers);
    }
    get action() {
      return __privateGet(this, _action_accessor_storage);
    }
    set action(value) {
      __privateSet(this, _action_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<button
      class=${classMap(this.theme.components.Button)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Button) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Button) : nothing}
      @click=${() => {
        if (!this.action) {
          return;
        }
        const evt = new StateEvent({
          eventType: "a2ui.action",
          action: this.action,
          dataContextPath: this.dataContextPath,
          sourceComponentId: this.id,
          sourceComponent: this.component
        });
        this.dispatchEvent(evt);
      }}
    >
      <slot></slot>
    </button>`;
    }
  }, _action_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _action_decorators = [property()];
    __esDecorate3(_a3, null, _action_decorators, { kind: "accessor", name: "action", static: false, private: false, access: { has: (obj) => "action" in obj, get: (obj) => obj.action, set: (obj, value) => {
      obj.action = value;
    } }, metadata: _metadata }, _action_initializers, _action_extraInitializers);
    __esDecorate3(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Button2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
      }
    `
  ], __runInitializers3(_classThis, _classExtraInitializers), _a3);
  return Button2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/card.js
var __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers4 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Card = (() => {
  var _a3;
  let _classDecorators = [customElement("a2ui-card")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  var Card2 = (_a3 = class extends _classSuper {
    render() {
      var _a4, _b2;
      return html` <section
      class=${classMap(this.theme.components.Card)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Card) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Card) : nothing}
    >
      <slot></slot>
    </section>`;
    }
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate4(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Card2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      section {
        height: 100%;
        width: 100%;
        min-height: 0;
        overflow: auto;

        ::slotted(*) {
          height: 100%;
          width: 100%;
        }
      }
    `
  ], __runInitializers4(_classThis, _classExtraInitializers), _a3);
  return Card2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/checkbox.js
var __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers5 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Checkbox = (() => {
  var _value_accessor_storage, _label_accessor_storage, __this_instances, setBoundValue_fn, renderField_fn, _a3;
  let _classDecorators = [customElement("a2ui-checkbox")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  var Checkbox2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _value_accessor_storage, __runInitializers5(this, _value_initializers, null));
      __privateAdd(this, _label_accessor_storage, (__runInitializers5(this, _value_extraInitializers), __runInitializers5(this, _label_initializers, null)));
      __runInitializers5(this, _label_extraInitializers);
    }
    get value() {
      return __privateGet(this, _value_accessor_storage);
    }
    set value(value) {
      __privateSet(this, _value_accessor_storage, value);
    }
    get label() {
      return __privateGet(this, _label_accessor_storage);
    }
    set label(value) {
      __privateSet(this, _label_accessor_storage, value);
    }
    render() {
      if (this.value && typeof this.value === "object") {
        if ("literalBoolean" in this.value && this.value.literalBoolean) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literalBoolean);
        } else if ("literal" in this.value && this.value.literal !== void 0) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literal);
        } else if (this.value && "path" in this.value && this.value.path) {
          if (!this.processor || !this.component) {
            return html`(no model)`;
          }
          const textValue = this.processor.getData(this.component, this.value.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
          if (textValue === null) {
            return html`Invalid label`;
          }
          if (typeof textValue !== "boolean") {
            return html`Invalid label`;
          }
          return __privateMethod(this, __this_instances, renderField_fn).call(this, textValue);
        }
      }
      return nothing;
    }
  }, _value_accessor_storage = new WeakMap(), _label_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), setBoundValue_fn = function(value) {
    if (!this.value || !this.processor) {
      return;
    }
    if (!("path" in this.value)) {
      return;
    }
    if (!this.value.path) {
      return;
    }
    this.processor.setData(this.component, this.value.path, value, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
  }, renderField_fn = function(value) {
    var _a4, _b2, _c;
    return html` <section
      class=${classMap(this.theme.components.CheckBox.container)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.CheckBox) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.CheckBox) : nothing}
    >
      <input
        class=${classMap(this.theme.components.CheckBox.element)}
        autocomplete="off"
        @input=${(evt) => {
      if (!(evt.target instanceof HTMLInputElement)) {
        return;
      }
      __privateMethod(this, __this_instances, setBoundValue_fn).call(this, evt.target.value);
    }}
        id="data"
        type="checkbox"
        .value=${value}
      />
      <label class=${classMap(this.theme.components.CheckBox.label)} for="data"
        >${(_c = this.label) == null ? void 0 : _c.literalString}</label
      >
    </section>`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _value_decorators = [property()];
    _label_decorators = [property()];
    __esDecorate5(_a3, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: (obj) => "value" in obj, get: (obj) => obj.value, set: (obj, value) => {
      obj.value = value;
    } }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
    __esDecorate5(_a3, null, _label_decorators, { kind: "accessor", name: "label", static: false, private: false, access: { has: (obj) => "label" in obj, get: (obj) => obj.label, set: (obj, value) => {
      obj.label = value;
    } }, metadata: _metadata }, _label_initializers, _label_extraInitializers);
    __esDecorate5(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Checkbox2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      input {
        display: block;
        width: 100%;
      }

      .description {
        font-size: 14px;
        margin-bottom: 4px;
      }
    `
  ], __runInitializers5(_classThis, _classExtraInitializers), _a3);
  return Checkbox2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/column.js
var __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers6 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Column = (() => {
  var _alignment_accessor_storage, _distribution_accessor_storage, _a3;
  let _classDecorators = [customElement("a2ui-column")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _alignment_decorators;
  let _alignment_initializers = [];
  let _alignment_extraInitializers = [];
  let _distribution_decorators;
  let _distribution_initializers = [];
  let _distribution_extraInitializers = [];
  var Column2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _alignment_accessor_storage, __runInitializers6(this, _alignment_initializers, "stretch"));
      __privateAdd(this, _distribution_accessor_storage, (__runInitializers6(this, _alignment_extraInitializers), __runInitializers6(this, _distribution_initializers, "start")));
      __runInitializers6(this, _distribution_extraInitializers);
    }
    get alignment() {
      return __privateGet(this, _alignment_accessor_storage);
    }
    set alignment(value) {
      __privateSet(this, _alignment_accessor_storage, value);
    }
    get distribution() {
      return __privateGet(this, _distribution_accessor_storage);
    }
    set distribution(value) {
      __privateSet(this, _distribution_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.Column)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Column) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Column) : nothing}
    >
      <slot></slot>
    </section>`;
    }
  }, _alignment_accessor_storage = new WeakMap(), _distribution_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _alignment_decorators = [property({ reflect: true, type: String })];
    _distribution_decorators = [property({ reflect: true, type: String })];
    __esDecorate6(_a3, null, _alignment_decorators, { kind: "accessor", name: "alignment", static: false, private: false, access: { has: (obj) => "alignment" in obj, get: (obj) => obj.alignment, set: (obj, value) => {
      obj.alignment = value;
    } }, metadata: _metadata }, _alignment_initializers, _alignment_extraInitializers);
    __esDecorate6(_a3, null, _distribution_decorators, { kind: "accessor", name: "distribution", static: false, private: false, access: { has: (obj) => "distribution" in obj, get: (obj) => obj.distribution, set: (obj, value) => {
      obj.distribution = value;
    } }, metadata: _metadata }, _distribution_initializers, _distribution_extraInitializers);
    __esDecorate6(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Column2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: flex;
        flex: var(--weight);
      }

      section {
        display: flex;
        flex-direction: column;
        min-width: 100%;
        height: 100%;
      }

      :host([alignment="start"]) section {
        align-items: start;
      }

      :host([alignment="center"]) section {
        align-items: center;
      }

      :host([alignment="end"]) section {
        align-items: end;
      }

      :host([alignment="stretch"]) section {
        align-items: stretch;
      }

      :host([distribution="start"]) section {
        justify-content: start;
      }

      :host([distribution="center"]) section {
        justify-content: center;
      }

      :host([distribution="end"]) section {
        justify-content: end;
      }

      :host([distribution="spaceBetween"]) section {
        justify-content: space-between;
      }

      :host([distribution="spaceAround"]) section {
        justify-content: space-around;
      }

      :host([distribution="spaceEvenly"]) section {
        justify-content: space-evenly;
      }
    `
  ], __runInitializers6(_classThis, _classExtraInitializers), _a3);
  return Column2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/datetime-input.js
var __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers7 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var DateTimeInput = (() => {
  var _value_accessor_storage, _label_accessor_storage, _enableDate_accessor_storage, _enableTime_accessor_storage, __this_instances, setBoundValue_fn, renderField_fn, getInputType_fn, formatInputValue_fn, padNumber_fn, getPlaceholderText_fn, _a3;
  let _classDecorators = [customElement("a2ui-datetimeinput")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _enableDate_decorators;
  let _enableDate_initializers = [];
  let _enableDate_extraInitializers = [];
  let _enableTime_decorators;
  let _enableTime_initializers = [];
  let _enableTime_extraInitializers = [];
  var DateTimeInput2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _value_accessor_storage, __runInitializers7(this, _value_initializers, null));
      __privateAdd(this, _label_accessor_storage, (__runInitializers7(this, _value_extraInitializers), __runInitializers7(this, _label_initializers, null)));
      __privateAdd(this, _enableDate_accessor_storage, (__runInitializers7(this, _label_extraInitializers), __runInitializers7(this, _enableDate_initializers, true)));
      __privateAdd(this, _enableTime_accessor_storage, (__runInitializers7(this, _enableDate_extraInitializers), __runInitializers7(this, _enableTime_initializers, true)));
      __runInitializers7(this, _enableTime_extraInitializers);
    }
    get value() {
      return __privateGet(this, _value_accessor_storage);
    }
    set value(value) {
      __privateSet(this, _value_accessor_storage, value);
    }
    get label() {
      return __privateGet(this, _label_accessor_storage);
    }
    set label(value) {
      __privateSet(this, _label_accessor_storage, value);
    }
    get enableDate() {
      return __privateGet(this, _enableDate_accessor_storage);
    }
    set enableDate(value) {
      __privateSet(this, _enableDate_accessor_storage, value);
    }
    get enableTime() {
      return __privateGet(this, _enableTime_accessor_storage);
    }
    set enableTime(value) {
      __privateSet(this, _enableTime_accessor_storage, value);
    }
    render() {
      if (this.value && typeof this.value === "object") {
        if ("literalString" in this.value && this.value.literalString) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literalString);
        } else if ("literal" in this.value && this.value.literal !== void 0) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literal);
        } else if (this.value && "path" in this.value && this.value.path) {
          if (!this.processor || !this.component) {
            return html`(no model)`;
          }
          const textValue = this.processor.getData(this.component, this.value.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
          if (typeof textValue !== "string") {
            return html`(invalid)`;
          }
          return __privateMethod(this, __this_instances, renderField_fn).call(this, textValue);
        }
      }
      return nothing;
    }
  }, _value_accessor_storage = new WeakMap(), _label_accessor_storage = new WeakMap(), _enableDate_accessor_storage = new WeakMap(), _enableTime_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), setBoundValue_fn = function(value) {
    if (!this.value || !this.processor) {
      return;
    }
    if (!("path" in this.value)) {
      return;
    }
    if (!this.value.path) {
      return;
    }
    this.processor.setData(this.component, this.value.path, value, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
  }, renderField_fn = function(value) {
    var _a4, _b2;
    return html`<section
      class=${classMap(this.theme.components.DateTimeInput.container)}
    >
      <label
        for="data"
        class=${classMap(this.theme.components.DateTimeInput.label)}
        >${__privateMethod(this, __this_instances, getPlaceholderText_fn).call(this)}</label
      >
      <input
        autocomplete="off"
        class=${classMap(this.theme.components.DateTimeInput.element)}
        style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.DateTimeInput) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.DateTimeInput) : nothing}
        @input=${(evt) => {
      if (!(evt.target instanceof HTMLInputElement)) {
        return;
      }
      __privateMethod(this, __this_instances, setBoundValue_fn).call(this, evt.target.value);
    }}
        id="data"
        name="data"
        .value=${__privateMethod(this, __this_instances, formatInputValue_fn).call(this, value)}
        .placeholder=${__privateMethod(this, __this_instances, getPlaceholderText_fn).call(this)}
        .type=${__privateMethod(this, __this_instances, getInputType_fn).call(this)}
      />
    </section>`;
  }, getInputType_fn = function() {
    if (this.enableDate && this.enableTime) {
      return "datetime-local";
    } else if (this.enableDate) {
      return "date";
    } else if (this.enableTime) {
      return "time";
    }
    return "datetime-local";
  }, formatInputValue_fn = function(value) {
    const inputType = __privateMethod(this, __this_instances, getInputType_fn).call(this);
    const date = value ? new Date(value) : null;
    if (!date || isNaN(date.getTime())) {
      return "";
    }
    const year = __privateMethod(this, __this_instances, padNumber_fn).call(this, date.getFullYear());
    const month = __privateMethod(this, __this_instances, padNumber_fn).call(this, date.getMonth());
    const day = __privateMethod(this, __this_instances, padNumber_fn).call(this, date.getDate());
    const hours = __privateMethod(this, __this_instances, padNumber_fn).call(this, date.getHours());
    const minutes = __privateMethod(this, __this_instances, padNumber_fn).call(this, date.getMinutes());
    if (inputType === "date") {
      return `${year}-${month}-${day}`;
    } else if (inputType === "time") {
      return `${hours}:${minutes}`;
    }
    return `${year}-${month}-${day}T${hours}:${minutes}`;
  }, padNumber_fn = function(value) {
    return value.toString().padStart(2, "0");
  }, getPlaceholderText_fn = function() {
    const inputType = __privateMethod(this, __this_instances, getInputType_fn).call(this);
    if (inputType === "date") {
      return "Date";
    } else if (inputType === "time") {
      return "Time";
    }
    return "Date & Time";
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _value_decorators = [property()];
    _label_decorators = [property()];
    _enableDate_decorators = [property({ reflect: false, type: Boolean })];
    _enableTime_decorators = [property({ reflect: false, type: Boolean })];
    __esDecorate7(_a3, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: (obj) => "value" in obj, get: (obj) => obj.value, set: (obj, value) => {
      obj.value = value;
    } }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
    __esDecorate7(_a3, null, _label_decorators, { kind: "accessor", name: "label", static: false, private: false, access: { has: (obj) => "label" in obj, get: (obj) => obj.label, set: (obj, value) => {
      obj.label = value;
    } }, metadata: _metadata }, _label_initializers, _label_extraInitializers);
    __esDecorate7(_a3, null, _enableDate_decorators, { kind: "accessor", name: "enableDate", static: false, private: false, access: { has: (obj) => "enableDate" in obj, get: (obj) => obj.enableDate, set: (obj, value) => {
      obj.enableDate = value;
    } }, metadata: _metadata }, _enableDate_initializers, _enableDate_extraInitializers);
    __esDecorate7(_a3, null, _enableTime_decorators, { kind: "accessor", name: "enableTime", static: false, private: false, access: { has: (obj) => "enableTime" in obj, get: (obj) => obj.enableTime, set: (obj, value) => {
      obj.enableTime = value;
    } }, metadata: _metadata }, _enableTime_initializers, _enableTime_extraInitializers);
    __esDecorate7(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    DateTimeInput2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      input {
        display: block;
        border-radius: 8px;
        padding: 8px;
        border: 1px solid #ccc;
        width: 100%;
      }
    `
  ], __runInitializers7(_classThis, _classExtraInitializers), _a3);
  return DateTimeInput2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/divider.js
var __esDecorate8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers8 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Divider = (() => {
  var _a3;
  let _classDecorators = [customElement("a2ui-divider")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  var Divider2 = (_a3 = class extends _classSuper {
    render() {
      var _a4, _b2;
      return html`<hr
      class=${classMap(this.theme.components.Divider)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Divider) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Divider) : nothing}
    />`;
    }
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    __esDecorate8(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Divider2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      :host {
        display: block;
        min-height: 0;
        overflow: auto;
      }

      hr {
        height: 1px;
        background: #ccc;
        border: none;
      }
    `
  ], __runInitializers8(_classThis, _classExtraInitializers), _a3);
  return Divider2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/icon.js
var __esDecorate9 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers9 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Icon = (() => {
  var _name_accessor_storage, __this_instances, renderIcon_fn, _a3;
  let _classDecorators = [customElement("a2ui-icon")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _name_decorators;
  let _name_initializers = [];
  let _name_extraInitializers = [];
  var Icon2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _name_accessor_storage, __runInitializers9(this, _name_initializers, null));
      __runInitializers9(this, _name_extraInitializers);
    }
    get name() {
      return __privateGet(this, _name_accessor_storage);
    }
    set name(value) {
      __privateSet(this, _name_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.Icon)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Icon) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Icon) : nothing}
    >
      ${__privateMethod(this, __this_instances, renderIcon_fn).call(this)}
    </section>`;
    }
  }, _name_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderIcon_fn = function() {
    if (!this.name) {
      return nothing;
    }
    const render2 = (url) => {
      url = url.replace(/([A-Z])/gm, "_$1").toLocaleLowerCase();
      return html`<span class="g-icon">${url}</span>`;
    };
    if (this.name && typeof this.name === "object") {
      if ("literalString" in this.name) {
        const iconName = this.name.literalString ?? "";
        return render2(iconName);
      } else if ("literal" in this.name) {
        const iconName = this.name.literal ?? "";
        return render2(iconName);
      } else if (this.name && "path" in this.name && this.name.path) {
        if (!this.processor || !this.component) {
          return html`(no model)`;
        }
        const iconName = this.processor.getData(this.component, this.name.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (!iconName) {
          return html`Invalid icon name`;
        }
        if (typeof iconName !== "string") {
          return html`Invalid icon name`;
        }
        return render2(iconName);
      }
    }
    return html`(empty)`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _name_decorators = [property()];
    __esDecorate9(_a3, null, _name_decorators, { kind: "accessor", name: "name", static: false, private: false, access: { has: (obj) => "name" in obj, get: (obj) => obj.name, set: (obj, value) => {
      obj.name = value;
    } }, metadata: _metadata }, _name_initializers, _name_extraInitializers);
    __esDecorate9(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Icon2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }
    `
  ], __runInitializers9(_classThis, _classExtraInitializers), _a3);
  return Icon2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/index.js
var __exports = {};
__export(__exports, {
  Data: () => Data,
  Events: () => events_exports,
  Primitives: () => primitives_exports,
  Schemas: () => Schemas,
  Styles: () => styles_exports,
  Types: () => types_exports,
  UI: () => ui_exports
});

// node_modules/@a2ui/lit/dist/src/0.8/types/types.js
var types_exports = {};

// node_modules/@a2ui/lit/dist/src/0.8/types/primitives.js
var primitives_exports = {};

// node_modules/signal-utils/dist/-private/util.ts.js
var createStorage = (initial = null) => new Signal.State(initial, {
  equals: () => false
});

// node_modules/signal-utils/dist/array.ts.js
var ARRAY_GETTER_METHODS = /* @__PURE__ */ new Set([Symbol.iterator, "concat", "entries", "every", "filter", "find", "findIndex", "flat", "flatMap", "forEach", "includes", "indexOf", "join", "keys", "lastIndexOf", "map", "reduce", "reduceRight", "slice", "some", "values"]);
var ARRAY_WRITE_THEN_READ_METHODS = /* @__PURE__ */ new Set(["fill", "push", "unshift"]);
function convertToInt(prop) {
  if (typeof prop === "symbol") return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}
var _collection, _storages, _SignalArray_instances, readStorageFor_fn, dirtyStorageFor_fn;
var _SignalArray = class _SignalArray {
  constructor(arr = []) {
    __privateAdd(this, _SignalArray_instances);
    __privateAdd(this, _collection, createStorage());
    __privateAdd(this, _storages, /* @__PURE__ */ new Map());
    let clone = arr.slice();
    let self = this;
    let boundFns = /* @__PURE__ */ new Map();
    let nativelyAccessingLengthFromPushOrUnshift = false;
    return new Proxy(clone, {
      get(target, prop) {
        var _a3;
        let index = convertToInt(prop);
        if (index !== null) {
          __privateMethod(_a3 = self, _SignalArray_instances, readStorageFor_fn).call(_a3, index);
          __privateGet(self, _collection).get();
          return target[index];
        }
        if (prop === "length") {
          if (nativelyAccessingLengthFromPushOrUnshift) {
            nativelyAccessingLengthFromPushOrUnshift = false;
          } else {
            __privateGet(self, _collection).get();
          }
          return target[prop];
        }
        if (ARRAY_WRITE_THEN_READ_METHODS.has(prop)) {
          nativelyAccessingLengthFromPushOrUnshift = true;
        }
        if (ARRAY_GETTER_METHODS.has(prop)) {
          let fn = boundFns.get(prop);
          if (fn === void 0) {
            fn = (...args) => {
              __privateGet(self, _collection).get();
              return target[prop](...args);
            };
            boundFns.set(prop, fn);
          }
          return fn;
        }
        return target[prop];
      },
      set(target, prop, value) {
        var _a3;
        target[prop] = value;
        let index = convertToInt(prop);
        if (index !== null) {
          __privateMethod(_a3 = self, _SignalArray_instances, dirtyStorageFor_fn).call(_a3, index);
          __privateGet(self, _collection).set(null);
        } else if (prop === "length") {
          __privateGet(self, _collection).set(null);
        }
        return true;
      },
      getPrototypeOf() {
        return _SignalArray.prototype;
      }
    });
  }
  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   */
  /**
   * Creates an array from an iterable object.
   * @param iterable An iterable object to convert to an array.
   * @param mapfn A mapping function to call on every element of the array.
   * @param thisArg Value of 'this' used to invoke the mapfn.
   */
  static from(iterable, mapfn, thisArg) {
    return mapfn ? new _SignalArray(Array.from(iterable, mapfn, thisArg)) : new _SignalArray(Array.from(iterable));
  }
  static of(...arr) {
    return new _SignalArray(arr);
  }
};
_collection = new WeakMap();
_storages = new WeakMap();
_SignalArray_instances = new WeakSet();
readStorageFor_fn = function(index) {
  let storage = __privateGet(this, _storages).get(index);
  if (storage === void 0) {
    storage = createStorage();
    __privateGet(this, _storages).set(index, storage);
  }
  storage.get();
};
dirtyStorageFor_fn = function(index) {
  const storage = __privateGet(this, _storages).get(index);
  if (storage) {
    storage.set(null);
  }
};
var SignalArray = _SignalArray;
Object.setPrototypeOf(SignalArray.prototype, Array.prototype);

// node_modules/signal-utils/dist/map.ts.js
var SignalMap = class {
  constructor(existing) {
    __publicField(this, "collection", createStorage());
    __publicField(this, "storages", /* @__PURE__ */ new Map());
    __publicField(this, "vals");
    this.vals = existing ? new Map(existing) : /* @__PURE__ */ new Map();
  }
  readStorageFor(key) {
    const {
      storages
    } = this;
    let storage = storages.get(key);
    if (storage === void 0) {
      storage = createStorage();
      storages.set(key, storage);
    }
    storage.get();
  }
  dirtyStorageFor(key) {
    const storage = this.storages.get(key);
    if (storage) {
      storage.set(null);
    }
  }
  // **** KEY GETTERS ****
  get(key) {
    this.readStorageFor(key);
    return this.vals.get(key);
  }
  has(key) {
    this.readStorageFor(key);
    return this.vals.has(key);
  }
  // **** ALL GETTERS ****
  entries() {
    this.collection.get();
    return this.vals.entries();
  }
  keys() {
    this.collection.get();
    return this.vals.keys();
  }
  values() {
    this.collection.get();
    return this.vals.values();
  }
  forEach(fn) {
    this.collection.get();
    this.vals.forEach(fn);
  }
  get size() {
    this.collection.get();
    return this.vals.size;
  }
  [Symbol.iterator]() {
    this.collection.get();
    return this.vals[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return this.vals[Symbol.toStringTag];
  }
  // **** KEY SETTERS ****
  set(key, value) {
    this.dirtyStorageFor(key);
    this.collection.set(null);
    this.vals.set(key, value);
    return this;
  }
  delete(key) {
    this.dirtyStorageFor(key);
    this.collection.set(null);
    return this.vals.delete(key);
  }
  // **** ALL SETTERS ****
  clear() {
    this.storages.forEach((s) => s.set(null));
    this.collection.set(null);
    this.vals.clear();
  }
};
Object.setPrototypeOf(SignalMap.prototype, Map.prototype);

// node_modules/signal-utils/dist/object.ts.js
var _storages2, _collection2, _SignalObjectImpl_instances, readStorageFor_fn2, dirtyStorageFor_fn2, dirtyCollection_fn;
var _SignalObjectImpl = class _SignalObjectImpl {
  constructor(obj = {}) {
    __privateAdd(this, _SignalObjectImpl_instances);
    __privateAdd(this, _storages2, /* @__PURE__ */ new Map());
    __privateAdd(this, _collection2, createStorage());
    let proto = Object.getPrototypeOf(obj);
    let descs = Object.getOwnPropertyDescriptors(obj);
    let clone = Object.create(proto);
    for (let prop in descs) {
      Object.defineProperty(clone, prop, descs[prop]);
    }
    let self = this;
    return new Proxy(clone, {
      get(target, prop, receiver) {
        var _a3;
        __privateMethod(_a3 = self, _SignalObjectImpl_instances, readStorageFor_fn2).call(_a3, prop);
        return Reflect.get(target, prop, receiver);
      },
      has(target, prop) {
        var _a3;
        __privateMethod(_a3 = self, _SignalObjectImpl_instances, readStorageFor_fn2).call(_a3, prop);
        return prop in target;
      },
      ownKeys(target) {
        __privateGet(self, _collection2).get();
        return Reflect.ownKeys(target);
      },
      set(target, prop, value, receiver) {
        var _a3, _b2;
        let result = Reflect.set(target, prop, value, receiver);
        __privateMethod(_a3 = self, _SignalObjectImpl_instances, dirtyStorageFor_fn2).call(_a3, prop);
        __privateMethod(_b2 = self, _SignalObjectImpl_instances, dirtyCollection_fn).call(_b2);
        return result;
      },
      deleteProperty(target, prop) {
        var _a3, _b2;
        if (prop in target) {
          delete target[prop];
          __privateMethod(_a3 = self, _SignalObjectImpl_instances, dirtyStorageFor_fn2).call(_a3, prop);
          __privateMethod(_b2 = self, _SignalObjectImpl_instances, dirtyCollection_fn).call(_b2);
        }
        return true;
      },
      getPrototypeOf() {
        return _SignalObjectImpl.prototype;
      }
    });
  }
  static fromEntries(entries) {
    return new _SignalObjectImpl(Object.fromEntries(entries));
  }
};
_storages2 = new WeakMap();
_collection2 = new WeakMap();
_SignalObjectImpl_instances = new WeakSet();
readStorageFor_fn2 = function(key) {
  let storage = __privateGet(this, _storages2).get(key);
  if (storage === void 0) {
    storage = createStorage();
    __privateGet(this, _storages2).set(key, storage);
  }
  storage.get();
};
dirtyStorageFor_fn2 = function(key) {
  const storage = __privateGet(this, _storages2).get(key);
  if (storage) {
    storage.set(null);
  }
};
dirtyCollection_fn = function() {
  __privateGet(this, _collection2).set(null);
};
var SignalObjectImpl = _SignalObjectImpl;
var SignalObject = SignalObjectImpl;

// node_modules/signal-utils/dist/set.ts.js
var SignalSet = class {
  constructor(existing) {
    __publicField(this, "collection", createStorage());
    __publicField(this, "storages", /* @__PURE__ */ new Map());
    __publicField(this, "vals");
    this.vals = new Set(existing);
  }
  storageFor(key) {
    const storages = this.storages;
    let storage = storages.get(key);
    if (storage === void 0) {
      storage = createStorage();
      storages.set(key, storage);
    }
    return storage;
  }
  dirtyStorageFor(key) {
    const storage = this.storages.get(key);
    if (storage) {
      storage.set(null);
    }
  }
  // **** KEY GETTERS ****
  has(value) {
    this.storageFor(value).get();
    return this.vals.has(value);
  }
  // **** ALL GETTERS ****
  entries() {
    this.collection.get();
    return this.vals.entries();
  }
  keys() {
    this.collection.get();
    return this.vals.keys();
  }
  values() {
    this.collection.get();
    return this.vals.values();
  }
  forEach(fn) {
    this.collection.get();
    this.vals.forEach(fn);
  }
  get size() {
    this.collection.get();
    return this.vals.size;
  }
  [Symbol.iterator]() {
    this.collection.get();
    return this.vals[Symbol.iterator]();
  }
  get [Symbol.toStringTag]() {
    return this.vals[Symbol.toStringTag];
  }
  // **** KEY SETTERS ****
  add(value) {
    this.dirtyStorageFor(value);
    this.collection.set(null);
    this.vals.add(value);
    return this;
  }
  delete(value) {
    this.dirtyStorageFor(value);
    this.collection.set(null);
    return this.vals.delete(value);
  }
  // **** ALL SETTERS ****
  clear() {
    this.storages.forEach((s) => s.set(null));
    this.collection.set(null);
    this.vals.clear();
  }
};
Object.setPrototypeOf(SignalSet.prototype, Set.prototype);

// node_modules/@a2ui/lit/dist/src/0.8/data/signal-model-processor.js
function create() {
  return new A2uiMessageProcessor({
    arrayCtor: SignalArray,
    mapCtor: SignalMap,
    objCtor: SignalObject,
    setCtor: SignalSet
  });
}

// node_modules/@a2ui/lit/dist/src/0.8/schemas/server_to_client_with_standard_catalog.json
var server_to_client_with_standard_catalog_default = {
  title: "A2UI Message Schema",
  description: "Describes a JSON payload for an A2UI (Agent to UI) message, which is used to dynamically construct and update user interfaces. A message MUST contain exactly ONE of the action properties: 'beginRendering', 'surfaceUpdate', 'dataModelUpdate', or 'deleteSurface'.",
  type: "object",
  additionalProperties: false,
  properties: {
    beginRendering: {
      type: "object",
      description: "Signals the client to begin rendering a surface with a root component and specific styles.",
      additionalProperties: false,
      properties: {
        surfaceId: {
          type: "string",
          description: "The unique identifier for the UI surface to be rendered."
        },
        root: {
          type: "string",
          description: "The ID of the root component to render."
        },
        styles: {
          type: "object",
          description: "Styling information for the UI.",
          additionalProperties: false,
          properties: {
            font: {
              type: "string",
              description: "The primary font for the UI."
            },
            primaryColor: {
              type: "string",
              description: "The primary UI color as a hexadecimal code (e.g., '#00BFFF').",
              pattern: "^#[0-9a-fA-F]{6}$"
            }
          }
        }
      },
      required: ["root", "surfaceId"]
    },
    surfaceUpdate: {
      type: "object",
      description: "Updates a surface with a new set of components.",
      additionalProperties: false,
      properties: {
        surfaceId: {
          type: "string",
          description: "The unique identifier for the UI surface to be updated. If you are adding a new surface this *must* be a new, unique identified that has never been used for any existing surfaces shown."
        },
        components: {
          type: "array",
          description: "A list containing all UI components for the surface.",
          minItems: 1,
          items: {
            type: "object",
            description: "Represents a *single* component in a UI widget tree. This component could be one of many supported types.",
            additionalProperties: false,
            properties: {
              id: {
                type: "string",
                description: "The unique identifier for this component."
              },
              weight: {
                type: "number",
                description: "The relative weight of this component within a Row or Column. This corresponds to the CSS 'flex-grow' property. Note: this may ONLY be set when the component is a direct descendant of a Row or Column."
              },
              component: {
                type: "object",
                description: "A wrapper object that MUST contain exactly one key, which is the name of the component type (e.g., 'Heading'). The value is an object containing the properties for that specific component.",
                additionalProperties: false,
                properties: {
                  Text: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      text: {
                        type: "object",
                        description: "The text content to display. This can be a literal string or a reference to a value in the data model ('path', e.g., '/doc/title'). While simple Markdown formatting is supported (i.e. without HTML, images, or links), utilizing dedicated UI components is generally preferred for a richer and more structured presentation.",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      usageHint: {
                        type: "string",
                        description: "A hint for the base text style. One of:\n- `h1`: Largest heading.\n- `h2`: Second largest heading.\n- `h3`: Third largest heading.\n- `h4`: Fourth largest heading.\n- `h5`: Fifth largest heading.\n- `caption`: Small text for captions.\n- `body`: Standard body text.",
                        enum: [
                          "h1",
                          "h2",
                          "h3",
                          "h4",
                          "h5",
                          "caption",
                          "body"
                        ]
                      }
                    },
                    required: ["text"]
                  },
                  Image: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      url: {
                        type: "object",
                        description: "The URL of the image to display. This can be a literal string ('literal') or a reference to a value in the data model ('path', e.g. '/thumbnail/url').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      fit: {
                        type: "string",
                        description: "Specifies how the image should be resized to fit its container. This corresponds to the CSS 'object-fit' property.",
                        enum: [
                          "contain",
                          "cover",
                          "fill",
                          "none",
                          "scale-down"
                        ]
                      },
                      usageHint: {
                        type: "string",
                        description: "A hint for the image size and style. One of:\n- `icon`: Small square icon.\n- `avatar`: Circular avatar image.\n- `smallFeature`: Small feature image.\n- `mediumFeature`: Medium feature image.\n- `largeFeature`: Large feature image.\n- `header`: Full-width, full bleed, header image.",
                        enum: [
                          "icon",
                          "avatar",
                          "smallFeature",
                          "mediumFeature",
                          "largeFeature",
                          "header"
                        ]
                      }
                    },
                    required: ["url"]
                  },
                  Icon: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      name: {
                        type: "object",
                        description: "The name of the icon to display. This can be a literal string or a reference to a value in the data model ('path', e.g. '/form/submit').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string",
                            enum: [
                              "accountCircle",
                              "add",
                              "arrowBack",
                              "arrowForward",
                              "attachFile",
                              "calendarToday",
                              "call",
                              "camera",
                              "check",
                              "close",
                              "delete",
                              "download",
                              "edit",
                              "event",
                              "error",
                              "favorite",
                              "favoriteOff",
                              "folder",
                              "help",
                              "home",
                              "info",
                              "locationOn",
                              "lock",
                              "lockOpen",
                              "mail",
                              "menu",
                              "moreVert",
                              "moreHoriz",
                              "notificationsOff",
                              "notifications",
                              "payment",
                              "person",
                              "phone",
                              "photo",
                              "print",
                              "refresh",
                              "search",
                              "send",
                              "settings",
                              "share",
                              "shoppingCart",
                              "star",
                              "starHalf",
                              "starOff",
                              "upload",
                              "visibility",
                              "visibilityOff",
                              "warning"
                            ]
                          },
                          path: {
                            type: "string"
                          }
                        }
                      }
                    },
                    required: ["name"]
                  },
                  Video: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      url: {
                        type: "object",
                        description: "The URL of the video to display. This can be a literal string or a reference to a value in the data model ('path', e.g. '/video/url').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      }
                    },
                    required: ["url"]
                  },
                  AudioPlayer: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      url: {
                        type: "object",
                        description: "The URL of the audio to be played. This can be a literal string ('literal') or a reference to a value in the data model ('path', e.g. '/song/url').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      description: {
                        type: "object",
                        description: "A description of the audio, such as a title or summary. This can be a literal string or a reference to a value in the data model ('path', e.g. '/song/title').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      }
                    },
                    required: ["url"]
                  },
                  Row: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      children: {
                        type: "object",
                        description: "Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.",
                        additionalProperties: false,
                        properties: {
                          explicitList: {
                            type: "array",
                            items: {
                              type: "string"
                            }
                          },
                          template: {
                            type: "object",
                            description: "A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the map of components in the data model. Values in the map will define the list of children.",
                            additionalProperties: false,
                            properties: {
                              componentId: {
                                type: "string"
                              },
                              dataBinding: {
                                type: "string"
                              }
                            },
                            required: ["componentId", "dataBinding"]
                          }
                        }
                      },
                      distribution: {
                        type: "string",
                        description: "Defines the arrangement of children along the main axis (horizontally). This corresponds to the CSS 'justify-content' property.",
                        enum: [
                          "center",
                          "end",
                          "spaceAround",
                          "spaceBetween",
                          "spaceEvenly",
                          "start"
                        ]
                      },
                      alignment: {
                        type: "string",
                        description: "Defines the alignment of children along the cross axis (vertically). This corresponds to the CSS 'align-items' property.",
                        enum: ["start", "center", "end", "stretch"]
                      }
                    },
                    required: ["children"]
                  },
                  Column: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      children: {
                        type: "object",
                        description: "Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.",
                        additionalProperties: false,
                        properties: {
                          explicitList: {
                            type: "array",
                            items: {
                              type: "string"
                            }
                          },
                          template: {
                            type: "object",
                            description: "A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the map of components in the data model. Values in the map will define the list of children.",
                            additionalProperties: false,
                            properties: {
                              componentId: {
                                type: "string"
                              },
                              dataBinding: {
                                type: "string"
                              }
                            },
                            required: ["componentId", "dataBinding"]
                          }
                        }
                      },
                      distribution: {
                        type: "string",
                        description: "Defines the arrangement of children along the main axis (vertically). This corresponds to the CSS 'justify-content' property.",
                        enum: [
                          "start",
                          "center",
                          "end",
                          "spaceBetween",
                          "spaceAround",
                          "spaceEvenly"
                        ]
                      },
                      alignment: {
                        type: "string",
                        description: "Defines the alignment of children along the cross axis (horizontally). This corresponds to the CSS 'align-items' property.",
                        enum: ["center", "end", "start", "stretch"]
                      }
                    },
                    required: ["children"]
                  },
                  List: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      children: {
                        type: "object",
                        description: "Defines the children. Use 'explicitList' for a fixed set of children, or 'template' to generate children from a data list.",
                        additionalProperties: false,
                        properties: {
                          explicitList: {
                            type: "array",
                            items: {
                              type: "string"
                            }
                          },
                          template: {
                            type: "object",
                            description: "A template for generating a dynamic list of children from a data model list. `componentId` is the component to use as a template, and `dataBinding` is the path to the map of components in the data model. Values in the map will define the list of children.",
                            additionalProperties: false,
                            properties: {
                              componentId: {
                                type: "string"
                              },
                              dataBinding: {
                                type: "string"
                              }
                            },
                            required: ["componentId", "dataBinding"]
                          }
                        }
                      },
                      direction: {
                        type: "string",
                        description: "The direction in which the list items are laid out.",
                        enum: ["vertical", "horizontal"]
                      },
                      alignment: {
                        type: "string",
                        description: "Defines the alignment of children along the cross axis.",
                        enum: ["start", "center", "end", "stretch"]
                      }
                    },
                    required: ["children"]
                  },
                  Card: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      child: {
                        type: "string",
                        description: "The ID of the component to be rendered inside the card."
                      }
                    },
                    required: ["child"]
                  },
                  Tabs: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      tabItems: {
                        type: "array",
                        description: "An array of objects, where each object defines a tab with a title and a child component.",
                        items: {
                          type: "object",
                          additionalProperties: false,
                          properties: {
                            title: {
                              type: "object",
                              description: "The tab title. Defines the value as either a literal value or a path to data model value (e.g. '/options/title').",
                              additionalProperties: false,
                              properties: {
                                literalString: {
                                  type: "string"
                                },
                                path: {
                                  type: "string"
                                }
                              }
                            },
                            child: {
                              type: "string"
                            }
                          },
                          required: ["title", "child"]
                        }
                      }
                    },
                    required: ["tabItems"]
                  },
                  Divider: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      axis: {
                        type: "string",
                        description: "The orientation of the divider.",
                        enum: ["horizontal", "vertical"]
                      }
                    }
                  },
                  Modal: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      entryPointChild: {
                        type: "string",
                        description: "The ID of the component that opens the modal when interacted with (e.g., a button)."
                      },
                      contentChild: {
                        type: "string",
                        description: "The ID of the component to be displayed inside the modal."
                      }
                    },
                    required: ["entryPointChild", "contentChild"]
                  },
                  Button: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      child: {
                        type: "string",
                        description: "The ID of the component to display in the button, typically a Text component."
                      },
                      primary: {
                        type: "boolean",
                        description: "Indicates if this button should be styled as the primary action."
                      },
                      action: {
                        type: "object",
                        description: "The client-side action to be dispatched when the button is clicked. It includes the action's name and an optional context payload.",
                        additionalProperties: false,
                        properties: {
                          name: {
                            type: "string"
                          },
                          context: {
                            type: "array",
                            items: {
                              type: "object",
                              additionalProperties: false,
                              properties: {
                                key: {
                                  type: "string"
                                },
                                value: {
                                  type: "object",
                                  description: "Defines the value to be included in the context as either a literal value or a path to a data model value (e.g. '/user/name').",
                                  additionalProperties: false,
                                  properties: {
                                    path: {
                                      type: "string"
                                    },
                                    literalString: {
                                      type: "string"
                                    },
                                    literalNumber: {
                                      type: "number"
                                    },
                                    literalBoolean: {
                                      type: "boolean"
                                    }
                                  }
                                }
                              },
                              required: ["key", "value"]
                            }
                          }
                        },
                        required: ["name"]
                      }
                    },
                    required: ["child", "action"]
                  },
                  CheckBox: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      label: {
                        type: "object",
                        description: "The text to display next to the checkbox. Defines the value as either a literal value or a path to data model ('path', e.g. '/option/label').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      value: {
                        type: "object",
                        description: "The current state of the checkbox (true for checked, false for unchecked). This can be a literal boolean ('literalBoolean') or a reference to a value in the data model ('path', e.g. '/filter/open').",
                        additionalProperties: false,
                        properties: {
                          literalBoolean: {
                            type: "boolean"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      }
                    },
                    required: ["label", "value"]
                  },
                  TextField: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      label: {
                        type: "object",
                        description: "The text label for the input field. This can be a literal string or a reference to a value in the data model ('path, e.g. '/user/name').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      text: {
                        type: "object",
                        description: "The value of the text field. This can be a literal string or a reference to a value in the data model ('path', e.g. '/user/name').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      textFieldType: {
                        type: "string",
                        description: "The type of input field to display.",
                        enum: [
                          "date",
                          "longText",
                          "number",
                          "shortText",
                          "obscured"
                        ]
                      },
                      validationRegexp: {
                        type: "string",
                        description: "A regular expression used for client-side validation of the input."
                      }
                    },
                    required: ["label"]
                  },
                  DateTimeInput: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      value: {
                        type: "object",
                        description: "The selected date and/or time value. This can be a literal string ('literalString') or a reference to a value in the data model ('path', e.g. '/user/dob').",
                        additionalProperties: false,
                        properties: {
                          literalString: {
                            type: "string"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      enableDate: {
                        type: "boolean",
                        description: "If true, allows the user to select a date."
                      },
                      enableTime: {
                        type: "boolean",
                        description: "If true, allows the user to select a time."
                      },
                      outputFormat: {
                        type: "string",
                        description: "The desired format for the output string after a date or time is selected."
                      }
                    },
                    required: ["value"]
                  },
                  MultipleChoice: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      selections: {
                        type: "object",
                        description: "The currently selected values for the component. This can be a literal array of strings or a path to an array in the data model('path', e.g. '/hotel/options').",
                        additionalProperties: false,
                        properties: {
                          literalArray: {
                            type: "array",
                            items: {
                              type: "string"
                            }
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      options: {
                        type: "array",
                        description: "An array of available options for the user to choose from.",
                        items: {
                          type: "object",
                          additionalProperties: false,
                          properties: {
                            label: {
                              type: "object",
                              description: "The text to display for this option. This can be a literal string or a reference to a value in the data model (e.g. '/option/label').",
                              additionalProperties: false,
                              properties: {
                                literalString: {
                                  type: "string"
                                },
                                path: {
                                  type: "string"
                                }
                              }
                            },
                            value: {
                              type: "string",
                              description: "The value to be associated with this option when selected."
                            }
                          },
                          required: ["label", "value"]
                        }
                      },
                      maxAllowedSelections: {
                        type: "integer",
                        description: "The maximum number of options that the user is allowed to select."
                      }
                    },
                    required: ["selections", "options"]
                  },
                  Slider: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                      value: {
                        type: "object",
                        description: "The current value of the slider. This can be a literal number ('literalNumber') or a reference to a value in the data model ('path', e.g. '/restaurant/cost').",
                        additionalProperties: false,
                        properties: {
                          literalNumber: {
                            type: "number"
                          },
                          path: {
                            type: "string"
                          }
                        }
                      },
                      minValue: {
                        type: "number",
                        description: "The minimum value of the slider."
                      },
                      maxValue: {
                        type: "number",
                        description: "The maximum value of the slider."
                      }
                    },
                    required: ["value"]
                  }
                }
              }
            },
            required: ["id", "component"]
          }
        }
      },
      required: ["surfaceId", "components"]
    },
    dataModelUpdate: {
      type: "object",
      description: "Updates the data model for a surface.",
      additionalProperties: false,
      properties: {
        surfaceId: {
          type: "string",
          description: "The unique identifier for the UI surface this data model update applies to."
        },
        path: {
          type: "string",
          description: "An optional path to a location within the data model (e.g., '/user/name'). If omitted, or set to '/', the entire data model will be replaced."
        },
        contents: {
          type: "array",
          description: "An array of data entries. Each entry must contain a 'key' and exactly one corresponding typed 'value*' property.",
          items: {
            type: "object",
            description: "A single data entry. Exactly one 'value*' property should be provided alongside the key.",
            additionalProperties: false,
            properties: {
              key: {
                type: "string",
                description: "The key for this data entry."
              },
              valueString: {
                type: "string"
              },
              valueNumber: {
                type: "number"
              },
              valueBoolean: {
                type: "boolean"
              },
              valueMap: {
                description: "Represents a map as an adjacency list.",
                type: "array",
                items: {
                  type: "object",
                  description: "One entry in the map. Exactly one 'value*' property should be provided alongside the key.",
                  additionalProperties: false,
                  properties: {
                    key: {
                      type: "string"
                    },
                    valueString: {
                      type: "string"
                    },
                    valueNumber: {
                      type: "number"
                    },
                    valueBoolean: {
                      type: "boolean"
                    }
                  },
                  required: ["key"]
                }
              }
            },
            required: ["key"]
          }
        }
      },
      required: ["contents", "surfaceId"]
    },
    deleteSurface: {
      type: "object",
      description: "Signals the client to delete the surface identified by 'surfaceId'.",
      additionalProperties: false,
      properties: {
        surfaceId: {
          type: "string",
          description: "The unique identifier for the UI surface to be deleted."
        }
      },
      required: ["surfaceId"]
    }
  }
};

// node_modules/@a2ui/lit/dist/src/0.8/core.js
var Data = {
  createSignalA2uiMessageProcessor: create,
  A2uiMessageProcessor,
  Guards: guards_exports
};
var Schemas = {
  A2UIClientEventMessage: server_to_client_with_standard_catalog_default
};

// node_modules/@a2ui/lit/dist/src/0.8/ui/image.js
var __esDecorate10 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers10 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Image = (() => {
  var _url_accessor_storage, _usageHint_accessor_storage, _fit_accessor_storage, __this_instances, renderImage_fn, _a3;
  let _classDecorators = [customElement("a2ui-image")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _url_decorators;
  let _url_initializers = [];
  let _url_extraInitializers = [];
  let _usageHint_decorators;
  let _usageHint_initializers = [];
  let _usageHint_extraInitializers = [];
  let _fit_decorators;
  let _fit_initializers = [];
  let _fit_extraInitializers = [];
  var Image2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _url_accessor_storage, __runInitializers10(this, _url_initializers, null));
      __privateAdd(this, _usageHint_accessor_storage, (__runInitializers10(this, _url_extraInitializers), __runInitializers10(this, _usageHint_initializers, null)));
      __privateAdd(this, _fit_accessor_storage, (__runInitializers10(this, _usageHint_extraInitializers), __runInitializers10(this, _fit_initializers, null)));
      __runInitializers10(this, _fit_extraInitializers);
    }
    get url() {
      return __privateGet(this, _url_accessor_storage);
    }
    set url(value) {
      __privateSet(this, _url_accessor_storage, value);
    }
    get usageHint() {
      return __privateGet(this, _usageHint_accessor_storage);
    }
    set usageHint(value) {
      __privateSet(this, _usageHint_accessor_storage, value);
    }
    get fit() {
      return __privateGet(this, _fit_accessor_storage);
    }
    set fit(value) {
      __privateSet(this, _fit_accessor_storage, value);
    }
    render() {
      var _a4;
      const classes = styles_exports.merge(this.theme.components.Image.all, this.usageHint ? this.theme.components.Image[this.usageHint] : {});
      return html`<section
      class=${classMap(classes)}
      style=${styleMap({
        ...((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Image) ?? {},
        "--object-fit": this.fit ?? "fill"
      })}
    >
      ${__privateMethod(this, __this_instances, renderImage_fn).call(this)}
    </section>`;
    }
  }, _url_accessor_storage = new WeakMap(), _usageHint_accessor_storage = new WeakMap(), _fit_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderImage_fn = function() {
    if (!this.url) {
      return nothing;
    }
    const render2 = (url) => {
      return html`<img src=${url} />`;
    };
    if (this.url && typeof this.url === "object") {
      if ("literalString" in this.url) {
        const imageUrl = this.url.literalString ?? "";
        return render2(imageUrl);
      } else if ("literal" in this.url) {
        const imageUrl = this.url.literal ?? "";
        return render2(imageUrl);
      } else if (this.url && "path" in this.url && this.url.path) {
        if (!this.processor || !this.component) {
          return html`(no model)`;
        }
        const imageUrl = this.processor.getData(this.component, this.url.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (!imageUrl) {
          return html`Invalid image URL`;
        }
        if (typeof imageUrl !== "string") {
          return html`Invalid image URL`;
        }
        return render2(imageUrl);
      }
    }
    return html`(empty)`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _url_decorators = [property()];
    _usageHint_decorators = [property()];
    _fit_decorators = [property()];
    __esDecorate10(_a3, null, _url_decorators, { kind: "accessor", name: "url", static: false, private: false, access: { has: (obj) => "url" in obj, get: (obj) => obj.url, set: (obj, value) => {
      obj.url = value;
    } }, metadata: _metadata }, _url_initializers, _url_extraInitializers);
    __esDecorate10(_a3, null, _usageHint_decorators, { kind: "accessor", name: "usageHint", static: false, private: false, access: { has: (obj) => "usageHint" in obj, get: (obj) => obj.usageHint, set: (obj, value) => {
      obj.usageHint = value;
    } }, metadata: _metadata }, _usageHint_initializers, _usageHint_extraInitializers);
    __esDecorate10(_a3, null, _fit_decorators, { kind: "accessor", name: "fit", static: false, private: false, access: { has: (obj) => "fit" in obj, get: (obj) => obj.fit, set: (obj, value) => {
      obj.fit = value;
    } }, metadata: _metadata }, _fit_initializers, _fit_extraInitializers);
    __esDecorate10(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Image2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: var(--object-fit, fill);
      }
    `
  ], __runInitializers10(_classThis, _classExtraInitializers), _a3);
  return Image2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/list.js
var __esDecorate11 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers11 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var List = (() => {
  var _direction_accessor_storage, _a3;
  let _classDecorators = [customElement("a2ui-list")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _direction_decorators;
  let _direction_initializers = [];
  let _direction_extraInitializers = [];
  var List2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _direction_accessor_storage, __runInitializers11(this, _direction_initializers, "vertical"));
      __runInitializers11(this, _direction_extraInitializers);
    }
    get direction() {
      return __privateGet(this, _direction_accessor_storage);
    }
    set direction(value) {
      __privateSet(this, _direction_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.List)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.List) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.List) : nothing}
    >
      <slot></slot>
    </section>`;
    }
  }, _direction_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _direction_decorators = [property({ reflect: true, type: String })];
    __esDecorate11(_a3, null, _direction_decorators, { kind: "accessor", name: "direction", static: false, private: false, access: { has: (obj) => "direction" in obj, get: (obj) => obj.direction, set: (obj, value) => {
      obj.direction = value;
    } }, metadata: _metadata }, _direction_initializers, _direction_extraInitializers);
    __esDecorate11(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    List2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      :host([direction="vertical"]) section {
        display: grid;
      }

      :host([direction="horizontal"]) section {
        display: flex;
        max-width: 100%;
        overflow-x: scroll;
        overflow-y: hidden;
        scrollbar-width: none;

        > ::slotted(*) {
          flex: 1 0 fit-content;
          max-width: min(80%, 400px);
        }
      }
    `
  ], __runInitializers11(_classThis, _classExtraInitializers), _a3);
  return List2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/utils/utils.js
var utils_exports = {};
__export(utils_exports, {
  extractNumberValue: () => extractNumberValue,
  extractStringValue: () => extractStringValue
});
function extractStringValue(val, component, processor, surfaceId) {
  if (val !== null && typeof val === "object") {
    if ("literalString" in val) {
      return val.literalString ?? "";
    } else if ("literal" in val && val.literal !== void 0) {
      return val.literal ?? "";
    } else if (val && "path" in val && val.path) {
      if (!processor || !component) {
        return "(no model)";
      }
      const textValue = processor.getData(component, val.path, surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
      if (textValue === null || typeof textValue !== "string") {
        return "";
      }
      return textValue;
    }
  }
  return "";
}
function extractNumberValue(val, component, processor, surfaceId) {
  if (val !== null && typeof val === "object") {
    if ("literalNumber" in val) {
      return val.literalNumber ?? 0;
    } else if ("literal" in val && val.literal !== void 0) {
      return val.literal ?? 0;
    } else if (val && "path" in val && val.path) {
      if (!processor || !component) {
        return -1;
      }
      let numberValue = processor.getData(component, val.path, surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
      if (typeof numberValue === "string") {
        numberValue = Number.parseInt(numberValue, 10);
        if (Number.isNaN(numberValue)) {
          numberValue = null;
        }
      }
      if (numberValue === null || typeof numberValue !== "number") {
        return -1;
      }
      return numberValue;
    }
  }
  return 0;
}

// node_modules/@a2ui/lit/dist/src/0.8/ui/multiple-choice.js
var __esDecorate12 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers12 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var MultipleChoice = (() => {
  var _description_accessor_storage, _options_accessor_storage, _selections_accessor_storage, __this_instances, setBoundValue_fn, _a3;
  let _classDecorators = [customElement("a2ui-multiplechoice")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _description_decorators;
  let _description_initializers = [];
  let _description_extraInitializers = [];
  let _options_decorators;
  let _options_initializers = [];
  let _options_extraInitializers = [];
  let _selections_decorators;
  let _selections_initializers = [];
  let _selections_extraInitializers = [];
  var MultipleChoice2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _description_accessor_storage, __runInitializers12(this, _description_initializers, null));
      __privateAdd(this, _options_accessor_storage, (__runInitializers12(this, _description_extraInitializers), __runInitializers12(this, _options_initializers, [])));
      __privateAdd(this, _selections_accessor_storage, (__runInitializers12(this, _options_extraInitializers), __runInitializers12(this, _selections_initializers, [])));
      __runInitializers12(this, _selections_extraInitializers);
    }
    get description() {
      return __privateGet(this, _description_accessor_storage);
    }
    set description(value) {
      __privateSet(this, _description_accessor_storage, value);
    }
    get options() {
      return __privateGet(this, _options_accessor_storage);
    }
    set options(value) {
      __privateSet(this, _options_accessor_storage, value);
    }
    get selections() {
      return __privateGet(this, _selections_accessor_storage);
    }
    set selections(value) {
      __privateSet(this, _selections_accessor_storage, value);
    }
    willUpdate(changedProperties) {
      const shouldUpdate = changedProperties.has("options");
      if (!shouldUpdate) {
        return;
      }
      if (!this.processor || !this.component || Array.isArray(this.selections)) {
        return;
      }
      this.selections;
      const selectionValue = this.processor.getData(this.component, this.selections.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
      if (!Array.isArray(selectionValue)) {
        return;
      }
      __privateMethod(this, __this_instances, setBoundValue_fn).call(this, selectionValue);
    }
    render() {
      var _a4, _b2;
      return html`<section class=${classMap(this.theme.components.MultipleChoice.container)}>
      <label class=${classMap(this.theme.components.MultipleChoice.label)} for="data">${this.description ?? "Select an item"}</div>
      <select
        name="data"
        id="data"
        class=${classMap(this.theme.components.MultipleChoice.element)}
        style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.MultipleChoice) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.MultipleChoice) : nothing}
        @change=${(evt) => {
        if (!(evt.target instanceof HTMLSelectElement)) {
          return;
        }
        __privateMethod(this, __this_instances, setBoundValue_fn).call(this, [evt.target.value]);
      }}
      >
        ${this.options.map((option) => {
        const label = extractStringValue(option.label, this.component, this.processor, this.surfaceId);
        return html`<option ${option.value}>${label}</option>`;
      })}
      </select>
    </section>`;
    }
  }, _description_accessor_storage = new WeakMap(), _options_accessor_storage = new WeakMap(), _selections_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), setBoundValue_fn = function(value) {
    console.log(value);
    if (!this.selections || !this.processor) {
      return;
    }
    if (!("path" in this.selections)) {
      return;
    }
    if (!this.selections.path) {
      return;
    }
    this.processor.setData(this.component, this.selections.path, value, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _description_decorators = [property()];
    _options_decorators = [property()];
    _selections_decorators = [property()];
    __esDecorate12(_a3, null, _description_decorators, { kind: "accessor", name: "description", static: false, private: false, access: { has: (obj) => "description" in obj, get: (obj) => obj.description, set: (obj, value) => {
      obj.description = value;
    } }, metadata: _metadata }, _description_initializers, _description_extraInitializers);
    __esDecorate12(_a3, null, _options_decorators, { kind: "accessor", name: "options", static: false, private: false, access: { has: (obj) => "options" in obj, get: (obj) => obj.options, set: (obj, value) => {
      obj.options = value;
    } }, metadata: _metadata }, _options_initializers, _options_extraInitializers);
    __esDecorate12(_a3, null, _selections_decorators, { kind: "accessor", name: "selections", static: false, private: false, access: { has: (obj) => "selections" in obj, get: (obj) => obj.selections, set: (obj, value) => {
      obj.selections = value;
    } }, metadata: _metadata }, _selections_initializers, _selections_extraInitializers);
    __esDecorate12(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    MultipleChoice2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      select {
        width: 100%;
      }

      .description {
      }
    `
  ], __runInitializers12(_classThis, _classExtraInitializers), _a3);
  return MultipleChoice2 = _classThis;
})();

// node_modules/lit-html/development/directives/ref.js
var lastElementForContextAndCallback = /* @__PURE__ */ new WeakMap();
var RefDirective = class extends AsyncDirective {
  render(_ref) {
    return nothing;
  }
  update(part, [ref2]) {
    var _a3;
    const refChanged = ref2 !== this._ref;
    if (refChanged && this._ref !== void 0) {
      this._updateRefValue(void 0);
    }
    if (refChanged || this._lastElementForRef !== this._element) {
      this._ref = ref2;
      this._context = (_a3 = part.options) == null ? void 0 : _a3.host;
      this._updateRefValue(this._element = part.element);
    }
    return nothing;
  }
  _updateRefValue(element) {
    if (!this.isConnected) {
      element = void 0;
    }
    if (typeof this._ref === "function") {
      const context = this._context ?? globalThis;
      let lastElementForCallback = lastElementForContextAndCallback.get(context);
      if (lastElementForCallback === void 0) {
        lastElementForCallback = /* @__PURE__ */ new WeakMap();
        lastElementForContextAndCallback.set(context, lastElementForCallback);
      }
      if (lastElementForCallback.get(this._ref) !== void 0) {
        this._ref.call(this._context, void 0);
      }
      lastElementForCallback.set(this._ref, element);
      if (element !== void 0) {
        this._ref.call(this._context, element);
      }
    } else {
      this._ref.value = element;
    }
  }
  get _lastElementForRef() {
    var _a3, _b2;
    return typeof this._ref === "function" ? (_a3 = lastElementForContextAndCallback.get(this._context ?? globalThis)) == null ? void 0 : _a3.get(this._ref) : (_b2 = this._ref) == null ? void 0 : _b2.value;
  }
  disconnected() {
    if (this._lastElementForRef === this._element) {
      this._updateRefValue(void 0);
    }
  }
  reconnected() {
    this._updateRefValue(this._element);
  }
};
var ref = directive(RefDirective);

// node_modules/@a2ui/lit/dist/src/0.8/ui/modal.js
var __esDecorate13 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers13 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var __setFunctionName = function(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
var Modal = (() => {
  var _showModal_accessor_storage, __this_instances, showModal_get, showModal_set, _modalRef_accessor_storage, modalRef_get, modalRef_set, closeModal_fn, _a3;
  let _classDecorators = [customElement("a2ui-modal")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _private_showModal_decorators;
  let _private_showModal_initializers = [];
  let _private_showModal_extraInitializers = [];
  let _private_showModal_descriptor;
  let _private_modalRef_decorators;
  let _private_modalRef_initializers = [];
  let _private_modalRef_extraInitializers = [];
  let _private_modalRef_descriptor;
  var Modal2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _showModal_accessor_storage, __runInitializers13(this, _private_showModal_initializers, false));
      __privateAdd(this, _modalRef_accessor_storage, (__runInitializers13(this, _private_showModal_extraInitializers), __runInitializers13(this, _private_modalRef_initializers, null)));
      __runInitializers13(this, _private_modalRef_extraInitializers);
    }
    render() {
      var _a4, _b2;
      if (!__privateGet(this, __this_instances, showModal_get)) {
        return html`<section
        @click=${() => {
          __privateSet(this, __this_instances, true, showModal_set);
        }}
      >
        <slot name="entry"></slot>
      </section>`;
      }
      return html`<dialog
      class=${classMap(this.theme.components.Modal.backdrop)}
      @click=${(evt) => {
        const [top] = evt.composedPath();
        if (!(top instanceof HTMLDialogElement)) {
          return;
        }
        __privateMethod(this, __this_instances, closeModal_fn).call(this);
      }}
      ${ref((el) => {
        const showModalIfNeeded = () => {
          const validElement = el && el instanceof HTMLDialogElement;
          if (!validElement || el.open) {
            return;
          }
          el.showModal();
        };
        requestAnimationFrame(showModalIfNeeded);
      })}
    >
      <section
        class=${classMap(this.theme.components.Modal.element)}
        style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Modal) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Modal) : nothing}
      >
        <div id="controls">
          <button
            @click=${() => {
        __privateMethod(this, __this_instances, closeModal_fn).call(this);
      }}
          >
            <span class="g-icon">close</span>
          </button>
        </div>
        <slot></slot>
      </section>
    </dialog>`;
    }
  }, _showModal_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), showModal_get = function() {
    return _private_showModal_descriptor.get.call(this);
  }, showModal_set = function(value) {
    return _private_showModal_descriptor.set.call(this, value);
  }, _modalRef_accessor_storage = new WeakMap(), modalRef_get = function() {
    return _private_modalRef_descriptor.get.call(this);
  }, modalRef_set = function(value) {
    return _private_modalRef_descriptor.set.call(this, value);
  }, closeModal_fn = function() {
    if (!__privateGet(this, __this_instances, modalRef_get)) {
      return;
    }
    if (__privateGet(this, __this_instances, modalRef_get).open) {
      __privateGet(this, __this_instances, modalRef_get).close();
    }
    __privateSet(this, __this_instances, false, showModal_set);
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _private_showModal_decorators = [state()];
    _private_modalRef_decorators = [query("dialog")];
    __esDecorate13(_a3, _private_showModal_descriptor = { get: __setFunctionName(function() {
      return __privateGet(this, _showModal_accessor_storage);
    }, "#showModal", "get"), set: __setFunctionName(function(value) {
      __privateSet(this, _showModal_accessor_storage, value);
    }, "#showModal", "set") }, _private_showModal_decorators, { kind: "accessor", name: "#showModal", static: false, private: true, access: { has: (obj) => __privateIn(__this_instances, obj), get: (obj) => __privateGet(obj, __this_instances, showModal_get), set: (obj, value) => {
      __privateSet(obj, __this_instances, value, showModal_set);
    } }, metadata: _metadata }, _private_showModal_initializers, _private_showModal_extraInitializers);
    __esDecorate13(_a3, _private_modalRef_descriptor = { get: __setFunctionName(function() {
      return __privateGet(this, _modalRef_accessor_storage);
    }, "#modalRef", "get"), set: __setFunctionName(function(value) {
      __privateSet(this, _modalRef_accessor_storage, value);
    }, "#modalRef", "set") }, _private_modalRef_decorators, { kind: "accessor", name: "#modalRef", static: false, private: true, access: { has: (obj) => __privateIn(__this_instances, obj), get: (obj) => __privateGet(obj, __this_instances, modalRef_get), set: (obj, value) => {
      __privateSet(obj, __this_instances, value, modalRef_set);
    } }, metadata: _metadata }, _private_modalRef_initializers, _private_modalRef_extraInitializers);
    __esDecorate13(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Modal2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      dialog {
        padding: 0 0 0 0;
        border: none;
        background: none;

        & section {
          & #controls {
            display: flex;
            justify-content: end;
            margin-bottom: 4px;

            & button {
              padding: 0;
              background: none;
              width: 20px;
              height: 20px;
              pointer: cursor;
              border: none;
              cursor: pointer;
            }
          }
        }
      }
    `
  ], __runInitializers13(_classThis, _classExtraInitializers), _a3);
  return Modal2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/row.js
var __esDecorate14 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers14 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Row = (() => {
  var _alignment_accessor_storage, _distribution_accessor_storage, _a3;
  let _classDecorators = [customElement("a2ui-row")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _alignment_decorators;
  let _alignment_initializers = [];
  let _alignment_extraInitializers = [];
  let _distribution_decorators;
  let _distribution_initializers = [];
  let _distribution_extraInitializers = [];
  var Row2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _alignment_accessor_storage, __runInitializers14(this, _alignment_initializers, "stretch"));
      __privateAdd(this, _distribution_accessor_storage, (__runInitializers14(this, _alignment_extraInitializers), __runInitializers14(this, _distribution_initializers, "start")));
      __runInitializers14(this, _distribution_extraInitializers);
    }
    get alignment() {
      return __privateGet(this, _alignment_accessor_storage);
    }
    set alignment(value) {
      __privateSet(this, _alignment_accessor_storage, value);
    }
    get distribution() {
      return __privateGet(this, _distribution_accessor_storage);
    }
    set distribution(value) {
      __privateSet(this, _distribution_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.Row)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Row) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Row) : nothing}
    >
      <slot></slot>
    </section>`;
    }
  }, _alignment_accessor_storage = new WeakMap(), _distribution_accessor_storage = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _alignment_decorators = [property({ reflect: true, type: String })];
    _distribution_decorators = [property({ reflect: true, type: String })];
    __esDecorate14(_a3, null, _alignment_decorators, { kind: "accessor", name: "alignment", static: false, private: false, access: { has: (obj) => "alignment" in obj, get: (obj) => obj.alignment, set: (obj, value) => {
      obj.alignment = value;
    } }, metadata: _metadata }, _alignment_initializers, _alignment_extraInitializers);
    __esDecorate14(_a3, null, _distribution_decorators, { kind: "accessor", name: "distribution", static: false, private: false, access: { has: (obj) => "distribution" in obj, get: (obj) => obj.distribution, set: (obj, value) => {
      obj.distribution = value;
    } }, metadata: _metadata }, _distribution_initializers, _distribution_extraInitializers);
    __esDecorate14(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Row2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: flex;
        flex: var(--weight);
      }

      section {
        display: flex;
        flex-direction: row;
        width: 100%;
        min-height: 100%;
      }

      :host([alignment="start"]) section {
        align-items: start;
      }

      :host([alignment="center"]) section {
        align-items: center;
      }

      :host([alignment="end"]) section {
        align-items: end;
      }

      :host([alignment="stretch"]) section {
        align-items: stretch;
      }

      :host([distribution="start"]) section {
        justify-content: start;
      }

      :host([distribution="center"]) section {
        justify-content: center;
      }

      :host([distribution="end"]) section {
        justify-content: end;
      }

      :host([distribution="spaceBetween"]) section {
        justify-content: space-between;
      }

      :host([distribution="spaceAround"]) section {
        justify-content: space-around;
      }

      :host([distribution="spaceEvenly"]) section {
        justify-content: space-evenly;
      }
    `
  ], __runInitializers14(_classThis, _classExtraInitializers), _a3);
  return Row2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/slider.js
var __esDecorate15 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers15 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Slider = (() => {
  var _value_accessor_storage, _minValue_accessor_storage, _maxValue_accessor_storage, _label_accessor_storage, _inputType_accessor_storage, __this_instances, setBoundValue_fn, renderField_fn, _a3;
  let _classDecorators = [customElement("a2ui-slider")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _minValue_decorators;
  let _minValue_initializers = [];
  let _minValue_extraInitializers = [];
  let _maxValue_decorators;
  let _maxValue_initializers = [];
  let _maxValue_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _inputType_decorators;
  let _inputType_initializers = [];
  let _inputType_extraInitializers = [];
  var Slider2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _value_accessor_storage, __runInitializers15(this, _value_initializers, null));
      __privateAdd(this, _minValue_accessor_storage, (__runInitializers15(this, _value_extraInitializers), __runInitializers15(this, _minValue_initializers, 0)));
      __privateAdd(this, _maxValue_accessor_storage, (__runInitializers15(this, _minValue_extraInitializers), __runInitializers15(this, _maxValue_initializers, 0)));
      __privateAdd(this, _label_accessor_storage, (__runInitializers15(this, _maxValue_extraInitializers), __runInitializers15(this, _label_initializers, null)));
      __privateAdd(this, _inputType_accessor_storage, (__runInitializers15(this, _label_extraInitializers), __runInitializers15(this, _inputType_initializers, null)));
      __runInitializers15(this, _inputType_extraInitializers);
    }
    get value() {
      return __privateGet(this, _value_accessor_storage);
    }
    set value(value) {
      __privateSet(this, _value_accessor_storage, value);
    }
    get minValue() {
      return __privateGet(this, _minValue_accessor_storage);
    }
    set minValue(value) {
      __privateSet(this, _minValue_accessor_storage, value);
    }
    get maxValue() {
      return __privateGet(this, _maxValue_accessor_storage);
    }
    set maxValue(value) {
      __privateSet(this, _maxValue_accessor_storage, value);
    }
    get label() {
      return __privateGet(this, _label_accessor_storage);
    }
    set label(value) {
      __privateSet(this, _label_accessor_storage, value);
    }
    get inputType() {
      return __privateGet(this, _inputType_accessor_storage);
    }
    set inputType(value) {
      __privateSet(this, _inputType_accessor_storage, value);
    }
    render() {
      if (this.value && typeof this.value === "object") {
        if ("literalNumber" in this.value && this.value.literalNumber) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literalNumber);
        } else if ("literal" in this.value && this.value.literal !== void 0) {
          return __privateMethod(this, __this_instances, renderField_fn).call(this, this.value.literal);
        } else if (this.value && "path" in this.value && this.value.path) {
          if (!this.processor || !this.component) {
            return html`(no processor)`;
          }
          const textValue = this.processor.getData(this.component, this.value.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
          if (textValue === null) {
            return html`Invalid value`;
          }
          if (typeof textValue !== "string" && typeof textValue !== "number") {
            return html`Invalid value`;
          }
          return __privateMethod(this, __this_instances, renderField_fn).call(this, textValue);
        }
      }
      return nothing;
    }
  }, _value_accessor_storage = new WeakMap(), _minValue_accessor_storage = new WeakMap(), _maxValue_accessor_storage = new WeakMap(), _label_accessor_storage = new WeakMap(), _inputType_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), setBoundValue_fn = function(value) {
    if (!this.value || !this.processor) {
      return;
    }
    if (!("path" in this.value)) {
      return;
    }
    if (!this.value.path) {
      return;
    }
    this.processor.setData(this.component, this.value.path, value, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
  }, renderField_fn = function(value) {
    var _a4, _b2, _c;
    return html`<section
      class=${classMap(this.theme.components.Slider.container)}
    >
      <label class=${classMap(this.theme.components.Slider.label)} for="data">
        ${((_a4 = this.label) == null ? void 0 : _a4.literalString) ?? ""}
      </label>
      <input
        autocomplete="off"
        class=${classMap(this.theme.components.Slider.element)}
        style=${((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Slider) ? styleMap((_c = this.theme.additionalStyles) == null ? void 0 : _c.Slider) : nothing}
        @input=${(evt) => {
      if (!(evt.target instanceof HTMLInputElement)) {
        return;
      }
      __privateMethod(this, __this_instances, setBoundValue_fn).call(this, evt.target.value);
    }}
        id="data"
        name="data"
        .value=${value}
        type="range"
        min=${this.minValue ?? "0"}
        max=${this.maxValue ?? "0"}
      />
      <span class=${classMap(this.theme.components.Slider.label)}
        >${this.value ? extractNumberValue(this.value, this.component, this.processor, this.surfaceId) : "0"}</span
      >
    </section>`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _value_decorators = [property()];
    _minValue_decorators = [property()];
    _maxValue_decorators = [property()];
    _label_decorators = [property()];
    _inputType_decorators = [property()];
    __esDecorate15(_a3, null, _value_decorators, { kind: "accessor", name: "value", static: false, private: false, access: { has: (obj) => "value" in obj, get: (obj) => obj.value, set: (obj, value) => {
      obj.value = value;
    } }, metadata: _metadata }, _value_initializers, _value_extraInitializers);
    __esDecorate15(_a3, null, _minValue_decorators, { kind: "accessor", name: "minValue", static: false, private: false, access: { has: (obj) => "minValue" in obj, get: (obj) => obj.minValue, set: (obj, value) => {
      obj.minValue = value;
    } }, metadata: _metadata }, _minValue_initializers, _minValue_extraInitializers);
    __esDecorate15(_a3, null, _maxValue_decorators, { kind: "accessor", name: "maxValue", static: false, private: false, access: { has: (obj) => "maxValue" in obj, get: (obj) => obj.maxValue, set: (obj, value) => {
      obj.maxValue = value;
    } }, metadata: _metadata }, _maxValue_initializers, _maxValue_extraInitializers);
    __esDecorate15(_a3, null, _label_decorators, { kind: "accessor", name: "label", static: false, private: false, access: { has: (obj) => "label" in obj, get: (obj) => obj.label, set: (obj, value) => {
      obj.label = value;
    } }, metadata: _metadata }, _label_initializers, _label_extraInitializers);
    __esDecorate15(_a3, null, _inputType_decorators, { kind: "accessor", name: "inputType", static: false, private: false, access: { has: (obj) => "inputType" in obj, get: (obj) => obj.inputType, set: (obj, value) => {
      obj.inputType = value;
    } }, metadata: _metadata }, _inputType_initializers, _inputType_extraInitializers);
    __esDecorate15(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Slider2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
      }

      input {
        display: block;
        width: 100%;
      }

      .description {
      }
    `
  ], __runInitializers15(_classThis, _classExtraInitializers), _a3);
  return Slider2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/surface.js
var __esDecorate16 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers16 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Surface = (() => {
  var _surfaceId_accessor_storage, _surface_accessor_storage, _processor_accessor_storage, __this_instances, renderLogo_fn, renderSurface_fn, _a3;
  let _classDecorators = [customElement("a2ui-surface")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _surfaceId_decorators;
  let _surfaceId_initializers = [];
  let _surfaceId_extraInitializers = [];
  let _surface_decorators;
  let _surface_initializers = [];
  let _surface_extraInitializers = [];
  let _processor_decorators;
  let _processor_initializers = [];
  let _processor_extraInitializers = [];
  var Surface2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _surfaceId_accessor_storage, __runInitializers16(this, _surfaceId_initializers, null));
      __privateAdd(this, _surface_accessor_storage, (__runInitializers16(this, _surfaceId_extraInitializers), __runInitializers16(this, _surface_initializers, null)));
      __privateAdd(this, _processor_accessor_storage, (__runInitializers16(this, _surface_extraInitializers), __runInitializers16(this, _processor_initializers, null)));
      __runInitializers16(this, _processor_extraInitializers);
    }
    get surfaceId() {
      return __privateGet(this, _surfaceId_accessor_storage);
    }
    set surfaceId(value) {
      __privateSet(this, _surfaceId_accessor_storage, value);
    }
    get surface() {
      return __privateGet(this, _surface_accessor_storage);
    }
    set surface(value) {
      __privateSet(this, _surface_accessor_storage, value);
    }
    get processor() {
      return __privateGet(this, _processor_accessor_storage);
    }
    set processor(value) {
      __privateSet(this, _processor_accessor_storage, value);
    }
    render() {
      if (!this.surface) {
        return nothing;
      }
      return html`${[__privateMethod(this, __this_instances, renderLogo_fn).call(this), __privateMethod(this, __this_instances, renderSurface_fn).call(this)]}`;
    }
  }, _surfaceId_accessor_storage = new WeakMap(), _surface_accessor_storage = new WeakMap(), _processor_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderLogo_fn = function() {
    var _a4;
    if (!((_a4 = this.surface) == null ? void 0 : _a4.styles.logoUrl)) {
      return nothing;
    }
    return html`<div id="surface-logo">
      <img src=${this.surface.styles.logoUrl} />
    </div>`;
  }, renderSurface_fn = function() {
    var _a4, _b2;
    const styles = {};
    if ((_a4 = this.surface) == null ? void 0 : _a4.styles) {
      for (const [key, value] of Object.entries(this.surface.styles)) {
        switch (key) {
          case "primaryColor": {
            break;
          }
          case "font": {
            break;
          }
        }
      }
    }
    return html`<a2ui-root
      style=${styleMap(styles)}
      .surfaceId=${this.surfaceId}
      .processor=${this.processor}
      .childComponents=${((_b2 = this.surface) == null ? void 0 : _b2.componentTree) ? [this.surface.componentTree] : null}
    ></a2ui-root>`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _surfaceId_decorators = [property()];
    _surface_decorators = [property()];
    _processor_decorators = [property()];
    __esDecorate16(_a3, null, _surfaceId_decorators, { kind: "accessor", name: "surfaceId", static: false, private: false, access: { has: (obj) => "surfaceId" in obj, get: (obj) => obj.surfaceId, set: (obj, value) => {
      obj.surfaceId = value;
    } }, metadata: _metadata }, _surfaceId_initializers, _surfaceId_extraInitializers);
    __esDecorate16(_a3, null, _surface_decorators, { kind: "accessor", name: "surface", static: false, private: false, access: { has: (obj) => "surface" in obj, get: (obj) => obj.surface, set: (obj, value) => {
      obj.surface = value;
    } }, metadata: _metadata }, _surface_initializers, _surface_extraInitializers);
    __esDecorate16(_a3, null, _processor_decorators, { kind: "accessor", name: "processor", static: false, private: false, access: { has: (obj) => "processor" in obj, get: (obj) => obj.processor, set: (obj, value) => {
      obj.processor = value;
    } }, metadata: _metadata }, _processor_initializers, _processor_extraInitializers);
    __esDecorate16(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Surface2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    css`
      :host {
        display: flex;
        min-height: 0;
        max-height: 100%;
        flex-direction: column;
        gap: 16px;
      }

      #surface-logo {
        display: flex;
        justify-content: center;

        & img {
          width: 50%;
          max-width: 220px;
        }
      }

      a2ui-root {
        flex: 1;
      }
    `
  ], __runInitializers16(_classThis, _classExtraInitializers), _a3);
  return Surface2 = _classThis;
})();

// node_modules/lit-html/development/directives/repeat.js
var generateMap = (list2, start, end) => {
  const map3 = /* @__PURE__ */ new Map();
  for (let i = start; i <= end; i++) {
    map3.set(list2[i], i);
  }
  return map3;
};
var RepeatDirective = class extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error("repeat() can only be used in text expressions");
    }
  }
  _getValuesAndKeys(items, keyFnOrTemplate, template) {
    let keyFn;
    if (template === void 0) {
      template = keyFnOrTemplate;
    } else if (keyFnOrTemplate !== void 0) {
      keyFn = keyFnOrTemplate;
    }
    const keys = [];
    const values = [];
    let index = 0;
    for (const item of items) {
      keys[index] = keyFn ? keyFn(item, index) : index;
      values[index] = template(item, index);
      index++;
    }
    return {
      values,
      keys
    };
  }
  render(items, keyFnOrTemplate, template) {
    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;
  }
  update(containerPart, [items, keyFnOrTemplate, template]) {
    const oldParts = getCommittedValue(containerPart);
    const { values: newValues, keys: newKeys } = this._getValuesAndKeys(items, keyFnOrTemplate, template);
    if (!Array.isArray(oldParts)) {
      this._itemKeys = newKeys;
      return newValues;
    }
    const oldKeys = this._itemKeys ?? (this._itemKeys = []);
    const newParts = [];
    let newKeyToIndexMap;
    let oldKeyToIndexMap;
    let oldHead = 0;
    let oldTail = oldParts.length - 1;
    let newHead = 0;
    let newTail = newValues.length - 1;
    while (oldHead <= oldTail && newHead <= newTail) {
      if (oldParts[oldHead] === null) {
        oldHead++;
      } else if (oldParts[oldTail] === null) {
        oldTail--;
      } else if (oldKeys[oldHead] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldHead], newValues[newHead]);
        oldHead++;
        newHead++;
      } else if (oldKeys[oldTail] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldTail], newValues[newTail]);
        oldTail--;
        newTail--;
      } else if (oldKeys[oldHead] === newKeys[newTail]) {
        newParts[newTail] = setChildPartValue(oldParts[oldHead], newValues[newTail]);
        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]);
        oldHead++;
        newTail--;
      } else if (oldKeys[oldTail] === newKeys[newHead]) {
        newParts[newHead] = setChildPartValue(oldParts[oldTail], newValues[newHead]);
        insertPart(containerPart, oldParts[oldHead], oldParts[oldTail]);
        oldTail--;
        newHead++;
      } else {
        if (newKeyToIndexMap === void 0) {
          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);
          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);
        }
        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {
          removePart(oldParts[oldHead]);
          oldHead++;
        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {
          removePart(oldParts[oldTail]);
          oldTail--;
        } else {
          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);
          const oldPart = oldIndex !== void 0 ? oldParts[oldIndex] : null;
          if (oldPart === null) {
            const newPart = insertPart(containerPart, oldParts[oldHead]);
            setChildPartValue(newPart, newValues[newHead]);
            newParts[newHead] = newPart;
          } else {
            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);
            insertPart(containerPart, oldParts[oldHead], oldPart);
            oldParts[oldIndex] = null;
          }
          newHead++;
        }
      }
    }
    while (newHead <= newTail) {
      const newPart = insertPart(containerPart, newParts[newTail + 1]);
      setChildPartValue(newPart, newValues[newHead]);
      newParts[newHead++] = newPart;
    }
    while (oldHead <= oldTail) {
      const oldPart = oldParts[oldHead++];
      if (oldPart !== null) {
        removePart(oldPart);
      }
    }
    this._itemKeys = newKeys;
    setCommittedValue(containerPart, newParts);
    return noChange;
  }
};
var repeat = directive(RepeatDirective);

// node_modules/@a2ui/lit/dist/src/0.8/ui/tabs.js
var __esDecorate17 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers17 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Tabs = (() => {
  var _titles_accessor_storage, _selected_accessor_storage, __this_instances, renderTabs_fn, renderSlot_fn, _a3;
  let _classDecorators = [customElement("a2ui-tabs")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _titles_decorators;
  let _titles_initializers = [];
  let _titles_extraInitializers = [];
  let _selected_decorators;
  let _selected_initializers = [];
  let _selected_extraInitializers = [];
  var Tabs2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _titles_accessor_storage, __runInitializers17(this, _titles_initializers, null));
      __privateAdd(this, _selected_accessor_storage, (__runInitializers17(this, _titles_extraInitializers), __runInitializers17(this, _selected_initializers, 0)));
      __runInitializers17(this, _selected_extraInitializers);
    }
    get titles() {
      return __privateGet(this, _titles_accessor_storage);
    }
    set titles(value) {
      __privateSet(this, _titles_accessor_storage, value);
    }
    get selected() {
      return __privateGet(this, _selected_accessor_storage);
    }
    set selected(value) {
      __privateSet(this, _selected_accessor_storage, value);
    }
    willUpdate(changedProperties) {
      super.willUpdate(changedProperties);
      if (changedProperties.has("selected")) {
        for (const child of this.children) {
          child.removeAttribute("slot");
        }
        const selectedChild = this.children[this.selected];
        if (!selectedChild) {
          return;
        }
        selectedChild.slot = "current";
      }
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.Tabs.container)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Tabs) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Tabs) : nothing}
    >
      ${[__privateMethod(this, __this_instances, renderTabs_fn).call(this), __privateMethod(this, __this_instances, renderSlot_fn).call(this)]}
    </section>`;
    }
  }, _titles_accessor_storage = new WeakMap(), _selected_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderTabs_fn = function() {
    if (!this.titles) {
      return nothing;
    }
    return html`<div
      id="buttons"
      class=${classMap(this.theme.components.Tabs.element)}
    >
      ${repeat(this.titles, (title, idx) => {
      let titleString = "";
      if ("literalString" in title && title.literalString) {
        titleString = title.literalString;
      } else if ("literal" in title && title.literal !== void 0) {
        titleString = title.literal;
      } else if (title && "path" in title && title.path) {
        if (!this.processor || !this.component) {
          return html`(no model)`;
        }
        const textValue = this.processor.getData(this.component, title.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (typeof textValue !== "string") {
          return html`(invalid)`;
        }
        titleString = textValue;
      }
      let classes;
      if (this.selected === idx) {
        classes = styles_exports.merge(this.theme.components.Tabs.controls.all, this.theme.components.Tabs.controls.selected);
      } else {
        classes = { ...this.theme.components.Tabs.controls.all };
      }
      return html`<button
          ?disabled=${this.selected === idx}
          class=${classMap(classes)}
          @click=${() => {
        this.selected = idx;
      }}
        >
          ${titleString}
        </button>`;
    })}
    </div>`;
  }, renderSlot_fn = function() {
    return html`<slot name="current"></slot>`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _titles_decorators = [property()];
    _selected_decorators = [property()];
    __esDecorate17(_a3, null, _titles_decorators, { kind: "accessor", name: "titles", static: false, private: false, access: { has: (obj) => "titles" in obj, get: (obj) => obj.titles, set: (obj, value) => {
      obj.titles = value;
    } }, metadata: _metadata }, _titles_initializers, _titles_extraInitializers);
    __esDecorate17(_a3, null, _selected_decorators, { kind: "accessor", name: "selected", static: false, private: false, access: { has: (obj) => "selected" in obj, get: (obj) => obj.selected, set: (obj, value) => {
      obj.selected = value;
    } }, metadata: _metadata }, _selected_initializers, _selected_extraInitializers);
    __esDecorate17(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Tabs2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      :host {
        display: block;
        flex: var(--weight);
      }
    `
  ], __runInitializers17(_classThis, _classExtraInitializers), _a3);
  return Tabs2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/text-field.js
var __esDecorate18 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers18 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var TextField = (() => {
  var _text_accessor_storage, _label_accessor_storage, _inputType_accessor_storage, __this_instances, setBoundValue_fn, renderField_fn, _a3;
  let _classDecorators = [customElement("a2ui-textfield")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _text_decorators;
  let _text_initializers = [];
  let _text_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _inputType_decorators;
  let _inputType_initializers = [];
  let _inputType_extraInitializers = [];
  var TextField2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _text_accessor_storage, __runInitializers18(this, _text_initializers, null));
      __privateAdd(this, _label_accessor_storage, (__runInitializers18(this, _text_extraInitializers), __runInitializers18(this, _label_initializers, null)));
      __privateAdd(this, _inputType_accessor_storage, (__runInitializers18(this, _label_extraInitializers), __runInitializers18(this, _inputType_initializers, null)));
      __runInitializers18(this, _inputType_extraInitializers);
    }
    get text() {
      return __privateGet(this, _text_accessor_storage);
    }
    set text(value) {
      __privateSet(this, _text_accessor_storage, value);
    }
    get label() {
      return __privateGet(this, _label_accessor_storage);
    }
    set label(value) {
      __privateSet(this, _label_accessor_storage, value);
    }
    get inputType() {
      return __privateGet(this, _inputType_accessor_storage);
    }
    set inputType(value) {
      __privateSet(this, _inputType_accessor_storage, value);
    }
    render() {
      const label = extractStringValue(this.label, this.component, this.processor, this.surfaceId);
      const value = extractStringValue(this.text, this.component, this.processor, this.surfaceId);
      return __privateMethod(this, __this_instances, renderField_fn).call(this, value, label);
    }
  }, _text_accessor_storage = new WeakMap(), _label_accessor_storage = new WeakMap(), _inputType_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), setBoundValue_fn = function(value) {
    if (!this.text || !this.processor) {
      return;
    }
    if (!("path" in this.text)) {
      return;
    }
    if (!this.text.path) {
      return;
    }
    this.processor.setData(this.component, this.text.path, value, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
  }, renderField_fn = function(value, label) {
    var _a4, _b2;
    return html` <section
      class=${classMap(this.theme.components.TextField.container)}
    >
      ${label && label !== "" ? html`<label
            class=${classMap(this.theme.components.TextField.label)}
            for="data"
            >${label}</label
          >` : nothing}
      <input
        autocomplete="off"
        class=${classMap(this.theme.components.TextField.element)}
        style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.TextField) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.TextField) : nothing}
        @input=${(evt) => {
      if (!(evt.target instanceof HTMLInputElement)) {
        return;
      }
      __privateMethod(this, __this_instances, setBoundValue_fn).call(this, evt.target.value);
    }}
        name="data"
        id="data"
        .value=${value}
        .placeholder=${"Please enter a value"}
        type=${this.inputType === "number" ? "number" : "text"}
      />
    </section>`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _text_decorators = [property()];
    _label_decorators = [property()];
    _inputType_decorators = [property()];
    __esDecorate18(_a3, null, _text_decorators, { kind: "accessor", name: "text", static: false, private: false, access: { has: (obj) => "text" in obj, get: (obj) => obj.text, set: (obj, value) => {
      obj.text = value;
    } }, metadata: _metadata }, _text_initializers, _text_extraInitializers);
    __esDecorate18(_a3, null, _label_decorators, { kind: "accessor", name: "label", static: false, private: false, access: { has: (obj) => "label" in obj, get: (obj) => obj.label, set: (obj, value) => {
      obj.label = value;
    } }, metadata: _metadata }, _label_initializers, _label_extraInitializers);
    __esDecorate18(_a3, null, _inputType_decorators, { kind: "accessor", name: "inputType", static: false, private: false, access: { has: (obj) => "inputType" in obj, get: (obj) => obj.inputType, set: (obj, value) => {
      obj.inputType = value;
    } }, metadata: _metadata }, _inputType_initializers, _inputType_extraInitializers);
    __esDecorate18(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    TextField2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: flex;
        flex: var(--weight);
      }

      input {
        display: block;
        width: 100%;
      }

      label {
        display: block;
        margin-bottom: 4px;
      }
    `
  ], __runInitializers18(_classThis, _classExtraInitializers), _a3);
  return TextField2 = _classThis;
})();

// node_modules/markdown-it/lib/common/utils.mjs
var utils_exports2 = {};
__export(utils_exports2, {
  arrayReplaceAt: () => arrayReplaceAt,
  assign: () => assign,
  escapeHtml: () => escapeHtml,
  escapeRE: () => escapeRE,
  fromCodePoint: () => fromCodePoint2,
  has: () => has,
  isMdAsciiPunct: () => isMdAsciiPunct,
  isPunctChar: () => isPunctChar,
  isSpace: () => isSpace,
  isString: () => isString,
  isValidEntityCode: () => isValidEntityCode,
  isWhiteSpace: () => isWhiteSpace,
  lib: () => lib,
  normalizeReference: () => normalizeReference,
  unescapeAll: () => unescapeAll,
  unescapeMd: () => unescapeMd
});

// node_modules/mdurl/index.mjs
var mdurl_exports = {};
__export(mdurl_exports, {
  decode: () => decode_default,
  encode: () => encode_default,
  format: () => format,
  parse: () => parse_default
});

// node_modules/mdurl/lib/decode.mjs
var decodeCache = {};
function getDecodeCache(exclude) {
  let cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (let i = 0; i < exclude.length; i++) {
    const ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode(string, exclude) {
  if (typeof exclude !== "string") {
    exclude = decode.defaultChars;
  }
  const cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    let result = "";
    for (let i = 0, l = seq.length; i < l; i += 3) {
      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          const chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          const chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l) {
        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          let chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "";
    }
    return result;
  });
}
decode.defaultChars = ";/?:@&=+$,#";
decode.componentChars = "";
var decode_default = decode;

// node_modules/mdurl/lib/encode.mjs
var encodeCache = {};
function getEncodeCache(exclude) {
  let cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (let i = 0; i < 128; i++) {
    const ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (let i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode(string, exclude, keepEscaped) {
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  const cache = getEncodeCache(exclude);
  let result = "";
  for (let i = 0, l = string.length; i < l; i++) {
    const code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result += cache[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        const nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
var encode_default = encode;

// node_modules/mdurl/lib/format.mjs
function format(url) {
  let result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}

// node_modules/mdurl/lib/parse.mjs
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i;
var portPattern = /:[0-9]*$/;
var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
var autoEscape = ["'"].concat(unwise);
var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
var hostEndingChars = ["/", "?", "#"];
var hostnameMaxLen = 255;
var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var hostlessProtocol = {
  javascript: true,
  "javascript:": true
};
var slashedProtocol = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) return url;
  const u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  let lowerProto, hec, slashes;
  let rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    const simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  let proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    let hostEnd = -1;
    for (let i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    let auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (let i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    const host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    const ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      const hostparts = this.hostname.split(/\./);
      for (let i = 0, l = hostparts.length; i < l; i++) {
        const part = hostparts[i];
        if (!part) {
          continue;
        }
        if (!part.match(hostnamePartPattern)) {
          let newpart = "";
          for (let j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            const validParts = hostparts.slice(0, i);
            const notHost = hostparts.slice(i + 1);
            const bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  const hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  const qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  let port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse_default = urlParse;

// node_modules/uc.micro/index.mjs
var uc_exports = {};
__export(uc_exports, {
  Any: () => regex_default,
  Cc: () => regex_default2,
  Cf: () => regex_default3,
  P: () => regex_default4,
  S: () => regex_default5,
  Z: () => regex_default6
});

// node_modules/uc.micro/properties/Any/regex.mjs
var regex_default = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

// node_modules/uc.micro/categories/Cc/regex.mjs
var regex_default2 = /[\0-\x1F\x7F-\x9F]/;

// node_modules/uc.micro/categories/Cf/regex.mjs
var regex_default3 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u0890\u0891\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD80D[\uDC30-\uDC3F]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

// node_modules/uc.micro/categories/P/regex.mjs
var regex_default4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDEAD\uDF55-\uDF59\uDF86-\uDF89]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5A\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDEB9\uDF3C-\uDF3E]|\uD806[\uDC3B\uDD44-\uDD46\uDDE2\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2\uDF00-\uDF09]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8\uDF43-\uDF4F\uDFFF]|\uD809[\uDC70-\uDC74]|\uD80B[\uDFF1\uDFF2]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A\uDFE2]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

// node_modules/uc.micro/categories/S/regex.mjs
var regex_default5 = /[\$\+<->\^`\|~\xA2-\xA6\xA8\xA9\xAC\xAE-\xB1\xB4\xB8\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0384\u0385\u03F6\u0482\u058D-\u058F\u0606-\u0608\u060B\u060E\u060F\u06DE\u06E9\u06FD\u06FE\u07F6\u07FE\u07FF\u0888\u09F2\u09F3\u09FA\u09FB\u0AF1\u0B70\u0BF3-\u0BFA\u0C7F\u0D4F\u0D79\u0E3F\u0F01-\u0F03\u0F13\u0F15-\u0F17\u0F1A-\u0F1F\u0F34\u0F36\u0F38\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE\u0FCF\u0FD5-\u0FD8\u109E\u109F\u1390-\u1399\u166D\u17DB\u1940\u19DE-\u19FF\u1B61-\u1B6A\u1B74-\u1B7C\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u2044\u2052\u207A-\u207C\u208A-\u208C\u20A0-\u20C0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F\u218A\u218B\u2190-\u2307\u230C-\u2328\u232B-\u2426\u2440-\u244A\u249C-\u24E9\u2500-\u2767\u2794-\u27C4\u27C7-\u27E5\u27F0-\u2982\u2999-\u29D7\u29DC-\u29FB\u29FE-\u2B73\u2B76-\u2B95\u2B97-\u2BFF\u2CE5-\u2CEA\u2E50\u2E51\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFF\u3004\u3012\u3013\u3020\u3036\u3037\u303E\u303F\u309B\u309C\u3190\u3191\u3196-\u319F\u31C0-\u31E3\u31EF\u3200-\u321E\u322A-\u3247\u3250\u3260-\u327F\u328A-\u32B0\u32C0-\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA700-\uA716\uA720\uA721\uA789\uA78A\uA828-\uA82B\uA836-\uA839\uAA77-\uAA79\uAB5B\uAB6A\uAB6B\uFB29\uFBB2-\uFBC2\uFD40-\uFD4F\uFDCF\uFDFC-\uFDFF\uFE62\uFE64-\uFE66\uFE69\uFF04\uFF0B\uFF1C-\uFF1E\uFF3E\uFF40\uFF5C\uFF5E\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFFC\uFFFD]|\uD800[\uDD37-\uDD3F\uDD79-\uDD89\uDD8C-\uDD8E\uDD90-\uDD9C\uDDA0\uDDD0-\uDDFC]|\uD802[\uDC77\uDC78\uDEC8]|\uD805\uDF3F|\uD807[\uDFD5-\uDFF1]|\uD81A[\uDF3C-\uDF3F\uDF45]|\uD82F\uDC9C|\uD833[\uDF50-\uDFC3]|\uD834[\uDC00-\uDCF5\uDD00-\uDD26\uDD29-\uDD64\uDD6A-\uDD6C\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDDEA\uDE00-\uDE41\uDE45\uDF00-\uDF56]|\uD835[\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85\uDE86]|\uD838[\uDD4F\uDEFF]|\uD83B[\uDCAC\uDCB0\uDD2E\uDEF0\uDEF1]|\uD83C[\uDC00-\uDC2B\uDC30-\uDC93\uDCA0-\uDCAE\uDCB1-\uDCBF\uDCC1-\uDCCF\uDCD1-\uDCF5\uDD0D-\uDDAD\uDDE6-\uDE02\uDE10-\uDE3B\uDE40-\uDE48\uDE50\uDE51\uDE60-\uDE65\uDF00-\uDFFF]|\uD83D[\uDC00-\uDED7\uDEDC-\uDEEC\uDEF0-\uDEFC\uDF00-\uDF76\uDF7B-\uDFD9\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDC00-\uDC0B\uDC10-\uDC47\uDC50-\uDC59\uDC60-\uDC87\uDC90-\uDCAD\uDCB0\uDCB1\uDD00-\uDE53\uDE60-\uDE6D\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8\uDF00-\uDF92\uDF94-\uDFCA]/;

// node_modules/uc.micro/categories/Z/regex.mjs
var regex_default6 = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

// node_modules/markdown-it/node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/markdown-it/node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((c) => c.charCodeAt(0))
);

// node_modules/markdown-it/node_modules/entities/lib/esm/decode_codepoint.js
var _a2;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a2 = String.fromCodePoint) !== null && _a2 !== void 0 ? _a2 : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// node_modules/markdown-it/node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code2) {
  return code2 >= CharCodes.ZERO && code2 <= CharCodes.NINE;
}
function isHexadecimalCharacter(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_F || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code2) {
  return code2 >= CharCodes.UPPER_A && code2 <= CharCodes.UPPER_Z || code2 >= CharCodes.LOWER_A && code2 <= CharCodes.LOWER_Z || isNumber(code2);
}
function isEntityInAttributeInvalidEnd(code2) {
  return code2 === CharCodes.EQUALS || isAsciiAlphaNumeric(code2);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors2) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors2;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base2) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base2, digitCount) + parseInt(str.substr(start, digitCount), base2);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      // Otherwise, emit a numeric entity if we have one.
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// node_modules/markdown-it/node_modules/entities/lib/esm/generated/encode-html.js
function restoreDiff(arr) {
  for (let i = 1; i < arr.length; i++) {
    arr[i][0] += arr[i - 1][0] + 1;
  }
  return arr;
}
var encode_html_default = new Map(restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));

// node_modules/markdown-it/node_modules/entities/lib/esm/escape.js
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c, index) => (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index)
  )
);
function getEscaper(regex, map3) {
  return function escape3(data) {
    let match2;
    let lastIdx = 0;
    let result = "";
    while (match2 = regex.exec(data)) {
      if (lastIdx !== match2.index) {
        result += data.substring(lastIdx, match2.index);
      }
      result += map3.get(match2[0].charCodeAt(0));
      lastIdx = match2.index + 1;
    }
    return result + data.substring(lastIdx);
  };
}
var escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));

// node_modules/markdown-it/node_modules/entities/lib/esm/index.js
var EntityLevel;
(function(EntityLevel2) {
  EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
  EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
})(EntityLevel || (EntityLevel = {}));
var EncodingMode;
(function(EncodingMode2) {
  EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
  EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
  EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
  EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
  EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
})(EncodingMode || (EncodingMode = {}));

// node_modules/markdown-it/lib/common/utils.mjs
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString(obj) {
  return _class(obj) === "[object String]";
}
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function has(object, key) {
  return _hasOwnProperty.call(object, key);
}
function assign(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be object");
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}
function isValidEntityCode(c) {
  if (c >= 55296 && c <= 57343) {
    return false;
  }
  if (c >= 64976 && c <= 65007) {
    return false;
  }
  if ((c & 65535) === 65535 || (c & 65535) === 65534) {
    return false;
  }
  if (c >= 0 && c <= 8) {
    return false;
  }
  if (c === 11) {
    return false;
  }
  if (c >= 14 && c <= 31) {
    return false;
  }
  if (c >= 127 && c <= 159) {
    return false;
  }
  if (c > 1114111) {
    return false;
  }
  return true;
}
function fromCodePoint2(c) {
  if (c > 65535) {
    c -= 65536;
    const surrogate1 = 55296 + (c >> 10);
    const surrogate2 = 56320 + (c & 1023);
    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}
var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
function replaceEntityPattern(match2, name) {
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    const code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if (isValidEntityCode(code2)) {
      return fromCodePoint2(code2);
    }
    return match2;
  }
  const decoded = decodeHTML(match2);
  if (decoded !== match2) {
    return decoded;
  }
  return match2;
}
function unescapeMd(str) {
  if (str.indexOf("\\") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_MD_RE, "$1");
}
function unescapeAll(str) {
  if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
    return str;
  }
  return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity2) {
    if (escaped) {
      return escaped;
    }
    return replaceEntityPattern(match2, entity2);
  });
}
var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}
function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}
var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, "\\$&");
}
function isSpace(code2) {
  switch (code2) {
    case 9:
    case 32:
      return true;
  }
  return false;
}
function isWhiteSpace(code2) {
  if (code2 >= 8192 && code2 <= 8202) {
    return true;
  }
  switch (code2) {
    case 9:
    // \t
    case 10:
    // \n
    case 11:
    // \v
    case 12:
    // \f
    case 13:
    // \r
    case 32:
    case 160:
    case 5760:
    case 8239:
    case 8287:
    case 12288:
      return true;
  }
  return false;
}
function isPunctChar(ch) {
  return regex_default4.test(ch) || regex_default5.test(ch);
}
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 124:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function normalizeReference(str) {
  str = str.trim().replace(/\s+/g, " ");
  if ("".toLowerCase() === "") {
    str = str.replace(//g, "");
  }
  return str.toLowerCase().toUpperCase();
}
var lib = { mdurl: mdurl_exports, ucmicro: uc_exports };

// node_modules/markdown-it/lib/helpers/index.mjs
var helpers_exports = {};
__export(helpers_exports, {
  parseLinkDestination: () => parseLinkDestination,
  parseLinkLabel: () => parseLinkLabel,
  parseLinkTitle: () => parseLinkTitle
});

// node_modules/markdown-it/lib/helpers/parse_link_label.mjs
function parseLinkLabel(state2, start, disableNested) {
  let level, found, marker, prevPos;
  const max = state2.posMax;
  const oldPos = state2.pos;
  state2.pos = start + 1;
  level = 1;
  while (state2.pos < max) {
    marker = state2.src.charCodeAt(state2.pos);
    if (marker === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state2.pos;
    state2.md.inline.skipToken(state2);
    if (marker === 91) {
      if (prevPos === state2.pos - 1) {
        level++;
      } else if (disableNested) {
        state2.pos = oldPos;
        return -1;
      }
    }
  }
  let labelEnd = -1;
  if (found) {
    labelEnd = state2.pos;
  }
  state2.pos = oldPos;
  return labelEnd;
}

// node_modules/markdown-it/lib/helpers/parse_link_destination.mjs
function parseLinkDestination(str, start, max) {
  let code2;
  let pos = start;
  const result = {
    ok: false,
    pos: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10) {
        return result;
      }
      if (code2 === 60) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  let level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === 32) {
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.pos = pos;
  result.ok = true;
  return result;
}

// node_modules/markdown-it/lib/helpers/parse_link_title.mjs
function parseLinkTitle(str, start, max, prev_state) {
  let code2;
  let pos = start;
  const state2 = {
    // if `true`, this is a valid link title
    ok: false,
    // if `true`, this link can be continued on the next line
    can_continue: false,
    // if `ok`, it's the position of the first character after the closing marker
    pos: 0,
    // if `ok`, it's the unescaped title
    str: "",
    // expected closing marker character code
    marker: 0
  };
  if (prev_state) {
    state2.str = prev_state.str;
    state2.marker = prev_state.marker;
  } else {
    if (pos >= max) {
      return state2;
    }
    let marker = str.charCodeAt(pos);
    if (marker !== 34 && marker !== 39 && marker !== 40) {
      return state2;
    }
    start++;
    pos++;
    if (marker === 40) {
      marker = 41;
    }
    state2.marker = marker;
  }
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 === state2.marker) {
      state2.pos = pos + 1;
      state2.str += unescapeAll(str.slice(start, pos));
      state2.ok = true;
      return state2;
    } else if (code2 === 40 && state2.marker === 41) {
      return state2;
    } else if (code2 === 92 && pos + 1 < max) {
      pos++;
    }
    pos++;
  }
  state2.can_continue = true;
  state2.str += unescapeAll(str.slice(start, pos));
  return state2;
}

// node_modules/markdown-it/lib/renderer.mjs
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  const info = token.info ? unescapeAll(token.info).trim() : "";
  let langName = "";
  let langAttrs = "";
  if (info) {
    const arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  let highlighted;
  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info) {
    const i = token.attrIndex("class");
    const tmpAttrs = token.attrs ? token.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    const tmpToken = {
      attrs: tmpAttrs
    };
    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>
`;
  }
  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>
`;
};
default_rules.image = function(tokens, idx, options, env, slf) {
  const token = tokens[idx];
  token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer() {
  this.rules = assign({}, default_rules);
}
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  let i, l, result;
  if (!token.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }
  return result;
};
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  const token = tokens[idx];
  let result = "";
  if (token.hidden) {
    return "";
  }
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token.nesting === -1 ? "</" : "<") + token.tag;
  result += this.renderAttrs(token);
  if (token.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  let needLf = false;
  if (token.block) {
    needLf = true;
    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        const nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
};
Renderer.prototype.renderInline = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type2 = tokens[i].type;
    if (typeof rules[type2] !== "undefined") {
      result += rules[type2](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
  let result = "";
  for (let i = 0, len = tokens.length; i < len; i++) {
    switch (tokens[i].type) {
      case "text":
        result += tokens[i].content;
        break;
      case "image":
        result += this.renderInlineAsText(tokens[i].children, options, env);
        break;
      case "html_inline":
      case "html_block":
        result += tokens[i].content;
        break;
      case "softbreak":
      case "hardbreak":
        result += "\n";
        break;
      default:
    }
  }
  return result;
};
Renderer.prototype.render = function(tokens, options, env) {
  let result = "";
  const rules = this.rules;
  for (let i = 0, len = tokens.length; i < len; i++) {
    const type2 = tokens[i].type;
    if (type2 === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type2] !== "undefined") {
      result += rules[type2](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer_default = Renderer;

// node_modules/markdown-it/lib/ruler.mjs
function Ruler() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler.prototype.__find__ = function(name) {
  for (let i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};
Ruler.prototype.__compile__ = function() {
  const self = this;
  const chains = [""];
  self.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self.__cache__ = {};
  chains.forEach(function(chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler.prototype.at = function(name, fn, options) {
  const index = this.__find__(name);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
  const index = this.__find__(beforeName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.after = function(afterName, ruleName, fn, options) {
  const index = this.__find__(afterName);
  const opt = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.push = function(ruleName, fn, options) {
  const opt = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt.alt || []
  });
  this.__cache__ = null;
};
Ruler.prototype.enable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list2, ignoreInvalid);
};
Ruler.prototype.disable = function(list2, ignoreInvalid) {
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  const result = [];
  list2.forEach(function(name) {
    const idx = this.__find__(name);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler_default = Ruler;

// node_modules/markdown-it/lib/token.mjs
function Token(type2, tag, nesting) {
  this.type = type2;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token.prototype.attrIndex = function attrIndex(name) {
  if (!this.attrs) {
    return -1;
  }
  const attrs = this.attrs;
  for (let i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }
  return -1;
};
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token.prototype.attrSet = function attrSet(name, value) {
  const idx = this.attrIndex(name);
  const attrData = [name, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token.prototype.attrGet = function attrGet(name) {
  const idx = this.attrIndex(name);
  let value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token.prototype.attrJoin = function attrJoin(name, value) {
  const idx = this.attrIndex(name);
  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token_default = Token;

// node_modules/markdown-it/lib/rules_core/state_core.mjs
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
StateCore.prototype.Token = token_default;
var state_core_default = StateCore;

// node_modules/markdown-it/lib/rules_core/normalize.mjs
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
function normalize(state2) {
  let str;
  str = state2.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "");
  state2.src = str;
}

// node_modules/markdown-it/lib/rules_core/block.mjs
function block(state2) {
  let token;
  if (state2.inlineMode) {
    token = new state2.Token("inline", "", 0);
    token.content = state2.src;
    token.map = [0, 1];
    token.children = [];
    state2.tokens.push(token);
  } else {
    state2.md.block.parse(state2.src, state2.md, state2.env, state2.tokens);
  }
}

// node_modules/markdown-it/lib/rules_core/inline.mjs
function inline(state2) {
  const tokens = state2.tokens;
  for (let i = 0, l = tokens.length; i < l; i++) {
    const tok = tokens[i];
    if (tok.type === "inline") {
      state2.md.inline.parse(tok.content, state2.md, state2.env, tok.children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/linkify.mjs
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
function linkify(state2) {
  const blockTokens = state2.tokens;
  if (!state2.md.options.linkify) {
    return;
  }
  for (let j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== "inline" || !state2.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    let tokens = blockTokens[j].children;
    let htmlLinkLevel = 0;
    for (let i = tokens.length - 1; i >= 0; i--) {
      const currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state2.md.linkify.test(currentToken.content)) {
        const text2 = currentToken.content;
        let links = state2.md.linkify.match(text2);
        const nodes = [];
        let level = currentToken.level;
        let lastPos = 0;
        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
          links = links.slice(1);
        }
        for (let ln = 0; ln < links.length; ln++) {
          const url = links[ln].url;
          const fullUrl = state2.md.normalizeLink(url);
          if (!state2.md.validateLink(fullUrl)) {
            continue;
          }
          let urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state2.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state2.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state2.md.normalizeLinkText(urlText);
          }
          const pos = links[ln].index;
          if (pos > lastPos) {
            const token = new state2.Token("text", "", 0);
            token.content = text2.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }
          const token_o = new state2.Token("link_open", "a", 1);
          token_o.attrs = [["href", fullUrl]];
          token_o.level = level++;
          token_o.markup = "linkify";
          token_o.info = "auto";
          nodes.push(token_o);
          const token_t = new state2.Token("text", "", 0);
          token_t.content = urlText;
          token_t.level = level;
          nodes.push(token_t);
          const token_c = new state2.Token("link_close", "a", -1);
          token_c.level = --level;
          token_c.markup = "linkify";
          token_c.info = "auto";
          nodes.push(token_c);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text2.length) {
          const token = new state2.Token("text", "", 0);
          token.content = text2.slice(lastPos);
          token.level = level;
          nodes.push(token);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}

// node_modules/markdown-it/lib/rules_core/replacements.mjs
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
var SCOPED_ABBR = {
  c: "",
  r: "",
  tm: ""
};
function replaceFn(match2, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  let inside_autolink = 0;
  for (let i = inlineTokens.length - 1; i >= 0; i--) {
    const token = inlineTokens[i];
    if (token.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, "").replace(/\.{2,}/g, "").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1").replace(/(^|\s)--(?=\s|$)/mg, "$1").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1");
      }
    }
    if (token.type === "link_open" && token.info === "auto") {
      inside_autolink--;
    }
    if (token.type === "link_close" && token.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace(state2) {
  let blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state2.tokens[blkIdx].content)) {
      replace_scoped(state2.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state2.tokens[blkIdx].content)) {
      replace_rare(state2.tokens[blkIdx].children);
    }
  }
}

// node_modules/markdown-it/lib/rules_core/smartquotes.mjs
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "";
function replaceAt(str, index, ch) {
  return str.slice(0, index) + ch + str.slice(index + 1);
}
function process_inlines(tokens, state2) {
  let j;
  const stack = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    const thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token.type !== "text") {
      continue;
    }
    let text2 = token.content;
    let pos = 0;
    let max = text2.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        const t = QUOTE_RE.exec(text2);
        if (!t) {
          break;
        }
        let canOpen = true;
        let canClose = true;
        pos = t.index + 1;
        const isSingle = t[0] === "'";
        let lastChar = 32;
        if (t.index - 1 >= 0) {
          lastChar = text2.charCodeAt(t.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        let nextChar = 32;
        if (pos < max) {
          nextChar = text2.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak") break;
            if (!tokens[j].content) continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
        const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
        const isLastWhiteSpace = isWhiteSpace(lastChar);
        const isNextWhiteSpace = isWhiteSpace(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token.content = replaceAt(token.content, t.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            let item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              let openQuote;
              let closeQuote;
              if (isSingle) {
                openQuote = state2.md.options.quotes[2];
                closeQuote = state2.md.options.quotes[3];
              } else {
                openQuote = state2.md.options.quotes[0];
                closeQuote = state2.md.options.quotes[1];
              }
              token.content = replaceAt(token.content, t.index, closeQuote);
              tokens[item.token].content = replaceAt(
                tokens[item.token].content,
                item.pos,
                openQuote
              );
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text2 = token.content;
              max = text2.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
      }
  }
}
function smartquotes(state2) {
  if (!state2.md.options.typographer) {
    return;
  }
  for (let blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state2.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state2.tokens[blkIdx].children, state2);
  }
}

// node_modules/markdown-it/lib/rules_core/text_join.mjs
function text_join(state2) {
  let curr, last;
  const blockTokens = state2.tokens;
  const l = blockTokens.length;
  for (let j = 0; j < l; j++) {
    if (blockTokens[j].type !== "inline") continue;
    const tokens = blockTokens[j].children;
    const max = tokens.length;
    for (curr = 0; curr < max; curr++) {
      if (tokens[curr].type === "text_special") {
        tokens[curr].type = "text";
      }
    }
    for (curr = last = 0; curr < max; curr++) {
      if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
      } else {
        if (curr !== last) {
          tokens[last] = tokens[curr];
        }
        last++;
      }
    }
    if (curr !== last) {
      tokens.length = last;
    }
  }
}

// node_modules/markdown-it/lib/parser_core.mjs
var _rules = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replace],
  ["smartquotes", smartquotes],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", text_join]
];
function Core() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
Core.prototype.process = function(state2) {
  const rules = this.ruler.getRules("");
  for (let i = 0, l = rules.length; i < l; i++) {
    rules[i](state2);
  }
};
Core.prototype.State = state_core_default;
var parser_core_default = Core;

// node_modules/markdown-it/lib/rules_block/state_block.mjs
function StateBlock(src, md, env, tokens) {
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  const s = this.src;
  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {
    const ch = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type2, tag, nesting) {
  const token = new token_default(type2, tag, nesting);
  token.block = true;
  if (nesting < 0) this.level--;
  token.level = this.level;
  if (nesting > 0) this.level++;
  this.tokens.push(token);
  return token;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (let max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  for (let max = this.src.length; pos < max; pos++) {
    const ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code2) {
  for (let max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code2) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code2 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  if (begin >= end) {
    return "";
  }
  const queue = new Array(end - begin);
  for (let i = 0, line = begin; line < end; line++, i++) {
    let lineIndent = 0;
    const lineStart = this.bMarks[line];
    let first = lineStart;
    let last;
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent) {
      const ch = this.src.charCodeAt(first);
      if (isSpace(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent) {
      queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = token_default;
var state_block_default = StateBlock;

// node_modules/markdown-it/lib/rules_block/table.mjs
var MAX_AUTOCOMPLETED_CELLS = 65536;
function getLine(state2, line) {
  const pos = state2.bMarks[line] + state2.tShift[line];
  const max = state2.eMarks[line];
  return state2.src.slice(pos, max);
}
function escapedSplit(str) {
  const result = [];
  const max = str.length;
  let pos = 0;
  let ch = str.charCodeAt(pos);
  let isEscaped = false;
  let lastPos = 0;
  let current = "";
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
function table(state2, startLine, endLine, silent) {
  if (startLine + 2 > endLine) {
    return false;
  }
  let nextLine = startLine + 1;
  if (state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  let pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  const firstCh = state2.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  const secondCh = state2.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace(secondCh)) {
    return false;
  }
  while (pos < state2.eMarks[nextLine]) {
    const ch = state2.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
      return false;
    }
    pos++;
  }
  let lineText = getLine(state2, startLine + 1);
  let columns = lineText.split("|");
  const aligns = [];
  for (let i = 0; i < columns.length; i++) {
    const t = columns[i].trim();
    if (!t) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t)) {
      return false;
    }
    if (t.charCodeAt(t.length - 1) === 58) {
      aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state2, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "") columns.shift();
  if (columns.length && columns[columns.length - 1] === "") columns.pop();
  const columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldParentType = state2.parentType;
  state2.parentType = "table";
  const terminatorRules = state2.md.block.ruler.getRules("blockquote");
  const token_to = state2.push("table_open", "table", 1);
  const tableLines = [startLine, 0];
  token_to.map = tableLines;
  const token_tho = state2.push("thead_open", "thead", 1);
  token_tho.map = [startLine, startLine + 1];
  const token_htro = state2.push("tr_open", "tr", 1);
  token_htro.map = [startLine, startLine + 1];
  for (let i = 0; i < columns.length; i++) {
    const token_ho = state2.push("th_open", "th", 1);
    if (aligns[i]) {
      token_ho.attrs = [["style", "text-align:" + aligns[i]]];
    }
    const token_il = state2.push("inline", "", 0);
    token_il.content = columns[i].trim();
    token_il.children = [];
    state2.push("th_close", "th", -1);
  }
  state2.push("tr_close", "tr", -1);
  state2.push("thead_close", "thead", -1);
  let tbodyLines;
  let autocompletedCells = 0;
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state2, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "") columns.shift();
    if (columns.length && columns[columns.length - 1] === "") columns.pop();
    autocompletedCells += columnCount - columns.length;
    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {
      break;
    }
    if (nextLine === startLine + 2) {
      const token_tbo = state2.push("tbody_open", "tbody", 1);
      token_tbo.map = tbodyLines = [startLine + 2, 0];
    }
    const token_tro = state2.push("tr_open", "tr", 1);
    token_tro.map = [nextLine, nextLine + 1];
    for (let i = 0; i < columnCount; i++) {
      const token_tdo = state2.push("td_open", "td", 1);
      if (aligns[i]) {
        token_tdo.attrs = [["style", "text-align:" + aligns[i]]];
      }
      const token_il = state2.push("inline", "", 0);
      token_il.content = columns[i] ? columns[i].trim() : "";
      token_il.children = [];
      state2.push("td_close", "td", -1);
    }
    state2.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    state2.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  state2.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state2.parentType = oldParentType;
  state2.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/rules_block/code.mjs
function code(state2, startLine, endLine) {
  if (state2.sCount[startLine] - state2.blkIndent < 4) {
    return false;
  }
  let nextLine = startLine + 1;
  let last = nextLine;
  while (nextLine < endLine) {
    if (state2.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state2.line = last;
  const token = state2.push("code_block", "code", 0);
  token.content = state2.getLines(startLine, last, 4 + state2.blkIndent, false) + "\n";
  token.map = [startLine, state2.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/fence.mjs
function fence(state2, startLine, endLine, silent) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  const marker = state2.src.charCodeAt(pos);
  if (marker !== 126 && marker !== 96) {
    return false;
  }
  let mem = pos;
  pos = state2.skipChars(pos, marker);
  let len = pos - mem;
  if (len < 3) {
    return false;
  }
  const markup = state2.src.slice(mem, pos);
  const params = state2.src.slice(pos, max);
  if (marker === 96) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  let nextLine = startLine;
  let haveEndMarker = false;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos < max && state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.src.charCodeAt(pos) !== marker) {
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      continue;
    }
    pos = state2.skipChars(pos, marker);
    if (pos - mem < len) {
      continue;
    }
    pos = state2.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state2.sCount[startLine];
  state2.line = nextLine + (haveEndMarker ? 1 : 0);
  const token = state2.push("fence", "code", 0);
  token.info = params;
  token.content = state2.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state2.line];
  return true;
}

// node_modules/markdown-it/lib/rules_block/blockquote.mjs
function blockquote(state2, startLine, endLine, silent) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  const oldLineMax = state2.lineMax;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  const oldBMarks = [];
  const oldBSCount = [];
  const oldSCount = [];
  const oldTShift = [];
  const terminatorRules = state2.md.block.ruler.getRules("blockquote");
  const oldParentType = state2.parentType;
  state2.parentType = "blockquote";
  let lastLineEmpty = false;
  let nextLine;
  for (nextLine = startLine; nextLine < endLine; nextLine++) {
    const isOutdented = state2.sCount[nextLine] < state2.blkIndent;
    pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state2.src.charCodeAt(pos++) === 62 && !isOutdented) {
      let initial = state2.sCount[nextLine] + 1;
      let spaceAfterMarker;
      let adjustTab;
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state2.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state2.bsCount[nextLine] + initial) % 4 === 3) {
          pos++;
          initial++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      let offset = initial;
      oldBMarks.push(state2.bMarks[nextLine]);
      state2.bMarks[nextLine] = pos;
      while (pos < max) {
        const ch = state2.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state2.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state2.bsCount[nextLine]);
      state2.bsCount[nextLine] = state2.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state2.sCount[nextLine]);
      state2.sCount[nextLine] = offset - initial;
      oldTShift.push(state2.tShift[nextLine]);
      state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state2.lineMax = nextLine;
      if (state2.blkIndent !== 0) {
        oldBMarks.push(state2.bMarks[nextLine]);
        oldBSCount.push(state2.bsCount[nextLine]);
        oldTShift.push(state2.tShift[nextLine]);
        oldSCount.push(state2.sCount[nextLine]);
        state2.sCount[nextLine] -= state2.blkIndent;
      }
      break;
    }
    oldBMarks.push(state2.bMarks[nextLine]);
    oldBSCount.push(state2.bsCount[nextLine]);
    oldTShift.push(state2.tShift[nextLine]);
    oldSCount.push(state2.sCount[nextLine]);
    state2.sCount[nextLine] = -1;
  }
  const oldIndent = state2.blkIndent;
  state2.blkIndent = 0;
  const token_o = state2.push("blockquote_open", "blockquote", 1);
  token_o.markup = ">";
  const lines = [startLine, 0];
  token_o.map = lines;
  state2.md.block.tokenize(state2, startLine, nextLine);
  const token_c = state2.push("blockquote_close", "blockquote", -1);
  token_c.markup = ">";
  state2.lineMax = oldLineMax;
  state2.parentType = oldParentType;
  lines[1] = state2.line;
  for (let i = 0; i < oldTShift.length; i++) {
    state2.bMarks[i + startLine] = oldBMarks[i];
    state2.tShift[i + startLine] = oldTShift[i];
    state2.sCount[i + startLine] = oldSCount[i];
    state2.bsCount[i + startLine] = oldBSCount[i];
  }
  state2.blkIndent = oldIndent;
  return true;
}

// node_modules/markdown-it/lib/rules_block/hr.mjs
function hr(state2, startLine, endLine, silent) {
  const max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  const marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 95) {
    return false;
  }
  let cnt = 1;
  while (pos < max) {
    const ch = state2.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) {
      return false;
    }
    if (ch === marker) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state2.line = startLine + 1;
  const token = state2.push("hr", "hr", 0);
  token.map = [startLine, state2.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
}

// node_modules/markdown-it/lib/rules_block/list.mjs
function skipBulletListMarker(state2, startLine) {
  const max = state2.eMarks[startLine];
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  const marker = state2.src.charCodeAt(pos++);
  if (marker !== 42 && marker !== 45 && marker !== 43) {
    return -1;
  }
  if (pos < max) {
    const ch = state2.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state2, startLine) {
  const start = state2.bMarks[startLine] + state2.tShift[startLine];
  const max = state2.eMarks[startLine];
  let pos = start;
  if (pos + 1 >= max) {
    return -1;
  }
  let ch = state2.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state2.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace(ch)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state2, idx) {
  const level = state2.level + 2;
  for (let i = idx + 2, l = state2.tokens.length - 2; i < l; i++) {
    if (state2.tokens[i].level === level && state2.tokens[i].type === "paragraph_open") {
      state2.tokens[i + 2].hidden = true;
      state2.tokens[i].hidden = true;
      i += 2;
    }
  }
}
function list(state2, startLine, endLine, silent) {
  let max, pos, start, token;
  let nextLine = startLine;
  let tight = true;
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.listIndent >= 0 && state2.sCount[nextLine] - state2.listIndent >= 4 && state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  let isTerminatingParagraph = false;
  if (silent && state2.parentType === "paragraph") {
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  let isOrdered;
  let markerValue;
  let posAfterMarker;
  if ((posAfterMarker = skipOrderedListMarker(state2, nextLine)) >= 0) {
    isOrdered = true;
    start = state2.bMarks[nextLine] + state2.tShift[nextLine];
    markerValue = Number(state2.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state2, nextLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state2.skipSpaces(posAfterMarker) >= state2.eMarks[nextLine]) return false;
  }
  if (silent) {
    return true;
  }
  const markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
  const listTokIdx = state2.tokens.length;
  if (isOrdered) {
    token = state2.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token.attrs = [["start", markerValue]];
    }
  } else {
    token = state2.push("bullet_list_open", "ul", 1);
  }
  const listLines = [nextLine, 0];
  token.map = listLines;
  token.markup = String.fromCharCode(markerCharCode);
  let prevEmptyEnd = false;
  const terminatorRules = state2.md.block.ruler.getRules("list");
  const oldParentType = state2.parentType;
  state2.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state2.eMarks[nextLine];
    const initial = state2.sCount[nextLine] + posAfterMarker - (state2.bMarks[nextLine] + state2.tShift[nextLine]);
    let offset = initial;
    while (pos < max) {
      const ch = state2.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state2.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    const contentStart = pos;
    let indentAfterMarker;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    const indent = initial + indentAfterMarker;
    token = state2.push("list_item_open", "li", 1);
    token.markup = String.fromCharCode(markerCharCode);
    const itemLines = [nextLine, 0];
    token.map = itemLines;
    if (isOrdered) {
      token.info = state2.src.slice(start, posAfterMarker - 1);
    }
    const oldTight = state2.tight;
    const oldTShift = state2.tShift[nextLine];
    const oldSCount = state2.sCount[nextLine];
    const oldListIndent = state2.listIndent;
    state2.listIndent = state2.blkIndent;
    state2.blkIndent = indent;
    state2.tight = true;
    state2.tShift[nextLine] = contentStart - state2.bMarks[nextLine];
    state2.sCount[nextLine] = offset;
    if (contentStart >= max && state2.isEmpty(nextLine + 1)) {
      state2.line = Math.min(state2.line + 2, endLine);
    } else {
      state2.md.block.tokenize(state2, nextLine, endLine, true);
    }
    if (!state2.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state2.line - nextLine > 1 && state2.isEmpty(state2.line - 1);
    state2.blkIndent = state2.listIndent;
    state2.listIndent = oldListIndent;
    state2.tShift[nextLine] = oldTShift;
    state2.sCount[nextLine] = oldSCount;
    state2.tight = oldTight;
    token = state2.push("list_item_close", "li", -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = state2.line;
    itemLines[1] = nextLine;
    if (nextLine >= endLine) {
      break;
    }
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state2.bMarks[nextLine] + state2.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token = state2.push("ordered_list_close", "ol", -1);
  } else {
    token = state2.push("bullet_list_close", "ul", -1);
  }
  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state2.line = nextLine;
  state2.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state2, listTokIdx);
  }
  return true;
}

// node_modules/markdown-it/lib/rules_block/reference.mjs
function reference(state2, startLine, _endLine, silent) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  let nextLine = startLine + 1;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 91) {
    return false;
  }
  function getNextLine(nextLine2) {
    const endLine = state2.lineMax;
    if (nextLine2 >= endLine || state2.isEmpty(nextLine2)) {
      return null;
    }
    let isContinuation = false;
    if (state2.sCount[nextLine2] - state2.blkIndent > 3) {
      isContinuation = true;
    }
    if (state2.sCount[nextLine2] < 0) {
      isContinuation = true;
    }
    if (!isContinuation) {
      const terminatorRules = state2.md.block.ruler.getRules("reference");
      const oldParentType = state2.parentType;
      state2.parentType = "reference";
      let terminate = false;
      for (let i = 0, l = terminatorRules.length; i < l; i++) {
        if (terminatorRules[i](state2, nextLine2, endLine, true)) {
          terminate = true;
          break;
        }
      }
      state2.parentType = oldParentType;
      if (terminate) {
        return null;
      }
    }
    const pos2 = state2.bMarks[nextLine2] + state2.tShift[nextLine2];
    const max2 = state2.eMarks[nextLine2];
    return state2.src.slice(pos2, max2 + 1);
  }
  let str = state2.src.slice(pos, max + 1);
  max = str.length;
  let labelEnd = -1;
  for (pos = 1; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        const lineContent = getNextLine(nextLine);
        if (lineContent !== null) {
          str += lineContent;
          max = str.length;
          nextLine++;
        }
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  const destRes = state2.md.helpers.parseLinkDestination(str, pos, max);
  if (!destRes.ok) {
    return false;
  }
  const href = state2.md.normalizeLink(destRes.str);
  if (!state2.md.validateLink(href)) {
    return false;
  }
  pos = destRes.pos;
  const destEndPos = pos;
  const destEndLineNo = nextLine;
  const start = pos;
  for (; pos < max; pos++) {
    const ch = str.charCodeAt(pos);
    if (ch === 10) {
      const lineContent = getNextLine(nextLine);
      if (lineContent !== null) {
        str += lineContent;
        max = str.length;
        nextLine++;
      }
    } else if (isSpace(ch)) {
    } else {
      break;
    }
  }
  let titleRes = state2.md.helpers.parseLinkTitle(str, pos, max);
  while (titleRes.can_continue) {
    const lineContent = getNextLine(nextLine);
    if (lineContent === null) break;
    str += lineContent;
    pos = max;
    max = str.length;
    nextLine++;
    titleRes = state2.md.helpers.parseLinkTitle(str, pos, max, titleRes);
  }
  let title;
  if (pos < max && start !== pos && titleRes.ok) {
    title = titleRes.str;
    pos = titleRes.pos;
  } else {
    title = "";
    pos = destEndPos;
    nextLine = destEndLineNo;
  }
  while (pos < max) {
    const ch = str.charCodeAt(pos);
    if (!isSpace(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      nextLine = destEndLineNo;
      while (pos < max) {
        const ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  const label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state2.env.references === "undefined") {
    state2.env.references = {};
  }
  if (typeof state2.env.references[label] === "undefined") {
    state2.env.references[label] = { title, href };
  }
  state2.line = nextLine;
  return true;
}

// node_modules/markdown-it/lib/common/html_blocks.mjs
var html_blocks_default = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];

// node_modules/markdown-it/lib/common/html_re.mjs
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---?>|<!--(?:[^-]|-[^-]|--[^>])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Za-z][^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");

// node_modules/markdown-it/lib/rules_block/html_block.mjs
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + html_blocks_default.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
function html_block(state2, startLine, endLine, silent) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (!state2.md.options.html) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  let lineText = state2.src.slice(pos, max);
  let i = 0;
  for (; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  let nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state2.sCount[nextLine] < state2.blkIndent) {
        break;
      }
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max = state2.eMarks[nextLine];
      lineText = state2.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state2.line = nextLine;
  const token = state2.push("html_block", "", 0);
  token.map = [startLine, nextLine];
  token.content = state2.getLines(startLine, nextLine, state2.blkIndent, true);
  return true;
}

// node_modules/markdown-it/lib/rules_block/heading.mjs
function heading(state2, startLine, endLine, silent) {
  let pos = state2.bMarks[startLine] + state2.tShift[startLine];
  let max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  let ch = state2.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  let level = 1;
  ch = state2.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state2.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state2.skipSpacesBack(max, pos);
  const tmp = state2.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace(state2.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state2.line = startLine + 1;
  const token_o = state2.push("heading_open", "h" + String(level), 1);
  token_o.markup = "########".slice(0, level);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = state2.src.slice(pos, max).trim();
  token_i.map = [startLine, state2.line];
  token_i.children = [];
  const token_c = state2.push("heading_close", "h" + String(level), -1);
  token_c.markup = "########".slice(0, level);
  return true;
}

// node_modules/markdown-it/lib/rules_block/lheading.mjs
function lheading(state2, startLine, endLine) {
  const terminatorRules = state2.md.block.ruler.getRules("paragraph");
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  const oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  let level = 0;
  let marker;
  let nextLine = startLine + 1;
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      let pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      const max = state2.eMarks[nextLine];
      if (pos < max) {
        marker = state2.src.charCodeAt(pos);
        if (marker === 45 || marker === 61) {
          pos = state2.skipChars(pos, marker);
          pos = state2.skipSpaces(pos);
          if (pos >= max) {
            level = marker === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  const content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine + 1;
  const token_o = state2.push("heading_open", "h" + String(level), 1);
  token_o.markup = String.fromCharCode(marker);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state2.line - 1];
  token_i.children = [];
  const token_c = state2.push("heading_close", "h" + String(level), -1);
  token_c.markup = String.fromCharCode(marker);
  state2.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/rules_block/paragraph.mjs
function paragraph(state2, startLine, endLine) {
  const terminatorRules = state2.md.block.ruler.getRules("paragraph");
  const oldParentType = state2.parentType;
  let nextLine = startLine + 1;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    let terminate = false;
    for (let i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  const content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine;
  const token_o = state2.push("paragraph_open", "p", 1);
  token_o.map = [startLine, state2.line];
  const token_i = state2.push("inline", "", 0);
  token_i.content = content;
  token_i.map = [startLine, state2.line];
  token_i.children = [];
  state2.push("paragraph_close", "p", -1);
  state2.parentType = oldParentType;
  return true;
}

// node_modules/markdown-it/lib/parser_block.mjs
var _rules2 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules2.length; i++) {
    this.ruler.push(_rules2[i][0], _rules2[i][1], { alt: (_rules2[i][2] || []).slice() });
  }
}
ParserBlock.prototype.tokenize = function(state2, startLine, endLine) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state2.md.options.maxNesting;
  let line = startLine;
  let hasEmptyLines = false;
  while (line < endLine) {
    state2.line = line = state2.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state2.sCount[line] < state2.blkIndent) {
      break;
    }
    if (state2.level >= maxNesting) {
      state2.line = endLine;
      break;
    }
    const prevLine = state2.line;
    let ok = false;
    for (let i = 0; i < len; i++) {
      ok = rules[i](state2, line, endLine, false);
      if (ok) {
        if (prevLine >= state2.line) {
          throw new Error("block rule didn't increment state.line");
        }
        break;
      }
    }
    if (!ok) throw new Error("none of the block rules matched");
    state2.tight = !hasEmptyLines;
    if (state2.isEmpty(state2.line - 1)) {
      hasEmptyLines = true;
    }
    line = state2.line;
    if (line < endLine && state2.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state2.line = line;
    }
  }
};
ParserBlock.prototype.parse = function(src, md, env, outTokens) {
  if (!src) {
    return;
  }
  const state2 = new this.State(src, md, env, outTokens);
  this.tokenize(state2, state2.line, state2.lineMax);
};
ParserBlock.prototype.State = state_block_default;
var parser_block_default = ParserBlock;

// node_modules/markdown-it/lib/rules_inline/state_inline.mjs
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
  this.linkLevel = 0;
}
StateInline.prototype.pushPending = function() {
  const token = new token_default("text", "", 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = "";
  return token;
};
StateInline.prototype.push = function(type2, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  const token = new token_default(type2, tag, nesting);
  let token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  const max = this.posMax;
  const marker = this.src.charCodeAt(start);
  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  let pos = start;
  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }
  const count = pos - start;
  const nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  const isLastWhiteSpace = isWhiteSpace(lastChar);
  const isNextWhiteSpace = isWhiteSpace(nextChar);
  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);
  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);
  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);
  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);
  return { can_open, can_close, length: count };
};
StateInline.prototype.Token = token_default;
var state_inline_default = StateInline;

// node_modules/markdown-it/lib/rules_inline/text.mjs
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
function text(state2, silent) {
  let pos = state2.pos;
  while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state2.pos) {
    return false;
  }
  if (!silent) {
    state2.pending += state2.src.slice(state2.pos, pos);
  }
  state2.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/linkify.mjs
var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
function linkify2(state2, silent) {
  if (!state2.md.options.linkify) return false;
  if (state2.linkLevel > 0) return false;
  const pos = state2.pos;
  const max = state2.posMax;
  if (pos + 3 > max) return false;
  if (state2.src.charCodeAt(pos) !== 58) return false;
  if (state2.src.charCodeAt(pos + 1) !== 47) return false;
  if (state2.src.charCodeAt(pos + 2) !== 47) return false;
  const match2 = state2.pending.match(SCHEME_RE);
  if (!match2) return false;
  const proto = match2[1];
  const link2 = state2.md.linkify.matchAtStart(state2.src.slice(pos - proto.length));
  if (!link2) return false;
  let url = link2.url;
  if (url.length <= proto.length) return false;
  url = url.replace(/\*+$/, "");
  const fullUrl = state2.md.normalizeLink(url);
  if (!state2.md.validateLink(fullUrl)) return false;
  if (!silent) {
    state2.pending = state2.pending.slice(0, -proto.length);
    const token_o = state2.push("link_open", "a", 1);
    token_o.attrs = [["href", fullUrl]];
    token_o.markup = "linkify";
    token_o.info = "auto";
    const token_t = state2.push("text", "", 0);
    token_t.content = state2.md.normalizeLinkText(url);
    const token_c = state2.push("link_close", "a", -1);
    token_c.markup = "linkify";
    token_c.info = "auto";
  }
  state2.pos += url.length - proto.length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/newline.mjs
function newline(state2, silent) {
  let pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state2.pending.length - 1;
  const max = state2.posMax;
  if (!silent) {
    if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
        let ws = pmax - 1;
        while (ws >= 1 && state2.pending.charCodeAt(ws - 1) === 32) ws--;
        state2.pending = state2.pending.slice(0, ws);
        state2.push("hardbreak", "br", 0);
      } else {
        state2.pending = state2.pending.slice(0, -1);
        state2.push("softbreak", "br", 0);
      }
    } else {
      state2.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace(state2.src.charCodeAt(pos))) {
    pos++;
  }
  state2.pos = pos;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/escape.mjs
var ESCAPED = [];
for (let i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
function escape2(state2, silent) {
  let pos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 92) return false;
  pos++;
  if (pos >= max) return false;
  let ch1 = state2.src.charCodeAt(pos);
  if (ch1 === 10) {
    if (!silent) {
      state2.push("hardbreak", "br", 0);
    }
    pos++;
    while (pos < max) {
      ch1 = state2.src.charCodeAt(pos);
      if (!isSpace(ch1)) break;
      pos++;
    }
    state2.pos = pos;
    return true;
  }
  let escapedStr = state2.src[pos];
  if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
    const ch2 = state2.src.charCodeAt(pos + 1);
    if (ch2 >= 56320 && ch2 <= 57343) {
      escapedStr += state2.src[pos + 1];
      pos++;
    }
  }
  const origStr = "\\" + escapedStr;
  if (!silent) {
    const token = state2.push("text_special", "", 0);
    if (ch1 < 256 && ESCAPED[ch1] !== 0) {
      token.content = escapedStr;
    } else {
      token.content = origStr;
    }
    token.markup = origStr;
    token.info = "escape";
  }
  state2.pos = pos + 1;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/backticks.mjs
function backtick(state2, silent) {
  let pos = state2.pos;
  const ch = state2.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  const start = pos;
  pos++;
  const max = state2.posMax;
  while (pos < max && state2.src.charCodeAt(pos) === 96) {
    pos++;
  }
  const marker = state2.src.slice(start, pos);
  const openerLength = marker.length;
  if (state2.backticksScanned && (state2.backticks[openerLength] || 0) <= start) {
    if (!silent) state2.pending += marker;
    state2.pos += openerLength;
    return true;
  }
  let matchEnd = pos;
  let matchStart;
  while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state2.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    const closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        const token = state2.push("code_inline", "code", 0);
        token.markup = marker;
        token.content = state2.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state2.pos = matchEnd;
      return true;
    }
    state2.backticks[closerLength] = matchStart;
  }
  state2.backticksScanned = true;
  if (!silent) state2.pending += marker;
  state2.pos += openerLength;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/strikethrough.mjs
function strikethrough_tokenize(state2, silent) {
  const start = state2.pos;
  const marker = state2.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state2.scanDelims(state2.pos, true);
  let len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len < 2) {
    return false;
  }
  let token;
  if (len % 2) {
    token = state2.push("text", "", 0);
    token.content = ch;
    len--;
  }
  for (let i = 0; i < len; i += 2) {
    token = state2.push("text", "", 0);
    token.content = ch + ch;
    state2.delimiters.push({
      marker,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}
function postProcess(state2, delimiters) {
  let token;
  const loneMarkers = [];
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    token = state2.tokens[startDelim.token];
    token.type = "s_open";
    token.tag = "s";
    token.nesting = 1;
    token.markup = "~~";
    token.content = "";
    token = state2.tokens[endDelim.token];
    token.type = "s_close";
    token.tag = "s";
    token.nesting = -1;
    token.markup = "~~";
    token.content = "";
    if (state2.tokens[endDelim.token - 1].type === "text" && state2.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    const i = loneMarkers.pop();
    let j = i + 1;
    while (j < state2.tokens.length && state2.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token = state2.tokens[j];
      state2.tokens[j] = state2.tokens[i];
      state2.tokens[i] = token;
    }
  }
}
function strikethrough_postProcess(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  postProcess(state2, state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state2, tokens_meta[curr].delimiters);
    }
  }
}
var strikethrough_default = {
  tokenize: strikethrough_tokenize,
  postProcess: strikethrough_postProcess
};

// node_modules/markdown-it/lib/rules_inline/emphasis.mjs
function emphasis_tokenize(state2, silent) {
  const start = state2.pos;
  const marker = state2.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 95 && marker !== 42) {
    return false;
  }
  const scanned = state2.scanDelims(state2.pos, marker === 42);
  for (let i = 0; i < scanned.length; i++) {
    const token = state2.push("text", "", 0);
    token.content = String.fromCharCode(marker);
    state2.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // A position of the token this delimiter corresponds to.
      //
      token: state2.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}
function postProcess2(state2, delimiters) {
  const max = delimiters.length;
  for (let i = max - 1; i >= 0; i--) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    const isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
    delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    delimiters[startDelim.end + 1].token === endDelim.token + 1;
    const ch = String.fromCharCode(startDelim.marker);
    const token_o = state2.tokens[startDelim.token];
    token_o.type = isStrong ? "strong_open" : "em_open";
    token_o.tag = isStrong ? "strong" : "em";
    token_o.nesting = 1;
    token_o.markup = isStrong ? ch + ch : ch;
    token_o.content = "";
    const token_c = state2.tokens[endDelim.token];
    token_c.type = isStrong ? "strong_close" : "em_close";
    token_c.tag = isStrong ? "strong" : "em";
    token_c.nesting = -1;
    token_c.markup = isStrong ? ch + ch : ch;
    token_c.content = "";
    if (isStrong) {
      state2.tokens[delimiters[i - 1].token].content = "";
      state2.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
function emphasis_post_process(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  postProcess2(state2, state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess2(state2, tokens_meta[curr].delimiters);
    }
  }
}
var emphasis_default = {
  tokenize: emphasis_tokenize,
  postProcess: emphasis_post_process
};

// node_modules/markdown-it/lib/rules_inline/link.mjs
function link(state2, silent) {
  let code2, label, res, ref2;
  let href = "";
  let title = "";
  let start = state2.pos;
  let parseReference = true;
  if (state2.src.charCodeAt(state2.pos) !== 91) {
    return false;
  }
  const oldPos = state2.pos;
  const max = state2.posMax;
  const labelStart = state2.pos + 1;
  const labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  let pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state2.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference(label)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    const token_o = state2.push("link_open", "a", 1);
    const attrs = [["href", href]];
    token_o.attrs = attrs;
    if (title) {
      attrs.push(["title", title]);
    }
    state2.linkLevel++;
    state2.md.inline.tokenize(state2);
    state2.linkLevel--;
    state2.push("link_close", "a", -1);
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/image.mjs
function image(state2, silent) {
  let code2, content, label, pos, ref2, res, title, start;
  let href = "";
  const oldPos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(state2.pos) !== 33) {
    return false;
  }
  if (state2.src.charCodeAt(state2.pos + 1) !== 91) {
    return false;
  }
  const labelStart = state2.pos + 2;
  const labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code2 = state2.src.charCodeAt(pos);
      if (!isSpace(code2) && code2 !== 10) {
        break;
      }
    }
    res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code2 = state2.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      state2.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref2 = state2.env.references[normalizeReference(label)];
    if (!ref2) {
      state2.pos = oldPos;
      return false;
    }
    href = ref2.href;
    title = ref2.title;
  }
  if (!silent) {
    content = state2.src.slice(labelStart, labelEnd);
    const tokens = [];
    state2.md.inline.parse(
      content,
      state2.md,
      state2.env,
      tokens
    );
    const token = state2.push("image", "img", 0);
    const attrs = [["src", href], ["alt", ""]];
    token.attrs = attrs;
    token.children = tokens;
    token.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/autolink.mjs
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function autolink(state2, silent) {
  let pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state2.pos;
  const max = state2.posMax;
  for (; ; ) {
    if (++pos >= max) return false;
    const ch = state2.src.charCodeAt(pos);
    if (ch === 60) return false;
    if (ch === 62) break;
  }
  const url = state2.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    const fullUrl = state2.md.normalizeLink(url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state2.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state2.push("text", "", 0);
      token_t.content = state2.md.normalizeLinkText(url);
      const token_c = state2.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    const fullUrl = state2.md.normalizeLink("mailto:" + url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      const token_o = state2.push("link_open", "a", 1);
      token_o.attrs = [["href", fullUrl]];
      token_o.markup = "autolink";
      token_o.info = "auto";
      const token_t = state2.push("text", "", 0);
      token_t.content = state2.md.normalizeLinkText(url);
      const token_c = state2.push("link_close", "a", -1);
      token_c.markup = "autolink";
      token_c.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/html_inline.mjs
function isLinkOpen2(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose2(str) {
  return /^<\/a\s*>/i.test(str);
}
function isLetter(ch) {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
function html_inline(state2, silent) {
  if (!state2.md.options.html) {
    return false;
  }
  const max = state2.posMax;
  const pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state2.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match2 = state2.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    const token = state2.push("html_inline", "", 0);
    token.content = match2[0];
    if (isLinkOpen2(token.content)) state2.linkLevel++;
    if (isLinkClose2(token.content)) state2.linkLevel--;
  }
  state2.pos += match2[0].length;
  return true;
}

// node_modules/markdown-it/lib/rules_inline/entity.mjs
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
function entity(state2, silent) {
  const pos = state2.pos;
  const max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 38) return false;
  if (pos + 1 >= max) return false;
  const ch = state2.src.charCodeAt(pos + 1);
  if (ch === 35) {
    const match2 = state2.src.slice(pos).match(DIGITAL_RE);
    if (match2) {
      if (!silent) {
        const code2 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
        const token = state2.push("text_special", "", 0);
        token.content = isValidEntityCode(code2) ? fromCodePoint2(code2) : fromCodePoint2(65533);
        token.markup = match2[0];
        token.info = "entity";
      }
      state2.pos += match2[0].length;
      return true;
    }
  } else {
    const match2 = state2.src.slice(pos).match(NAMED_RE);
    if (match2) {
      const decoded = decodeHTML(match2[0]);
      if (decoded !== match2[0]) {
        if (!silent) {
          const token = state2.push("text_special", "", 0);
          token.content = decoded;
          token.markup = match2[0];
          token.info = "entity";
        }
        state2.pos += match2[0].length;
        return true;
      }
    }
  }
  return false;
}

// node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs
function processDelimiters(delimiters) {
  const openersBottom = {};
  const max = delimiters.length;
  if (!max) return;
  let headerIdx = 0;
  let lastTokenIdx = -2;
  const jumps = [];
  for (let closerIdx = 0; closerIdx < max; closerIdx++) {
    const closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close) continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    let openerIdx = headerIdx - jumps[headerIdx] - 1;
    let newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      const opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker) continue;
      if (opener.open && opener.end < 0) {
        let isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
function link_pairs(state2) {
  const tokens_meta = state2.tokens_meta;
  const max = state2.tokens_meta.length;
  processDelimiters(state2.delimiters);
  for (let curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(tokens_meta[curr].delimiters);
    }
  }
}

// node_modules/markdown-it/lib/rules_inline/fragments_join.mjs
function fragments_join(state2) {
  let curr, last;
  let level = 0;
  const tokens = state2.tokens;
  const max = state2.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0) level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}

// node_modules/markdown-it/lib/parser_inline.mjs
var _rules3 = [
  ["text", text],
  ["linkify", linkify2],
  ["newline", newline],
  ["escape", escape2],
  ["backticks", backtick],
  ["strikethrough", strikethrough_default.tokenize],
  ["emphasis", emphasis_default.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules22 = [
  ["balance_pairs", link_pairs],
  ["strikethrough", strikethrough_default.postProcess],
  ["emphasis", emphasis_default.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", fragments_join]
];
function ParserInline() {
  this.ruler = new ruler_default();
  for (let i = 0; i < _rules3.length; i++) {
    this.ruler.push(_rules3[i][0], _rules3[i][1]);
  }
  this.ruler2 = new ruler_default();
  for (let i = 0; i < _rules22.length; i++) {
    this.ruler2.push(_rules22[i][0], _rules22[i][1]);
  }
}
ParserInline.prototype.skipToken = function(state2) {
  const pos = state2.pos;
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const maxNesting = state2.md.options.maxNesting;
  const cache = state2.cache;
  if (typeof cache[pos] !== "undefined") {
    state2.pos = cache[pos];
    return;
  }
  let ok = false;
  if (state2.level < maxNesting) {
    for (let i = 0; i < len; i++) {
      state2.level++;
      ok = rules[i](state2, true);
      state2.level--;
      if (ok) {
        if (pos >= state2.pos) {
          throw new Error("inline rule didn't increment state.pos");
        }
        break;
      }
    }
  } else {
    state2.pos = state2.posMax;
  }
  if (!ok) {
    state2.pos++;
  }
  cache[pos] = state2.pos;
};
ParserInline.prototype.tokenize = function(state2) {
  const rules = this.ruler.getRules("");
  const len = rules.length;
  const end = state2.posMax;
  const maxNesting = state2.md.options.maxNesting;
  while (state2.pos < end) {
    const prevPos = state2.pos;
    let ok = false;
    if (state2.level < maxNesting) {
      for (let i = 0; i < len; i++) {
        ok = rules[i](state2, false);
        if (ok) {
          if (prevPos >= state2.pos) {
            throw new Error("inline rule didn't increment state.pos");
          }
          break;
        }
      }
    }
    if (ok) {
      if (state2.pos >= end) {
        break;
      }
      continue;
    }
    state2.pending += state2.src[state2.pos++];
  }
  if (state2.pending) {
    state2.pushPending();
  }
};
ParserInline.prototype.parse = function(str, md, env, outTokens) {
  const state2 = new this.State(str, md, env, outTokens);
  this.tokenize(state2);
  const rules = this.ruler2.getRules("");
  const len = rules.length;
  for (let i = 0; i < len; i++) {
    rules[i](state2);
  }
};
ParserInline.prototype.State = state_inline_default;
var parser_inline_default = ParserInline;

// node_modules/linkify-it/lib/re.mjs
function re_default(opts) {
  const re = {};
  opts = opts || {};
  re.src_Any = regex_default.source;
  re.src_Cc = regex_default2.source;
  re.src_Z = regex_default6.source;
  re.src_P = regex_default4.source;
  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
  re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
  const text_separators = "[><]";
  re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
  re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
  re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + // allow `,,,` in paths
  ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
  re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re.src_domain_root = // Allow letters & digits (http://test1)
  "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
  re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
  re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
  re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
  re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
  re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + re.src_ZPCc + "))((?![$+<=>^`|])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
  return re;
}

// node_modules/linkify-it/index.mjs
function assign2(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class2(obj) {
  return Object.prototype.toString.call(obj);
}
function isString2(obj) {
  return _class2(obj) === "[object String]";
}
function isObject2(obj) {
  return _class2(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class2(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class2(obj) === "[object Function]";
}
function escapeRE2(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.http) {
        self.re.http = new RegExp(
          "^\\/\\/" + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path,
          "i"
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.no_http) {
        self.re.no_http = new RegExp(
          "^" + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          "(?:localhost|(?:(?:" + self.re.src_domain + ")\\.)+" + self.re.src_domain_root + ")" + self.re.src_port + self.re.src_host_terminator + self.re.src_path,
          "i"
        );
      }
      if (self.re.no_http.test(tail)) {
        if (pos >= 3 && text2[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text2[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text2, pos, self) {
      const tail = text2.slice(pos);
      if (!self.re.mailto) {
        self.re.mailto = new RegExp(
          "^" + self.re.src_email_name + "@" + self.re.src_host_strict,
          "i"
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = "";
}
function createValidator(re) {
  return function(text2, pos) {
    const tail = text2.slice(pos);
    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self) {
    self.normalize(match2);
  };
}
function compile(self) {
  const re = self.re = re_default(self.__opts__);
  const tlds2 = self.__tlds__.slice();
  self.onCompile();
  if (!self.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re.src_xn);
  re.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re.src_tlds);
  }
  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
  const aliases = [];
  self.__compiled__ = {};
  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }
  Object.keys(self.__schemas__).forEach(function(name) {
    const val = self.__schemas__[name];
    if (val === null) {
      return;
    }
    const compiled = { validate: null, link: null };
    self.__compiled__[name] = compiled;
    if (isObject2(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }
      return;
    }
    if (isString2(val)) {
      aliases.push(name);
      return;
    }
    schemaError(name, val);
  });
  aliases.forEach(function(alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      return;
    }
    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  });
  self.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  const slist = Object.keys(self.__compiled__).filter(function(name) {
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE2).join("|");
  self.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "i");
  self.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
  self.re.schema_at_start = RegExp("^" + self.re.schema_search.source, "i");
  self.re.pretest = RegExp(
    "(" + self.re.schema_test.source + ")|(" + self.re.host_fuzzy_test.source + ")|@",
    "i"
  );
  resetScanCache(self);
}
function Match(self, shift) {
  const start = self.__index__;
  const end = self.__last_index__;
  const text2 = self.__text_cache__.slice(start, end);
  this.schema = self.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text2;
  this.text = text2;
  this.url = text2;
}
function createMatch(self, shift) {
  const match2 = new Match(self, shift);
  self.__compiled__[match2.schema].normalize(match2, self);
  return match2;
}
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign2({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign2({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign2(this.__opts__, options);
  return this;
};
LinkifyIt.prototype.test = function test(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) {
    return false;
  }
  let m, ml, me, len, shift, next, re, tld_pos, at_pos;
  if (this.re.schema_test.test(text2)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text2)) !== null) {
      len = this.testSchemaAt(text2, m[2], re.lastIndex);
      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text2.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text2.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text2.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt.prototype.pretest = function pretest(text2) {
  return this.re.pretest.test(text2);
};
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
};
LinkifyIt.prototype.match = function match(text2) {
  const result = [];
  let shift = 0;
  if (this.__index__ >= 0 && this.__text_cache__ === text2) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  let tail = shift ? text2.slice(shift) : text2;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
};
LinkifyIt.prototype.matchAtStart = function matchAtStart(text2) {
  this.__text_cache__ = text2;
  this.__index__ = -1;
  if (!text2.length) return null;
  const m = this.re.schema_at_start.exec(text2);
  if (!m) return null;
  const len = this.testSchemaAt(text2, m[2], m[0].length);
  if (!len) return null;
  this.__schema__ = m[2];
  this.__index__ = m.index + m[1].length;
  this.__last_index__ = m.index + m[0].length + len;
  return createMatch(this, 0);
};
LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
  list2 = Array.isArray(list2) ? list2 : [list2];
  if (!keepOld) {
    this.__tlds__ = list2.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt.prototype.normalize = function normalize2(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt.prototype.onCompile = function onCompile() {
};
var linkify_it_default = LinkifyIt;

// node_modules/punycode.js/punycode.es6.js
var maxInt = 2147483647;
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128;
var delimiter = "-";
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7F]/;
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
var errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map2(array, callback) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = callback(array[length]);
  }
  return result;
}
function mapDomain(domain, callback) {
  const parts = domain.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    domain = parts[1];
  }
  domain = domain.replace(regexSeparators, ".");
  const labels = domain.split(".");
  const encoded = map2(labels, callback).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
var basicToDigit = function(codePoint) {
  if (codePoint >= 48 && codePoint < 58) {
    return 26 + (codePoint - 48);
  }
  if (codePoint >= 65 && codePoint < 91) {
    return codePoint - 65;
  }
  if (codePoint >= 97 && codePoint < 123) {
    return codePoint - 97;
  }
  return base;
};
var digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
var adapt = function(delta, numPoints, firstTime) {
  let k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
var decode2 = function(input2) {
  const output = [];
  const inputLength = input2.length;
  let i = 0;
  let n = initialN;
  let bias = initialBias;
  let basic = input2.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input2.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input2.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    const oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input2.charCodeAt(index++));
      if (digit >= base) {
        error("invalid-input");
      }
      if (digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t) {
        break;
      }
      const baseMinusT = base - t;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n) {
      error("overflow");
    }
    n += floor(i / out);
    i %= out;
    output.splice(i++, 0, n);
  }
  return String.fromCodePoint(...output);
};
var encode2 = function(input2) {
  const output = [];
  input2 = ucs2decode(input2);
  const inputLength = input2.length;
  let n = initialN;
  let delta = 0;
  let bias = initialBias;
  for (const currentValue of input2) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  const basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m = maxInt;
    for (const currentValue of input2) {
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta += (m - n) * handledCPCountPlusOne;
    n = m;
    for (const currentValue of input2) {
      if (currentValue < n && ++delta > maxInt) {
        error("overflow");
      }
      if (currentValue === n) {
        let q = delta;
        for (let k = base; ; k += base) {
          const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) {
            break;
          }
          const qMinusT = q - t;
          const baseMinusT = base - t;
          output.push(
            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
          );
          q = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q, 0)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }
    ++delta;
    ++n;
  }
  return output.join("");
};
var toUnicode = function(input2) {
  return mapDomain(input2, function(string) {
    return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
  });
};
var toASCII = function(input2) {
  return mapDomain(input2, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
  });
};
var punycode = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  "version": "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode2,
  "encode": encode2,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6_default = punycode;

// node_modules/markdown-it/lib/presets/default.mjs
var default_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

// node_modules/markdown-it/lib/presets/zero.mjs
var zero_default = {
  options: {
    // Enable HTML tags in source
    html: false,
    // Use '/' to close single tags (<br />)
    xhtmlOut: false,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/presets/commonmark.mjs
var commonmark_default = {
  options: {
    // Enable HTML tags in source
    html: true,
    // Use '/' to close single tags (<br />)
    xhtmlOut: true,
    // Convert '\n' in paragraphs into <br>
    breaks: false,
    // CSS language prefix for fenced blocks
    langPrefix: "language-",
    // autoconvert URL-like texts to links
    linkify: false,
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '' for Russian, '' for German,
    // and ['\xA0', '\xA0', '\xA0', '\xA0'] for French (including nbsp).
    quotes: "",
    /*  */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    // Internal protection, recursion limit
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};

// node_modules/markdown-it/lib/index.mjs
var config = {
  default: default_default,
  zero: zero_default,
  commonmark: commonmark_default
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  const str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return encode_default(format(parsed));
}
function normalizeLinkText(url) {
  const parsed = parse_default(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode_es6_default.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return decode_default(format(parsed), decode_default.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new parser_inline_default();
  this.block = new parser_block_default();
  this.core = new parser_core_default();
  this.renderer = new renderer_default();
  this.linkify = new linkify_it_default();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils_exports2;
  this.helpers = assign({}, helpers_exports);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  const self = this;
  if (isString(presets)) {
    const presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
  let result = [];
  if (!Array.isArray(list2)) {
    list2 = [list2];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list2, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list2, true));
  const missed = list2.filter(function(name) {
    return result.indexOf(name) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  const args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  const state2 = new this.core.State(src, this, env);
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  const state2 = new this.core.State(src, this, env);
  state2.inlineMode = true;
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib_default = MarkdownIt;

// node_modules/@a2ui/lit/dist/src/0.8/ui/directives/sanitizer.js
function escapeNodeText(str) {
  const frag = document.createElement("div");
  render(html`${str}`, frag);
  return frag.innerHTML.replaceAll(/<!--([^-]*)-->/gim, "");
}

// node_modules/@a2ui/lit/dist/src/0.8/ui/directives/markdown.js
var _markdownIt, _lastValue, _lastTagClassMap, _originalClassMap, _MarkdownDirective_instances, applyTagClassMap_fn, unapplyTagClassMap_fn;
var MarkdownDirective = class extends Directive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _MarkdownDirective_instances);
    __privateAdd(this, _markdownIt, lib_default({
      highlight: (str, lang) => {
        switch (lang) {
          case "html": {
            const iframe2 = document.createElement("iframe");
            iframe2.classList.add("html-view");
            iframe2.srcdoc = str;
            iframe2.sandbox = "";
            return iframe2.innerHTML;
          }
          default:
            return escapeNodeText(str);
        }
      }
    }));
    __privateAdd(this, _lastValue, null);
    __privateAdd(this, _lastTagClassMap, null);
    __privateAdd(this, _originalClassMap, /* @__PURE__ */ new Map());
  }
  update(_part, [value, tagClassMap]) {
    if (__privateGet(this, _lastValue) === value && JSON.stringify(tagClassMap) === __privateGet(this, _lastTagClassMap)) {
      return noChange;
    }
    __privateSet(this, _lastValue, value);
    __privateSet(this, _lastTagClassMap, JSON.stringify(tagClassMap));
    return this.render(value, tagClassMap);
  }
  /**
   * Renders the markdown string to HTML using MarkdownIt.
   *
   * Note: MarkdownIt doesn't enable HTML in its output, so we render the
   * value directly without further sanitization.
   * @see https://github.com/markdown-it/markdown-it/blob/master/docs/security.md
   */
  render(value, tagClassMap) {
    if (tagClassMap) {
      __privateMethod(this, _MarkdownDirective_instances, applyTagClassMap_fn).call(this, tagClassMap);
    }
    const htmlString = __privateGet(this, _markdownIt).render(value);
    __privateMethod(this, _MarkdownDirective_instances, unapplyTagClassMap_fn).call(this);
    return unsafeHTML(htmlString);
  }
};
_markdownIt = new WeakMap();
_lastValue = new WeakMap();
_lastTagClassMap = new WeakMap();
_originalClassMap = new WeakMap();
_MarkdownDirective_instances = new WeakSet();
applyTagClassMap_fn = function(tagClassMap) {
  Object.entries(tagClassMap).forEach(([tag]) => {
    let tokenName;
    switch (tag) {
      case "p":
        tokenName = "paragraph";
        break;
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        tokenName = "heading";
        break;
      case "ul":
        tokenName = "bullet_list";
        break;
      case "ol":
        tokenName = "ordered_list";
        break;
      case "li":
        tokenName = "list_item";
        break;
      case "a":
        tokenName = "link";
        break;
      case "strong":
        tokenName = "strong";
        break;
      case "em":
        tokenName = "em";
        break;
    }
    if (!tokenName) {
      return;
    }
    const key = `${tokenName}_open`;
    __privateGet(this, _markdownIt).renderer.rules[key] = (tokens, idx, options, _env, self) => {
      const token = tokens[idx];
      const tokenClasses = tagClassMap[token.tag] ?? [];
      for (const clazz of tokenClasses) {
        token.attrJoin("class", clazz);
      }
      return self.renderToken(tokens, idx, options);
    };
  });
};
unapplyTagClassMap_fn = function() {
  for (const [key] of __privateGet(this, _originalClassMap)) {
    delete __privateGet(this, _markdownIt).renderer.rules[key];
  }
  __privateGet(this, _originalClassMap).clear();
};
var markdown = directive(MarkdownDirective);
var markdownItStandalone = lib_default();

// node_modules/@a2ui/lit/dist/src/0.8/ui/text.js
var __esDecorate19 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers19 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Text = (() => {
  var _text_accessor_storage, _usageHint_accessor_storage, __this_instances, renderText_fn, areHintedStyles_fn, getAdditionalStyles_fn, _a3;
  let _classDecorators = [customElement("a2ui-text")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _text_decorators;
  let _text_initializers = [];
  let _text_extraInitializers = [];
  let _usageHint_decorators;
  let _usageHint_initializers = [];
  let _usageHint_extraInitializers = [];
  var Text2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _text_accessor_storage, __runInitializers19(this, _text_initializers, null));
      __privateAdd(this, _usageHint_accessor_storage, (__runInitializers19(this, _text_extraInitializers), __runInitializers19(this, _usageHint_initializers, null)));
      __runInitializers19(this, _usageHint_extraInitializers);
    }
    get text() {
      return __privateGet(this, _text_accessor_storage);
    }
    set text(value) {
      __privateSet(this, _text_accessor_storage, value);
    }
    get usageHint() {
      return __privateGet(this, _usageHint_accessor_storage);
    }
    set usageHint(value) {
      __privateSet(this, _usageHint_accessor_storage, value);
    }
    render() {
      var _a4;
      const classes = styles_exports.merge(this.theme.components.Text.all, this.usageHint ? this.theme.components.Text[this.usageHint] : {});
      return html`<section
      class=${classMap(classes)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Text) ? styleMap(__privateMethod(this, __this_instances, getAdditionalStyles_fn).call(this)) : nothing}
    >
      ${__privateMethod(this, __this_instances, renderText_fn).call(this)}
    </section>`;
    }
  }, _text_accessor_storage = new WeakMap(), _usageHint_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderText_fn = function() {
    let textValue = null;
    if (this.text && typeof this.text === "object") {
      if ("literalString" in this.text && this.text.literalString) {
        textValue = this.text.literalString;
      } else if ("literal" in this.text && this.text.literal !== void 0) {
        textValue = this.text.literal;
      } else if (this.text && "path" in this.text && this.text.path) {
        if (!this.processor || !this.component) {
          return html`(no model)`;
        }
        const value = this.processor.getData(this.component, this.text.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (value !== null && value !== void 0) {
          textValue = value.toString();
        }
      }
    }
    if (textValue === null || textValue === void 0) {
      return html`(empty)`;
    }
    let markdownText = textValue;
    switch (this.usageHint) {
      case "h1":
        markdownText = `# ${markdownText}`;
        break;
      case "h2":
        markdownText = `## ${markdownText}`;
        break;
      case "h3":
        markdownText = `### ${markdownText}`;
        break;
      case "h4":
        markdownText = `#### ${markdownText}`;
        break;
      case "h5":
        markdownText = `##### ${markdownText}`;
        break;
      case "caption":
        markdownText = `*${markdownText}*`;
        break;
      default:
        break;
    }
    return html`${markdown(markdownText, styles_exports.appendToAll(this.theme.markdown, ["ol", "ul", "li"], {}))}`;
  }, areHintedStyles_fn = function(styles) {
    if (typeof styles !== "object")
      return false;
    if (Array.isArray(styles))
      return false;
    if (!styles)
      return false;
    const expected = ["h1", "h2", "h3", "h4", "h5", "h6", "caption", "body"];
    return expected.every((v) => v in styles);
  }, getAdditionalStyles_fn = function() {
    var _a4;
    let additionalStyles = {};
    const styles = (_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Text;
    if (!styles)
      return additionalStyles;
    if (__privateMethod(this, __this_instances, areHintedStyles_fn).call(this, styles)) {
      const hint = this.usageHint ?? "body";
      additionalStyles = styles[hint];
    } else {
      additionalStyles = styles;
    }
    return additionalStyles;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _text_decorators = [property()];
    _usageHint_decorators = [property({ reflect: true, attribute: "usage-hint" })];
    __esDecorate19(_a3, null, _text_decorators, { kind: "accessor", name: "text", static: false, private: false, access: { has: (obj) => "text" in obj, get: (obj) => obj.text, set: (obj, value) => {
      obj.text = value;
    } }, metadata: _metadata }, _text_initializers, _text_extraInitializers);
    __esDecorate19(_a3, null, _usageHint_decorators, { kind: "accessor", name: "usageHint", static: false, private: false, access: { has: (obj) => "usageHint" in obj, get: (obj) => obj.usageHint, set: (obj, value) => {
      obj.usageHint = value;
    } }, metadata: _metadata }, _usageHint_initializers, _usageHint_extraInitializers);
    __esDecorate19(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Text2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      :host {
        display: block;
        flex: var(--weight);
      }

      h1,
      h2,
      h3,
      h4,
      h5 {
        line-height: inherit;
        font: inherit;
      }
    `
  ], __runInitializers19(_classThis, _classExtraInitializers), _a3);
  return Text2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/video.js
var __esDecorate20 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers20 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var Video = (() => {
  var _url_accessor_storage, __this_instances, renderVideo_fn, _a3;
  let _classDecorators = [customElement("a2ui-video")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = Root;
  let _url_decorators;
  let _url_initializers = [];
  let _url_extraInitializers = [];
  var Video2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, __this_instances);
      __privateAdd(this, _url_accessor_storage, __runInitializers20(this, _url_initializers, null));
      __runInitializers20(this, _url_extraInitializers);
    }
    get url() {
      return __privateGet(this, _url_accessor_storage);
    }
    set url(value) {
      __privateSet(this, _url_accessor_storage, value);
    }
    render() {
      var _a4, _b2;
      return html`<section
      class=${classMap(this.theme.components.Video)}
      style=${((_a4 = this.theme.additionalStyles) == null ? void 0 : _a4.Video) ? styleMap((_b2 = this.theme.additionalStyles) == null ? void 0 : _b2.Video) : nothing}
    >
      ${__privateMethod(this, __this_instances, renderVideo_fn).call(this)}
    </section>`;
    }
  }, _url_accessor_storage = new WeakMap(), __this_instances = new WeakSet(), renderVideo_fn = function() {
    if (!this.url) {
      return nothing;
    }
    if (this.url && typeof this.url === "object") {
      if ("literalString" in this.url) {
        return html`<video controls src=${this.url.literalString} />`;
      } else if ("literal" in this.url) {
        return html`<video controls src=${this.url.literal} />`;
      } else if (this.url && "path" in this.url && this.url.path) {
        if (!this.processor || !this.component) {
          return html`(no processor)`;
        }
        const videoUrl = this.processor.getData(this.component, this.url.path, this.surfaceId ?? A2uiMessageProcessor.DEFAULT_SURFACE_ID);
        if (!videoUrl) {
          return html`Invalid video URL`;
        }
        if (typeof videoUrl !== "string") {
          return html`Invalid video URL`;
        }
        return html`<video controls src=${videoUrl} />`;
      }
    }
    return html`(empty)`;
  }, _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _url_decorators = [property()];
    __esDecorate20(_a3, null, _url_decorators, { kind: "accessor", name: "url", static: false, private: false, access: { has: (obj) => "url" in obj, get: (obj) => obj.url, set: (obj, value) => {
      obj.url = value;
    } }, metadata: _metadata }, _url_initializers, _url_extraInitializers);
    __esDecorate20(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    Video2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a3.styles = [
    structuralStyles2,
    css`
      * {
        box-sizing: border-box;
      }

      :host {
        display: block;
        flex: var(--weight);
        min-height: 0;
        overflow: auto;
      }

      video {
        display: block;
        width: 100%;
      }
    `
  ], __runInitializers20(_classThis, _classExtraInitializers), _a3);
  return Video2 = _classThis;
})();

// node_modules/@a2ui/lit/dist/src/0.8/ui/custom-components/index.js
function registerCustomComponents() {
}

// node_modules/@a2ui/lit/dist/src/0.8/ui/ui.js
function instanceOf(tagName) {
  const ctor = customElements.get(tagName);
  if (!ctor) {
    console.warn("No element definition for", tagName);
    return;
  }
  return new ctor();
}

// node_modules/@copilotkit/a2ui-renderer/dist/styles/global.js
var globalStyles = `
  :host {
    --n-100: #ffffff;
    --n-99: #fcfcfc;
    --n-98: #f9f9f9;
    --n-95: #f1f1f1;
    --n-90: #e2e2e2;
    --n-80: #c6c6c6;
    --n-70: #ababab;
    --n-60: #919191;
    --n-50: #777777;
    --n-40: #5e5e5e;
    --n-35: #525252;
    --n-30: #474747;
    --n-25: #3b3b3b;
    --n-20: #303030;
    --n-15: #262626;
    --n-10: #1b1b1b;
    --n-5: #111111;
    --n-0: #000000;

    --p-100: var(--a2ui-card-bg, #ffffff);
    --p-99: #fffbff;
    --p-98: #fcf8ff;
    --p-95: #f2efff;
    --p-90: #e1e0ff;
    --p-80: #c0c1ff;
    --p-70: #a0a3ff;
    --p-60: #8487ea;
    --p-50: #6a6dcd;
    --p-40: #5154b3;
    --p-35: #4447a6;
    --p-30: #383b99;
    --p-25: #2c2e8d;
    --p-20: #202182;
    --p-15: #131178;
    --p-10: #06006c;
    --p-5: #03004d;
    --p-0: #000000;

    --s-100: #ffffff;
    --s-99: #fffbff;
    --s-98: #fcf8ff;
    --s-95: #f2efff;
    --s-90: #e2e0f9;
    --s-80: #c6c4dd;
    --s-70: #aaa9c1;
    --s-60: #8f8fa5;
    --s-50: #75758b;
    --s-40: #5d5c72;
    --s-35: #515165;
    --s-30: #454559;
    --s-25: #393a4d;
    --s-20: #2e2f42;
    --s-15: #242437;
    --s-10: #191a2c;
    --s-5: #0f0f21;
    --s-0: #000000;

    --t-100: #ffffff;
    --t-99: #fffbff;
    --t-98: #fff8f9;
    --t-95: #ffecf4;
    --t-90: #ffd8ec;
    --t-80: #e9b9d3;
    --t-70: #cc9eb8;
    --t-60: #af849d;
    --t-50: #946b83;
    --t-40: #79536a;
    --t-35: #6c475d;
    --t-30: #5f3c51;
    --t-25: #523146;
    --t-20: #46263a;
    --t-15: #3a1b2f;
    --t-10: #2e1125;
    --t-5: #22071a;
    --t-0: #000000;

    --nv-100: #ffffff;
    --nv-99: #fffbff;
    --nv-98: #fcf8ff;
    --nv-95: #f2effa;
    --nv-90: #e4e1ec;
    --nv-80: #c8c5d0;
    --nv-70: #acaab4;
    --nv-60: #918f9a;
    --nv-50: #777680;
    --nv-40: #5e5d67;
    --nv-35: #52515b;
    --nv-30: #46464f;
    --nv-25: #3b3b43;
    --nv-20: #303038;
    --nv-15: #25252d;
    --nv-10: #1b1b23;
    --nv-5: #101018;
    --nv-0: #000000;

    --e-100: #ffffff;
    --e-99: #fffbff;
    --e-98: #fff8f7;
    --e-95: #ffedea;
    --e-90: #ffdad6;
    --e-80: #ffb4ab;
    --e-70: #ff897d;
    --e-60: #ff5449;
    --e-50: #de3730;
    --e-40: #ba1a1a;
    --e-35: #a80710;
    --e-30: #93000a;
    --e-25: #7e0007;
    --e-20: #690005;
    --e-15: #540003;
    --e-10: #410002;
    --e-5: #2d0001;
    --e-0: #000000;

    --primary: #137fec;
    --text-color: #fff;
    --background-light: #f6f7f8;
    --background-dark: #101922;
    --border-color: oklch(from var(--background-light) l c h / calc(alpha * 0.15));
    --elevated-background-light: oklch(
      from var(--background-light) l c h / calc(alpha * 0.05)
    );
    --bb-grid-size: 4px;
    --bb-grid-size-2: calc(var(--bb-grid-size) * 2);
    --bb-grid-size-3: calc(var(--bb-grid-size) * 3);
    --bb-grid-size-4: calc(var(--bb-grid-size) * 4);
    --bb-grid-size-5: calc(var(--bb-grid-size) * 5);
    --bb-grid-size-6: calc(var(--bb-grid-size) * 6);
    --bb-grid-size-7: calc(var(--bb-grid-size) * 7);
    --bb-grid-size-8: calc(var(--bb-grid-size) * 8);
    --bb-grid-size-9: calc(var(--bb-grid-size) * 9);
    --bb-grid-size-10: calc(var(--bb-grid-size) * 10);
    --bb-grid-size-11: calc(var(--bb-grid-size) * 11);
    --bb-grid-size-12: calc(var(--bb-grid-size) * 12);
    --bb-grid-size-13: calc(var(--bb-grid-size) * 13);
    --bb-grid-size-14: calc(var(--bb-grid-size) * 14);
    --bb-grid-size-15: calc(var(--bb-grid-size) * 15);
    --bb-grid-size-16: calc(var(--bb-grid-size) * 16);

    font-family: "Google Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  }
`;

// node_modules/@copilotkit/a2ui-renderer/dist/themed-surface.js
var __esDecorate21 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};
var __runInitializers21 = function(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};
var ThemedA2UISurface = (() => {
  var _theme_accessor_storage, _surfaceId_accessor_storage, _surface_accessor_storage, _processor_accessor_storage, _onAction_accessor_storage, _handleAction, _a3;
  let _classDecorators = [customElement("themed-a2ui-surface")];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _classSuper = SignalWatcher(LitElement);
  let _theme_decorators;
  let _theme_initializers = [];
  let _theme_extraInitializers = [];
  let _surfaceId_decorators;
  let _surfaceId_initializers = [];
  let _surfaceId_extraInitializers = [];
  let _surface_decorators;
  let _surface_initializers = [];
  let _surface_extraInitializers = [];
  let _processor_decorators;
  let _processor_initializers = [];
  let _processor_extraInitializers = [];
  let _onAction_decorators;
  let _onAction_initializers = [];
  let _onAction_extraInitializers = [];
  var ThemedA2UISurface2 = (_a3 = class extends _classSuper {
    constructor() {
      super(...arguments);
      __privateAdd(this, _theme_accessor_storage, __runInitializers21(this, _theme_initializers, void 0));
      __privateAdd(this, _surfaceId_accessor_storage, (__runInitializers21(this, _theme_extraInitializers), __runInitializers21(this, _surfaceId_initializers, null)));
      __privateAdd(this, _surface_accessor_storage, (__runInitializers21(this, _surfaceId_extraInitializers), __runInitializers21(this, _surface_initializers, null)));
      __privateAdd(this, _processor_accessor_storage, (__runInitializers21(this, _surface_extraInitializers), __runInitializers21(this, _processor_initializers, null)));
      __privateAdd(this, _onAction_accessor_storage, (__runInitializers21(this, _processor_extraInitializers), __runInitializers21(this, _onAction_initializers, null)));
      __privateAdd(this, _handleAction, (__runInitializers21(this, _onAction_extraInitializers), (event) => {
        var _a4;
        (_a4 = this.onAction) == null ? void 0 : _a4.call(this, event, {
          surfaceId: this.surfaceId,
          surface: this.surface,
          processor: this.processor
        });
      }));
    }
    get theme() {
      return __privateGet(this, _theme_accessor_storage);
    }
    set theme(value) {
      __privateSet(this, _theme_accessor_storage, value);
    }
    get surfaceId() {
      return __privateGet(this, _surfaceId_accessor_storage);
    }
    set surfaceId(value) {
      __privateSet(this, _surfaceId_accessor_storage, value);
    }
    get surface() {
      return __privateGet(this, _surface_accessor_storage);
    }
    set surface(value) {
      __privateSet(this, _surface_accessor_storage, value);
    }
    get processor() {
      return __privateGet(this, _processor_accessor_storage);
    }
    set processor(value) {
      __privateSet(this, _processor_accessor_storage, value);
    }
    get onAction() {
      return __privateGet(this, _onAction_accessor_storage);
    }
    set onAction(value) {
      __privateSet(this, _onAction_accessor_storage, value);
    }
    render() {
      return html`<style>
        ${globalStyles}
      </style>
      <a2ui-surface
        @a2uiaction=${__privateGet(this, _handleAction)}
        .surfaceId=${this.surfaceId}
        .surface=${this.surface}
        .processor=${this.processor}
      ></a2ui-surface>`;
    }
  }, _theme_accessor_storage = new WeakMap(), _surfaceId_accessor_storage = new WeakMap(), _surface_accessor_storage = new WeakMap(), _processor_accessor_storage = new WeakMap(), _onAction_accessor_storage = new WeakMap(), _handleAction = new WeakMap(), _classThis = _a3, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
    _theme_decorators = [provide({ context: theme_exports.themeContext }), property({ attribute: false })];
    _surfaceId_decorators = [property({ attribute: false })];
    _surface_decorators = [property({ attribute: false })];
    _processor_decorators = [property({ attribute: false })];
    _onAction_decorators = [property({ attribute: false })];
    __esDecorate21(_a3, null, _theme_decorators, { kind: "accessor", name: "theme", static: false, private: false, access: { has: (obj) => "theme" in obj, get: (obj) => obj.theme, set: (obj, value) => {
      obj.theme = value;
    } }, metadata: _metadata }, _theme_initializers, _theme_extraInitializers);
    __esDecorate21(_a3, null, _surfaceId_decorators, { kind: "accessor", name: "surfaceId", static: false, private: false, access: { has: (obj) => "surfaceId" in obj, get: (obj) => obj.surfaceId, set: (obj, value) => {
      obj.surfaceId = value;
    } }, metadata: _metadata }, _surfaceId_initializers, _surfaceId_extraInitializers);
    __esDecorate21(_a3, null, _surface_decorators, { kind: "accessor", name: "surface", static: false, private: false, access: { has: (obj) => "surface" in obj, get: (obj) => obj.surface, set: (obj, value) => {
      obj.surface = value;
    } }, metadata: _metadata }, _surface_initializers, _surface_extraInitializers);
    __esDecorate21(_a3, null, _processor_decorators, { kind: "accessor", name: "processor", static: false, private: false, access: { has: (obj) => "processor" in obj, get: (obj) => obj.processor, set: (obj, value) => {
      obj.processor = value;
    } }, metadata: _metadata }, _processor_initializers, _processor_extraInitializers);
    __esDecorate21(_a3, null, _onAction_decorators, { kind: "accessor", name: "onAction", static: false, private: false, access: { has: (obj) => "onAction" in obj, get: (obj) => obj.onAction, set: (obj, value) => {
      obj.onAction = value;
    } }, metadata: _metadata }, _onAction_initializers, _onAction_extraInitializers);
    __esDecorate21(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
    ThemedA2UISurface2 = _classThis = _classDescriptor.value;
    if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
    __runInitializers21(_classThis, _classExtraInitializers);
  })(), _a3);
  return ThemedA2UISurface2 = _classThis;
})();

// node_modules/@copilotkit/a2ui-renderer/dist/A2UIMessageRenderer.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);
function createA2UIMessageRenderer(options) {
  const { theme: theme2 } = options;
  return {
    activityType: "a2ui-surface",
    content: external_exports.any(),
    render: ({ content, agent }) => {
      const [operations, setOperations] = (0, import_react.useState)([]);
      const lastSignatureRef = (0, import_react.useRef)(null);
      const processorsRef = (0, import_react.useRef)(/* @__PURE__ */ new Map());
      const { copilotkit } = useCopilotKit();
      const actionLogger = (0, import_react.useCallback)(async (event, context) => {
        var _a3;
        if (!agent) {
          return;
        }
        const resolvedContext = {};
        const processorInstance = context.processor;
        const surfaceKey = context.surfaceId ?? __exports.Data.A2uiMessageProcessor.DEFAULT_SURFACE_ID;
        const actionContext = (_a3 = event.detail.action) == null ? void 0 : _a3.context;
        if (Array.isArray(actionContext) && actionContext.length > 0) {
          for (const item of actionContext) {
            if (!(item == null ? void 0 : item.key)) {
              continue;
            }
            const valueDescriptor = item.value;
            if (!valueDescriptor) {
              continue;
            }
            if (typeof valueDescriptor.literalBoolean === "boolean" || typeof valueDescriptor.literalNumber === "number" || typeof valueDescriptor.literalString === "string") {
              resolvedContext[item.key] = valueDescriptor.literalBoolean ?? valueDescriptor.literalNumber ?? valueDescriptor.literalString;
              continue;
            }
            const path = valueDescriptor.path;
            if (path && processorInstance && typeof path === "string") {
              const resolvedPath = processorInstance.resolvePath(path, event.detail.dataContextPath);
              const value = processorInstance.getData(event.detail.sourceComponent, resolvedPath, surfaceKey);
              if (value !== void 0) {
                resolvedContext[item.key] = value;
              }
            }
          }
        }
        const userAction = {
          userAction: {
            name: event.detail.action.name ?? "",
            surfaceId: context.surfaceId ?? surfaceKey,
            sourceComponentId: event.detail.sourceComponentId,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            context: {
              ...resolvedContext,
              surfaceId: context.surfaceId ?? surfaceKey
            }
          }
        };
        try {
          console.info("[A2UI] Action dispatched", userAction.userAction);
          copilotkit.setProperties({
            ...copilotkit.properties ?? {},
            a2uiAction: userAction
          });
          await copilotkit.runAgent({ agent });
        } finally {
          if (copilotkit.properties) {
            const { a2uiAction, ...rest } = copilotkit.properties;
            copilotkit.setProperties(rest);
          }
        }
      }, [agent, copilotkit]);
      (0, import_react.useEffect)(() => {
        if (!content || !Array.isArray(content.operations)) {
          processorsRef.current.forEach((processor) => processor.clearSurfaces());
          processorsRef.current.clear();
          lastSignatureRef.current = null;
          setOperations([]);
          return;
        }
        const processors = processorsRef.current;
        const incoming = content.operations;
        const signature = stringifyOperations(incoming);
        if (signature && signature === lastSignatureRef.current) {
          return;
        }
        const groupedOperations = /* @__PURE__ */ new Map();
        for (const operation of incoming) {
          const surfaceId = getOperationSurfaceId(operation) ?? __exports.Data.A2uiMessageProcessor.DEFAULT_SURFACE_ID;
          if (!groupedOperations.has(surfaceId)) {
            groupedOperations.set(surfaceId, []);
          }
          groupedOperations.get(surfaceId).push(operation);
        }
        groupedOperations.forEach((operationsForSurfaceId, surfaceId) => {
          let processor = processors.get(surfaceId);
          if (!processor) {
            processor = __exports.Data.createSignalA2uiMessageProcessor();
            processors.set(surfaceId, processor);
          }
          try {
            processor.processMessages(operationsForSurfaceId);
          } catch (error2) {
            processors.delete(surfaceId);
          }
        });
        const emptyProcessors = [];
        processors.forEach((processor, surfaceId) => {
          if (processor.getSurfaces().size === 0) {
            emptyProcessors.push(surfaceId);
          }
        });
        if (emptyProcessors.length > 0) {
          for (const surfaceId of emptyProcessors) {
            processors.delete(surfaceId);
          }
        }
        lastSignatureRef.current = signature;
        setOperations(incoming);
      }, [content]);
      const surfaceEntries = (0, import_react.useMemo)(() => {
        const entries = [];
        processorsRef.current.forEach((processor) => {
          processor.getSurfaces().forEach((surface, surfaceId) => {
            const typedSurface = surface;
            if (typedSurface == null ? void 0 : typedSurface.componentTree) {
              entries.push({ id: surfaceId, surface: typedSurface, processor });
            }
          });
        });
        return entries;
      }, [operations]);
      if (!surfaceEntries.length) {
        return null;
      }
      return (0, import_jsx_runtime.jsx)("div", { className: "flex min-h-0 flex-1 flex-col gap-6 overflow-auto py-6", children: surfaceEntries.map(({ id, surface, processor }) => (0, import_jsx_runtime.jsx)(SurfaceHost, { actionLogger, processor, surface, surfaceId: id, theme: theme2 }, id)) });
    }
  };
}
function getOperationSurfaceId(operation) {
  var _a3, _b2, _c, _d;
  if (!operation || typeof operation !== "object") {
    return null;
  }
  if (typeof operation.surfaceId === "string") {
    return operation.surfaceId;
  }
  return ((_a3 = operation == null ? void 0 : operation.beginRendering) == null ? void 0 : _a3.surfaceId) ?? ((_b2 = operation == null ? void 0 : operation.surfaceUpdate) == null ? void 0 : _b2.surfaceId) ?? ((_c = operation == null ? void 0 : operation.dataModelUpdate) == null ? void 0 : _c.surfaceId) ?? ((_d = operation == null ? void 0 : operation.deleteSurface) == null ? void 0 : _d.surfaceId) ?? null;
}
function stringifyOperations(ops) {
  try {
    return JSON.stringify(ops);
  } catch (error2) {
    return null;
  }
}
function SurfaceHost({ actionLogger, processor, surface, surfaceId, theme: theme2 }) {
  const elementRef = (0, import_react.useRef)(null);
  (0, import_react.useEffect)(() => {
    const element = elementRef.current;
    if (!element) {
      return;
    }
    element.processor = processor;
    element.surfaceId = surfaceId;
    element.surface = surface;
    element.onAction = actionLogger;
    element.theme = theme2;
    return () => {
      if (elementRef.current === element) {
        element.onAction = null;
      }
    };
  }, [processor, surface, surfaceId, actionLogger, theme2]);
  return (0, import_jsx_runtime.jsx)("div", { className: "flex w-full flex-none overflow-hidden rounded-lg bg-white/5 p-4", children: import_react.default.createElement("themed-a2ui-surface", {
    ref: elementRef,
    className: "flex flex-1",
    style: { height: "100%", overflow: "hidden" },
    "data-surface-id": surfaceId
  }) });
}

// node_modules/@copilotkit/a2ui-renderer/dist/A2UIViewer.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@copilotkit/a2ui-renderer/dist/theme/viewer-theme.js
var a = {
  "typography-f-sf": true,
  "typography-fs-n": true,
  "typography-w-500": true,
  "layout-as-n": true,
  "layout-dis-iflx": true,
  "layout-al-c": true
};
var audio = {
  "layout-w-100": true
};
var body = {
  "typography-f-s": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-mt-0": true,
  "layout-mb-2": true,
  "typography-sz-bm": true,
  "color-c-n10": true
};
var button = {
  "typography-f-sf": true,
  "typography-fs-n": true,
  "typography-w-500": true,
  "layout-pt-3": true,
  "layout-pb-3": true,
  "layout-pl-5": true,
  "layout-pr-5": true,
  "layout-mb-1": true,
  "border-br-16": true,
  "border-bw-0": true,
  "border-c-n70": true,
  "border-bs-s": true,
  "color-bgc-s30": true,
  "color-c-n100": true,
  "behavior-ho-80": true
};
var heading2 = {
  "typography-f-sf": true,
  "typography-fs-n": true,
  "typography-w-500": true,
  "layout-mt-0": true,
  "layout-mb-2": true,
  "color-c-n10": true
};
var h1 = {
  ...heading2,
  "typography-sz-tl": true
};
var h2 = {
  ...heading2,
  "typography-sz-tm": true
};
var h3 = {
  ...heading2,
  "typography-sz-ts": true
};
var iframe = {
  "behavior-sw-n": true
};
var input = {
  "typography-f-sf": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-pl-4": true,
  "layout-pr-4": true,
  "layout-pt-2": true,
  "layout-pb-2": true,
  "border-br-6": true,
  "border-bw-1": true,
  "color-bc-s70": true,
  "border-bs-s": true,
  "layout-as-n": true,
  "color-c-n10": true
};
var p = {
  "typography-f-s": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-m-0": true,
  "typography-sz-bm": true,
  "layout-as-n": true,
  "color-c-n10": true
};
var orderedList = {
  "typography-f-s": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-m-0": true,
  "typography-sz-bm": true,
  "layout-as-n": true
};
var unorderedList = {
  "typography-f-s": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-m-0": true,
  "typography-sz-bm": true,
  "layout-as-n": true
};
var listItem = {
  "typography-f-s": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "layout-m-0": true,
  "typography-sz-bm": true,
  "layout-as-n": true
};
var pre = {
  "typography-f-c": true,
  "typography-fs-n": true,
  "typography-w-400": true,
  "typography-sz-bm": true,
  "typography-ws-p": true,
  "layout-as-n": true
};
var textarea = {
  ...input,
  "layout-r-none": true,
  "layout-fs-c": true
};
var video = {
  "layout-el-cv": true
};
var aLight = __exports.Styles.merge(a, { "color-c-n5": true });
var inputLight = __exports.Styles.merge(input, { "color-c-n5": true });
var textareaLight = __exports.Styles.merge(textarea, { "color-c-n5": true });
var buttonLight = __exports.Styles.merge(button, { "color-c-n100": true });
var h1Light = __exports.Styles.merge(h1, { "color-c-n5": true });
var h2Light = __exports.Styles.merge(h2, { "color-c-n5": true });
var h3Light = __exports.Styles.merge(h3, { "color-c-n5": true });
var bodyLight = __exports.Styles.merge(body, { "color-c-n5": true });
var pLight = __exports.Styles.merge(p, { "color-c-n35": true });
var preLight = __exports.Styles.merge(pre, { "color-c-n35": true });
var orderedListLight = __exports.Styles.merge(orderedList, {
  "color-c-n35": true
});
var unorderedListLight = __exports.Styles.merge(unorderedList, {
  "color-c-n35": true
});
var listItemLight = __exports.Styles.merge(listItem, {
  "color-c-n35": true
});
var theme = {
  additionalStyles: {
    Button: {
      "--n-35": "var(--n-100)"
    },
    Card: {
      padding: "32px"
    }
  },
  components: {
    AudioPlayer: {},
    Button: {
      "layout-pt-2": true,
      "layout-pb-2": true,
      "layout-pl-3": true,
      "layout-pr-3": true,
      "border-br-12": true,
      "border-bw-0": true,
      "border-bs-s": true,
      "color-bgc-p30": true,
      "color-c-n100": true,
      "behavior-ho-70": true
    },
    Card: { "border-br-9": true, "color-bgc-p100": true },
    CheckBox: {
      element: {
        "layout-m-0": true,
        "layout-mr-2": true,
        "layout-p-2": true,
        "border-br-12": true,
        "border-bw-1": true,
        "border-bs-s": true,
        "color-bgc-p100": true,
        "color-bc-p60": true,
        "color-c-n30": true,
        "color-c-p30": true
      },
      label: {
        "color-c-p30": true,
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-flx-1": true,
        "typography-sz-ll": true
      },
      container: {
        "layout-dsp-iflex": true,
        "layout-al-c": true
      }
    },
    Column: {
      "layout-g-2": true
    },
    DateTimeInput: {
      container: {},
      label: {},
      element: {
        "layout-pt-2": true,
        "layout-pb-2": true,
        "layout-pl-3": true,
        "layout-pr-3": true,
        "border-br-12": true,
        "border-bw-1": true,
        "border-bs-s": true,
        "color-bgc-p100": true,
        "color-bc-p60": true,
        "color-c-n30": true,
        "color-c-p30": true
      }
    },
    Divider: {},
    Image: {
      all: {
        "border-br-5": true,
        "layout-el-cv": true,
        "layout-w-100": true,
        "layout-h-100": true
      },
      avatar: { "is-avatar": true },
      header: {},
      icon: {},
      largeFeature: {},
      mediumFeature: {},
      smallFeature: {}
    },
    Icon: {},
    List: {
      "layout-g-4": true,
      "layout-p-2": true
    },
    Modal: {
      backdrop: { "color-bbgc-p60_20": true },
      element: {
        "border-br-2": true,
        "color-bgc-p100": true,
        "layout-p-4": true,
        "border-bw-1": true,
        "border-bs-s": true,
        "color-bc-p80": true
      }
    },
    MultipleChoice: {
      container: {},
      label: {},
      element: {}
    },
    Row: {
      "layout-g-4": true
    },
    Slider: {
      container: {},
      label: {},
      element: {}
    },
    Tabs: {
      container: {},
      controls: { all: {}, selected: {} },
      element: {}
    },
    Text: {
      all: {
        "layout-w-100": true,
        "layout-g-2": true
      },
      h1: {
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-m-0": true,
        "layout-p-0": true,
        "typography-sz-tl": true
      },
      h2: {
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-m-0": true,
        "layout-p-0": true,
        "typography-sz-tm": true
      },
      h3: {
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-m-0": true,
        "layout-p-0": true,
        "typography-sz-ts": true
      },
      h4: {
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-m-0": true,
        "layout-p-0": true,
        "typography-sz-bl": true
      },
      h5: {
        "typography-f-sf": true,
        "typography-v-r": true,
        "typography-w-400": true,
        "layout-m-0": true,
        "layout-p-0": true,
        "typography-sz-bm": true
      },
      body: {},
      caption: {}
    },
    TextField: {
      container: {
        "typography-sz-bm": true,
        "layout-w-100": true,
        "layout-g-2": true,
        "layout-dsp-flexhor": true,
        "layout-al-c": true
      },
      label: {
        "layout-flx-0": true
      },
      element: {
        "typography-sz-bm": true,
        "layout-pt-2": true,
        "layout-pb-2": true,
        "layout-pl-3": true,
        "layout-pr-3": true,
        "border-br-12": true,
        "border-bw-1": true,
        "border-bs-s": true,
        "color-bgc-p100": true,
        "color-bc-p60": true,
        "color-c-n30": true,
        "color-c-p30": true
      }
    },
    Video: {
      "border-br-5": true,
      "layout-el-cv": true
    }
  },
  elements: {
    a: aLight,
    audio,
    body: bodyLight,
    button: buttonLight,
    h1: h1Light,
    h2: h2Light,
    h3: h3Light,
    h4: {},
    h5: {},
    iframe,
    input: inputLight,
    p: pLight,
    pre: preLight,
    textarea: textareaLight,
    video
  },
  markdown: {
    p: [...Object.keys(pLight)],
    h1: [...Object.keys(h1Light)],
    h2: [...Object.keys(h2Light)],
    h3: [...Object.keys(h3Light)],
    h4: [],
    h5: [],
    ul: [...Object.keys(unorderedListLight)],
    ol: [...Object.keys(orderedListLight)],
    li: [...Object.keys(listItemLight)],
    a: [...Object.keys(aLight)],
    strong: [],
    em: []
  }
};

// node_modules/@copilotkit/a2ui-renderer/dist/A2UIViewer.js
function A2UIViewer({ root, components, data, onAction, styles, className }) {
  const elementRef = (0, import_react2.useRef)(null);
  const baseId = (0, import_react2.useId)();
  const surfaceId = (0, import_react2.useMemo)(() => {
    const definitionKey = `${root}-${JSON.stringify(components)}`;
    let hash = 0;
    for (let i = 0; i < definitionKey.length; i++) {
      const char = definitionKey.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return `${baseId}-${hash}`;
  }, [baseId, root, components]);
  const processor = (0, import_react2.useMemo)(() => __exports.Data.createSignalA2uiMessageProcessor(), [surfaceId]);
  const surface = (0, import_react2.useMemo)(() => {
    const messages = [
      { beginRendering: { surfaceId, root, styles: styles ?? {} } },
      { surfaceUpdate: { surfaceId, components } }
    ];
    if (data && Object.keys(data).length > 0) {
      const contents = objectToValueMaps(data);
      if (contents.length > 0) {
        messages.push({ dataModelUpdate: { surfaceId, path: "/", contents } });
      }
    }
    processor.processMessages(messages);
    return processor.getSurfaces().get(surfaceId) ?? null;
  }, [processor, surfaceId, root, components, data, styles]);
  const handleAction = (0, import_react2.useCallback)((event, context) => {
    var _a3, _b2;
    if (!onAction)
      return;
    const resolvedContext = {};
    const processorInstance = context.processor;
    const actionContext = (_a3 = event.detail.action) == null ? void 0 : _a3.context;
    if (Array.isArray(actionContext) && actionContext.length > 0) {
      for (const item of actionContext) {
        if (!(item == null ? void 0 : item.key))
          continue;
        const valueDescriptor = item.value;
        if (!valueDescriptor)
          continue;
        if (typeof valueDescriptor.literalBoolean === "boolean" || typeof valueDescriptor.literalNumber === "number" || typeof valueDescriptor.literalString === "string") {
          resolvedContext[item.key] = valueDescriptor.literalBoolean ?? valueDescriptor.literalNumber ?? valueDescriptor.literalString;
          continue;
        }
        const path = valueDescriptor.path;
        if (path && processorInstance && typeof path === "string") {
          const resolvedPath = processorInstance.resolvePath(path, event.detail.dataContextPath);
          const value = processorInstance.getData(event.detail.sourceComponent, resolvedPath, surfaceId);
          if (value !== void 0) {
            resolvedContext[item.key] = value;
          }
        }
      }
    }
    onAction({
      actionName: ((_b2 = event.detail.action) == null ? void 0 : _b2.name) ?? "",
      sourceComponentId: event.detail.sourceComponentId,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      context: resolvedContext
    });
  }, [onAction, surfaceId]);
  (0, import_react2.useEffect)(() => {
    const element = elementRef.current;
    if (!element)
      return;
    element.processor = processor;
    element.surfaceId = surfaceId;
    element.surface = surface;
    element.onAction = handleAction;
    element.theme = theme;
    return () => {
      if (elementRef.current === element) {
        element.onAction = null;
      }
    };
  }, [processor, surface, surfaceId, handleAction]);
  if (!(surface == null ? void 0 : surface.componentTree)) {
    return (0, import_jsx_runtime2.jsx)("div", { className, style: { padding: 16, color: "#666", fontFamily: "system-ui" }, children: "No content to display" });
  }
  return import_react2.default.createElement("themed-a2ui-surface", {
    ref: elementRef,
    className,
    "data-surface-id": surfaceId
  });
}
function objectToValueMaps(obj) {
  return Object.entries(obj).map(([key, value]) => valueToValueMap(key, value));
}
function valueToValueMap(key, value) {
  if (typeof value === "string") {
    return { key, valueString: value };
  }
  if (typeof value === "number") {
    return { key, valueNumber: value };
  }
  if (typeof value === "boolean") {
    return { key, valueBoolean: value };
  }
  if (value === null || value === void 0) {
    return { key };
  }
  if (Array.isArray(value)) {
    const valueMap = value.map((item, index) => valueToValueMap(String(index), item));
    return { key, valueMap };
  }
  if (typeof value === "object") {
    const valueMap = objectToValueMaps(value);
    return { key, valueMap };
  }
  return { key };
}
export {
  A2UIViewer,
  ThemedA2UISurface,
  createA2UIMessageRenderer,
  globalStyles
};
/*! Bundled license information:

signal-polyfill/dist/index.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
  (**
   * @license
   * Copyright 2024 Bloomberg Finance L.P.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@lit-labs/signals/development/lib/signal-watcher.js:
@lit-labs/signals/development/lib/watch.js:
@lit-labs/signals/development/lib/html-tag.js:
@lit-labs/signals/development/index.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directive-helpers.js:
lit-html/development/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/async-directive.js:
@lit/context/development/lib/decorators/provide.js:
@lit/reactive-element/development/decorators/custom-element.js:
@lit/reactive-element/development/decorators/property.js:
@lit/reactive-element/development/decorators/state.js:
@lit/reactive-element/development/decorators/event-options.js:
@lit/reactive-element/development/decorators/base.js:
@lit/reactive-element/development/decorators/query.js:
@lit/reactive-element/development/decorators/query-all.js:
@lit/reactive-element/development/decorators/query-async.js:
@lit/reactive-element/development/decorators/query-assigned-nodes.js:
lit-html/development/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/context-request-event.js:
@lit/context/development/lib/create-context.js:
@lit/context/development/lib/controllers/context-consumer.js:
@lit/context/development/lib/value-notifier.js:
@lit/context/development/lib/controllers/context-provider.js:
@lit/context/development/lib/context-root.js:
@lit/context/development/index.js:
@lit/reactive-element/development/decorators/query-assigned-elements.js:
lit-html/development/directives/map.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/context/development/lib/decorators/consume.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/development/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@copilotkit_a2ui-renderer.js.map
