import {
  v4_default
} from "./chunk-MNN7MA6Z.js";
import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-ISKIE5KO.js";

// node_modules/partial-json/dist/options.js
var require_options = __commonJS({
  "node_modules/partial-json/dist/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Allow = exports.ALL = exports.COLLECTION = exports.ATOM = exports.SPECIAL = exports.INF = exports._INFINITY = exports.INFINITY = exports.NAN = exports.BOOL = exports.NULL = exports.OBJ = exports.ARR = exports.NUM = exports.STR = void 0;
    exports.STR = 1;
    exports.NUM = 2;
    exports.ARR = 4;
    exports.OBJ = 8;
    exports.NULL = 16;
    exports.BOOL = 32;
    exports.NAN = 64;
    exports.INFINITY = 128;
    exports._INFINITY = 256;
    exports.INF = exports.INFINITY | exports._INFINITY;
    exports.SPECIAL = exports.NULL | exports.BOOL | exports.INF | exports.NAN;
    exports.ATOM = exports.STR | exports.NUM | exports.SPECIAL;
    exports.COLLECTION = exports.ARR | exports.OBJ;
    exports.ALL = exports.ATOM | exports.COLLECTION;
    exports.Allow = { STR: exports.STR, NUM: exports.NUM, ARR: exports.ARR, OBJ: exports.OBJ, NULL: exports.NULL, BOOL: exports.BOOL, NAN: exports.NAN, INFINITY: exports.INFINITY, _INFINITY: exports._INFINITY, INF: exports.INF, SPECIAL: exports.SPECIAL, ATOM: exports.ATOM, COLLECTION: exports.COLLECTION, ALL: exports.ALL };
    exports.default = exports.Allow;
  }
});

// node_modules/partial-json/dist/index.js
var require_dist = __commonJS({
  "node_modules/partial-json/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    }) : (function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Allow = exports.MalformedJSON = exports.PartialJSON = exports.parseJSON = exports.parse = void 0;
    var options_1 = require_options();
    Object.defineProperty(exports, "Allow", { enumerable: true, get: function() {
      return options_1.Allow;
    } });
    __exportStar(require_options(), exports);
    var PartialJSON2 = class extends Error {
    };
    exports.PartialJSON = PartialJSON2;
    var MalformedJSON = class extends Error {
    };
    exports.MalformedJSON = MalformedJSON;
    function parseJSON(jsonString, allowPartial = options_1.Allow.ALL) {
      if (typeof jsonString !== "string") {
        throw new TypeError(`expecting str, got ${typeof jsonString}`);
      }
      if (!jsonString.trim()) {
        throw new Error(`${jsonString} is empty`);
      }
      return _parseJSON(jsonString.trim(), allowPartial);
    }
    exports.parseJSON = parseJSON;
    var _parseJSON = (jsonString, allow) => {
      const length = jsonString.length;
      let index = 0;
      const markPartialJSON = (msg) => {
        throw new PartialJSON2(`${msg} at position ${index}`);
      };
      const throwMalformedError = (msg) => {
        throw new MalformedJSON(`${msg} at position ${index}`);
      };
      const parseAny = () => {
        skipBlank();
        if (index >= length)
          markPartialJSON("Unexpected end of input");
        if (jsonString[index] === '"')
          return parseStr();
        if (jsonString[index] === "{")
          return parseObj();
        if (jsonString[index] === "[")
          return parseArr();
        if (jsonString.substring(index, index + 4) === "null" || options_1.Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
          index += 4;
          return null;
        }
        if (jsonString.substring(index, index + 4) === "true" || options_1.Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
          index += 4;
          return true;
        }
        if (jsonString.substring(index, index + 5) === "false" || options_1.Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
          index += 5;
          return false;
        }
        if (jsonString.substring(index, index + 8) === "Infinity" || options_1.Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
          index += 8;
          return Infinity;
        }
        if (jsonString.substring(index, index + 9) === "-Infinity" || options_1.Allow._INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
          index += 9;
          return -Infinity;
        }
        if (jsonString.substring(index, index + 3) === "NaN" || options_1.Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
          index += 3;
          return NaN;
        }
        return parseNum();
      };
      const parseStr = () => {
        const start = index;
        let escape = false;
        index++;
        while (index < length && (jsonString[index] !== '"' || escape && jsonString[index - 1] === "\\")) {
          escape = jsonString[index] === "\\" ? !escape : false;
          index++;
        }
        if (jsonString.charAt(index) == '"') {
          try {
            return JSON.parse(jsonString.substring(start, ++index - Number(escape)));
          } catch (e) {
            throwMalformedError(String(e));
          }
        } else if (options_1.Allow.STR & allow) {
          try {
            return JSON.parse(jsonString.substring(start, index - Number(escape)) + '"');
          } catch (e) {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
          }
        }
        markPartialJSON("Unterminated string literal");
      };
      const parseObj = () => {
        index++;
        skipBlank();
        const obj = {};
        try {
          while (jsonString[index] !== "}") {
            skipBlank();
            if (index >= length && options_1.Allow.OBJ & allow)
              return obj;
            const key = parseStr();
            skipBlank();
            index++;
            try {
              const value = parseAny();
              obj[key] = value;
            } catch (e) {
              if (options_1.Allow.OBJ & allow)
                return obj;
              else
                throw e;
            }
            skipBlank();
            if (jsonString[index] === ",")
              index++;
          }
        } catch (e) {
          if (options_1.Allow.OBJ & allow)
            return obj;
          else
            markPartialJSON("Expected '}' at end of object");
        }
        index++;
        return obj;
      };
      const parseArr = () => {
        index++;
        const arr = [];
        try {
          while (jsonString[index] !== "]") {
            arr.push(parseAny());
            skipBlank();
            if (jsonString[index] === ",") {
              index++;
            }
          }
        } catch (e) {
          if (options_1.Allow.ARR & allow) {
            return arr;
          }
          markPartialJSON("Expected ']' at end of array");
        }
        index++;
        return arr;
      };
      const parseNum = () => {
        if (index === 0) {
          if (jsonString === "-")
            throwMalformedError("Not sure what '-' is");
          try {
            return JSON.parse(jsonString);
          } catch (e) {
            if (options_1.Allow.NUM & allow)
              try {
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
              } catch (e2) {
              }
            throwMalformedError(String(e));
          }
        }
        const start = index;
        if (jsonString[index] === "-")
          index++;
        while (jsonString[index] && ",]}".indexOf(jsonString[index]) === -1)
          index++;
        if (index == length && !(options_1.Allow.NUM & allow))
          markPartialJSON("Unterminated number literal");
        try {
          return JSON.parse(jsonString.substring(start, index));
        } catch (e) {
          if (jsonString.substring(start, index) === "-")
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
          } catch (e2) {
            throwMalformedError(String(e2));
          }
        }
      };
      const skipBlank = () => {
        while (index < length && " \n\r	".includes(jsonString[index])) {
          index++;
        }
      };
      return parseAny();
    };
    var parse2 = parseJSON;
    exports.parse = parse2;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map2) {
  overrideErrorMap = map2;
}
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x2) => x2.status === "aborted";
var isDirty = (x2) => x2.status === "dirty";
var isValid = (x2) => x2.status === "valid";
var isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message == null ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: (params == null ? void 0 : params.async) ?? false,
        contextualErrorMap: params == null ? void 0 : params.errorMap
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) == null ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params == null ? void 0 : params.errorMap,
        async: true
      },
      path: (params == null ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && (decoded == null ? void 0 : decoded.typ) !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      offset: (options == null ? void 0 : options.offset) ?? false,
      local: (options == null ? void 0 : options.local) ?? false,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options == null ? void 0 : options.precision) === "undefined" ? null : options == null ? void 0 : options.precision,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options == null ? void 0 : options.position,
      ...errorUtil.errToObj(options == null ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null;
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (params == null ? void 0 : params.coerce) ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params == null ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params == null ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b;
          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: ((arg) => ZodString.create({ ...arg, coerce: true })),
  number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
  boolean: ((arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  })),
  bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
  date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
};
var NEVER = INVALID;

// node_modules/@copilotkitnext/core/node_modules/@ag-ui/core/dist/index.mjs
var FunctionCallSchema = external_exports.object({
  name: external_exports.string(),
  arguments: external_exports.string()
});
var ToolCallSchema = external_exports.object({
  id: external_exports.string(),
  type: external_exports.literal("function"),
  function: FunctionCallSchema
});
var BaseMessageSchema = external_exports.object({
  id: external_exports.string(),
  role: external_exports.string(),
  content: external_exports.string().optional(),
  name: external_exports.string().optional()
});
var TextInputContentSchema = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string()
});
var BinaryInputContentObjectSchema = external_exports.object({
  type: external_exports.literal("binary"),
  mimeType: external_exports.string(),
  id: external_exports.string().optional(),
  url: external_exports.string().optional(),
  data: external_exports.string().optional(),
  filename: external_exports.string().optional()
});
var ensureBinaryPayload = (value, ctx) => {
  if (!value.id && !value.url && !value.data) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: "BinaryInputContent requires at least one of id, url, or data.",
      path: ["id"]
    });
  }
};
var BinaryInputContentSchema = BinaryInputContentObjectSchema.superRefine((value, ctx) => {
  ensureBinaryPayload(value, ctx);
});
var InputContentBaseSchema = external_exports.discriminatedUnion("type", [
  TextInputContentSchema,
  BinaryInputContentObjectSchema
]);
var InputContentSchema = InputContentBaseSchema.superRefine((value, ctx) => {
  if (value.type === "binary") {
    ensureBinaryPayload(value, ctx);
  }
});
var DeveloperMessageSchema = BaseMessageSchema.extend({
  role: external_exports.literal("developer"),
  content: external_exports.string()
});
var SystemMessageSchema = BaseMessageSchema.extend({
  role: external_exports.literal("system"),
  content: external_exports.string()
});
var AssistantMessageSchema = BaseMessageSchema.extend({
  role: external_exports.literal("assistant"),
  content: external_exports.string().optional(),
  toolCalls: external_exports.array(ToolCallSchema).optional()
});
var UserMessageSchema = BaseMessageSchema.extend({
  role: external_exports.literal("user"),
  content: external_exports.union([external_exports.string(), external_exports.array(InputContentSchema)])
});
var ToolMessageSchema = external_exports.object({
  id: external_exports.string(),
  content: external_exports.string(),
  role: external_exports.literal("tool"),
  toolCallId: external_exports.string(),
  error: external_exports.string().optional()
});
var ActivityMessageSchema = external_exports.object({
  id: external_exports.string(),
  role: external_exports.literal("activity"),
  activityType: external_exports.string(),
  content: external_exports.record(external_exports.any())
});
var MessageSchema = external_exports.discriminatedUnion("role", [
  DeveloperMessageSchema,
  SystemMessageSchema,
  AssistantMessageSchema,
  UserMessageSchema,
  ToolMessageSchema,
  ActivityMessageSchema
]);
var RoleSchema = external_exports.union([
  external_exports.literal("developer"),
  external_exports.literal("system"),
  external_exports.literal("assistant"),
  external_exports.literal("user"),
  external_exports.literal("tool"),
  external_exports.literal("activity")
]);
var ContextSchema = external_exports.object({
  description: external_exports.string(),
  value: external_exports.string()
});
var ToolSchema = external_exports.object({
  name: external_exports.string(),
  description: external_exports.string(),
  parameters: external_exports.any()
  // JSON Schema for the tool parameters
});
var RunAgentInputSchema = external_exports.object({
  threadId: external_exports.string(),
  runId: external_exports.string(),
  parentRunId: external_exports.string().optional(),
  state: external_exports.any(),
  messages: external_exports.array(MessageSchema),
  tools: external_exports.array(ToolSchema),
  context: external_exports.array(ContextSchema),
  forwardedProps: external_exports.any()
});
var StateSchema = external_exports.any();
var AGUIError = class extends Error {
  constructor(message) {
    super(message);
  }
};
var AGUIConnectNotImplementedError = class extends AGUIError {
  constructor() {
    super("Connect not implemented. This method is not supported by the current agent.");
  }
};
var TextMessageRoleSchema = external_exports.union([
  external_exports.literal("developer"),
  external_exports.literal("system"),
  external_exports.literal("assistant"),
  external_exports.literal("user")
]);
var EventType = ((EventType22) => {
  EventType22["TEXT_MESSAGE_START"] = "TEXT_MESSAGE_START";
  EventType22["TEXT_MESSAGE_CONTENT"] = "TEXT_MESSAGE_CONTENT";
  EventType22["TEXT_MESSAGE_END"] = "TEXT_MESSAGE_END";
  EventType22["TEXT_MESSAGE_CHUNK"] = "TEXT_MESSAGE_CHUNK";
  EventType22["THINKING_TEXT_MESSAGE_START"] = "THINKING_TEXT_MESSAGE_START";
  EventType22["THINKING_TEXT_MESSAGE_CONTENT"] = "THINKING_TEXT_MESSAGE_CONTENT";
  EventType22["THINKING_TEXT_MESSAGE_END"] = "THINKING_TEXT_MESSAGE_END";
  EventType22["TOOL_CALL_START"] = "TOOL_CALL_START";
  EventType22["TOOL_CALL_ARGS"] = "TOOL_CALL_ARGS";
  EventType22["TOOL_CALL_END"] = "TOOL_CALL_END";
  EventType22["TOOL_CALL_CHUNK"] = "TOOL_CALL_CHUNK";
  EventType22["TOOL_CALL_RESULT"] = "TOOL_CALL_RESULT";
  EventType22["THINKING_START"] = "THINKING_START";
  EventType22["THINKING_END"] = "THINKING_END";
  EventType22["STATE_SNAPSHOT"] = "STATE_SNAPSHOT";
  EventType22["STATE_DELTA"] = "STATE_DELTA";
  EventType22["MESSAGES_SNAPSHOT"] = "MESSAGES_SNAPSHOT";
  EventType22["ACTIVITY_SNAPSHOT"] = "ACTIVITY_SNAPSHOT";
  EventType22["ACTIVITY_DELTA"] = "ACTIVITY_DELTA";
  EventType22["RAW"] = "RAW";
  EventType22["CUSTOM"] = "CUSTOM";
  EventType22["RUN_STARTED"] = "RUN_STARTED";
  EventType22["RUN_FINISHED"] = "RUN_FINISHED";
  EventType22["RUN_ERROR"] = "RUN_ERROR";
  EventType22["STEP_STARTED"] = "STEP_STARTED";
  EventType22["STEP_FINISHED"] = "STEP_FINISHED";
  return EventType22;
})(EventType || {});
var BaseEventSchema = external_exports.object({
  type: external_exports.nativeEnum(EventType),
  timestamp: external_exports.number().optional(),
  rawEvent: external_exports.any().optional()
});
var TextMessageStartEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_START"
    /* TEXT_MESSAGE_START */
  ),
  messageId: external_exports.string(),
  role: TextMessageRoleSchema.default("assistant")
});
var TextMessageContentEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_CONTENT"
    /* TEXT_MESSAGE_CONTENT */
  ),
  messageId: external_exports.string(),
  delta: external_exports.string().refine((s) => s.length > 0, "Delta must not be an empty string")
});
var TextMessageEndEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_END"
    /* TEXT_MESSAGE_END */
  ),
  messageId: external_exports.string()
});
var TextMessageChunkEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_CHUNK"
    /* TEXT_MESSAGE_CHUNK */
  ),
  messageId: external_exports.string().optional(),
  role: TextMessageRoleSchema.optional(),
  delta: external_exports.string().optional()
});
var ThinkingTextMessageStartEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_START"
    /* THINKING_TEXT_MESSAGE_START */
  )
});
var ThinkingTextMessageContentEventSchema = TextMessageContentEventSchema.omit({
  messageId: true,
  type: true
}).extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_CONTENT"
    /* THINKING_TEXT_MESSAGE_CONTENT */
  )
});
var ThinkingTextMessageEndEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_END"
    /* THINKING_TEXT_MESSAGE_END */
  )
});
var ToolCallStartEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TOOL_CALL_START"
    /* TOOL_CALL_START */
  ),
  toolCallId: external_exports.string(),
  toolCallName: external_exports.string(),
  parentMessageId: external_exports.string().optional()
});
var ToolCallArgsEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TOOL_CALL_ARGS"
    /* TOOL_CALL_ARGS */
  ),
  toolCallId: external_exports.string(),
  delta: external_exports.string()
});
var ToolCallEndEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TOOL_CALL_END"
    /* TOOL_CALL_END */
  ),
  toolCallId: external_exports.string()
});
var ToolCallResultEventSchema = BaseEventSchema.extend({
  messageId: external_exports.string(),
  type: external_exports.literal(
    "TOOL_CALL_RESULT"
    /* TOOL_CALL_RESULT */
  ),
  toolCallId: external_exports.string(),
  content: external_exports.string(),
  role: external_exports.literal("tool").optional()
});
var ToolCallChunkEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "TOOL_CALL_CHUNK"
    /* TOOL_CALL_CHUNK */
  ),
  toolCallId: external_exports.string().optional(),
  toolCallName: external_exports.string().optional(),
  parentMessageId: external_exports.string().optional(),
  delta: external_exports.string().optional()
});
var ThinkingStartEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "THINKING_START"
    /* THINKING_START */
  ),
  title: external_exports.string().optional()
});
var ThinkingEndEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "THINKING_END"
    /* THINKING_END */
  )
});
var StateSnapshotEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "STATE_SNAPSHOT"
    /* STATE_SNAPSHOT */
  ),
  snapshot: StateSchema
});
var StateDeltaEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "STATE_DELTA"
    /* STATE_DELTA */
  ),
  delta: external_exports.array(external_exports.any())
  // JSON Patch (RFC 6902)
});
var MessagesSnapshotEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "MESSAGES_SNAPSHOT"
    /* MESSAGES_SNAPSHOT */
  ),
  messages: external_exports.array(MessageSchema)
});
var ActivitySnapshotEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "ACTIVITY_SNAPSHOT"
    /* ACTIVITY_SNAPSHOT */
  ),
  messageId: external_exports.string(),
  activityType: external_exports.string(),
  content: external_exports.record(external_exports.any()),
  replace: external_exports.boolean().optional().default(true)
});
var ActivityDeltaEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "ACTIVITY_DELTA"
    /* ACTIVITY_DELTA */
  ),
  messageId: external_exports.string(),
  activityType: external_exports.string(),
  patch: external_exports.array(external_exports.any())
});
var RawEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "RAW"
    /* RAW */
  ),
  event: external_exports.any(),
  source: external_exports.string().optional()
});
var CustomEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "CUSTOM"
    /* CUSTOM */
  ),
  name: external_exports.string(),
  value: external_exports.any()
});
var RunStartedEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "RUN_STARTED"
    /* RUN_STARTED */
  ),
  threadId: external_exports.string(),
  runId: external_exports.string(),
  parentRunId: external_exports.string().optional(),
  input: RunAgentInputSchema.optional()
});
var RunFinishedEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "RUN_FINISHED"
    /* RUN_FINISHED */
  ),
  threadId: external_exports.string(),
  runId: external_exports.string(),
  result: external_exports.any().optional()
});
var RunErrorEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "RUN_ERROR"
    /* RUN_ERROR */
  ),
  message: external_exports.string(),
  code: external_exports.string().optional()
});
var StepStartedEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "STEP_STARTED"
    /* STEP_STARTED */
  ),
  stepName: external_exports.string()
});
var StepFinishedEventSchema = BaseEventSchema.extend({
  type: external_exports.literal(
    "STEP_FINISHED"
    /* STEP_FINISHED */
  ),
  stepName: external_exports.string()
});
var EventSchemas = external_exports.discriminatedUnion("type", [
  TextMessageStartEventSchema,
  TextMessageContentEventSchema,
  TextMessageEndEventSchema,
  TextMessageChunkEventSchema,
  ThinkingStartEventSchema,
  ThinkingEndEventSchema,
  ThinkingTextMessageStartEventSchema,
  ThinkingTextMessageContentEventSchema,
  ThinkingTextMessageEndEventSchema,
  ToolCallStartEventSchema,
  ToolCallArgsEventSchema,
  ToolCallEndEventSchema,
  ToolCallChunkEventSchema,
  ToolCallResultEventSchema,
  StateSnapshotEventSchema,
  StateDeltaEventSchema,
  MessagesSnapshotEventSchema,
  ActivitySnapshotEventSchema,
  ActivityDeltaEventSchema,
  RawEventSchema,
  CustomEventSchema,
  RunStartedEventSchema,
  RunFinishedEventSchema,
  RunErrorEventSchema,
  StepStartedEventSchema,
  StepFinishedEventSchema
]);

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y2 = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values2(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = (function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
});

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (function() {
  return createNotification("C", void 0, void 0);
})();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = (function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x2) {
  return x2;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = (function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
})();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = (function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
})(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = (function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = (function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
})(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var objectProto = Object.prototype;

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map(function(b, ii) {
        return resultSelector(a, b, i, ii);
      })(innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = (function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js
function defaultIfEmpty(defaultValue) {
  return operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = (function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
})();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = (function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
})(Observable);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = (function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = (function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = (function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = (function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = (function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = (function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = (function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = (function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = (function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = (function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
})(AsyncScheduler);
var VirtualAction = (function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER2 = new Observable(noop);

// node_modules/fast-json-patch/module/core.mjs
var core_exports = {};
__export(core_exports, {
  JsonPatchError: () => JsonPatchError,
  _areEquals: () => _areEquals,
  applyOperation: () => applyOperation,
  applyPatch: () => applyPatch,
  applyReducer: () => applyReducer,
  deepClone: () => deepClone,
  getValueByPointer: () => getValueByPointer,
  validate: () => validate,
  validator: () => validator
});

// node_modules/fast-json-patch/module/helpers.mjs
var __extends2 = /* @__PURE__ */ (function() {
  var extendStatics2 = function(d, b) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (b2.hasOwnProperty(p)) d2[p] = b2[p];
    };
    return extendStatics2(d, b);
  };
  return function(d, b) {
    extendStatics2(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
})();
var _hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}
function _objectKeys(obj) {
  if (Array.isArray(obj)) {
    var keys_1 = new Array(obj.length);
    for (var k2 = 0; k2 < keys_1.length; k2++) {
      keys_1[k2] = "" + k2;
    }
    return keys_1;
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  var keys = [];
  for (var i in obj) {
    if (hasOwnProperty(obj, i)) {
      keys.push(i);
    }
  }
  return keys;
}
function _deepClone(obj) {
  switch (typeof obj) {
    case "object":
      return JSON.parse(JSON.stringify(obj));
    //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5
    case "undefined":
      return null;
    //this is how JSON.stringify behaves for array items
    default:
      return obj;
  }
}
function isInteger(str) {
  var i = 0;
  var len = str.length;
  var charCode;
  while (i < len) {
    charCode = str.charCodeAt(i);
    if (charCode >= 48 && charCode <= 57) {
      i++;
      continue;
    }
    return false;
  }
  return true;
}
function escapePathComponent(path) {
  if (path.indexOf("/") === -1 && path.indexOf("~") === -1)
    return path;
  return path.replace(/~/g, "~0").replace(/\//g, "~1");
}
function unescapePathComponent(path) {
  return path.replace(/~1/g, "/").replace(/~0/g, "~");
}
function hasUndefined(obj) {
  if (obj === void 0) {
    return true;
  }
  if (obj) {
    if (Array.isArray(obj)) {
      for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {
        if (hasUndefined(obj[i_1])) {
          return true;
        }
      }
    } else if (typeof obj === "object") {
      var objKeys = _objectKeys(obj);
      var objKeysLength = objKeys.length;
      for (var i = 0; i < objKeysLength; i++) {
        if (hasUndefined(obj[objKeys[i]])) {
          return true;
        }
      }
    }
  }
  return false;
}
function patchErrorMessageFormatter(message, args) {
  var messageParts = [message];
  for (var key in args) {
    var value = typeof args[key] === "object" ? JSON.stringify(args[key], null, 2) : args[key];
    if (typeof value !== "undefined") {
      messageParts.push(key + ": " + value);
    }
  }
  return messageParts.join("\n");
}
var PatchError = (
  /** @class */
  (function(_super) {
    __extends2(PatchError2, _super);
    function PatchError2(message, name, index, operation, tree) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, patchErrorMessageFormatter(message, { name, index, operation, tree })) || this;
      _this.name = name;
      _this.index = index;
      _this.operation = operation;
      _this.tree = tree;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      _this.message = patchErrorMessageFormatter(message, { name, index, operation, tree });
      return _this;
    }
    return PatchError2;
  })(Error)
);

// node_modules/fast-json-patch/module/core.mjs
var JsonPatchError = PatchError;
var deepClone = _deepClone;
var objOps = {
  add: function(obj, key, document) {
    obj[key] = this.value;
    return { newDocument: document };
  },
  remove: function(obj, key, document) {
    var removed = obj[key];
    delete obj[key];
    return { newDocument: document, removed };
  },
  replace: function(obj, key, document) {
    var removed = obj[key];
    obj[key] = this.value;
    return { newDocument: document, removed };
  },
  move: function(obj, key, document) {
    var removed = getValueByPointer(document, this.path);
    if (removed) {
      removed = _deepClone(removed);
    }
    var originalValue = applyOperation(document, { op: "remove", path: this.from }).removed;
    applyOperation(document, { op: "add", path: this.path, value: originalValue });
    return { newDocument: document, removed };
  },
  copy: function(obj, key, document) {
    var valueToCopy = getValueByPointer(document, this.from);
    applyOperation(document, { op: "add", path: this.path, value: _deepClone(valueToCopy) });
    return { newDocument: document };
  },
  test: function(obj, key, document) {
    return { newDocument: document, test: _areEquals(obj[key], this.value) };
  },
  _get: function(obj, key, document) {
    this.value = obj[key];
    return { newDocument: document };
  }
};
var arrOps = {
  add: function(arr, i, document) {
    if (isInteger(i)) {
      arr.splice(i, 0, this.value);
    } else {
      arr[i] = this.value;
    }
    return { newDocument: document, index: i };
  },
  remove: function(arr, i, document) {
    var removedList = arr.splice(i, 1);
    return { newDocument: document, removed: removedList[0] };
  },
  replace: function(arr, i, document) {
    var removed = arr[i];
    arr[i] = this.value;
    return { newDocument: document, removed };
  },
  move: objOps.move,
  copy: objOps.copy,
  test: objOps.test,
  _get: objOps._get
};
function getValueByPointer(document, pointer) {
  if (pointer == "") {
    return document;
  }
  var getOriginalDestination = { op: "_get", path: pointer };
  applyOperation(document, getOriginalDestination);
  return getOriginalDestination.value;
}
function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {
  if (validateOperation === void 0) {
    validateOperation = false;
  }
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (index === void 0) {
    index = 0;
  }
  if (validateOperation) {
    if (typeof validateOperation == "function") {
      validateOperation(operation, 0, document, operation.path);
    } else {
      validator(operation, 0);
    }
  }
  if (operation.path === "") {
    var returnValue = { newDocument: document };
    if (operation.op === "add") {
      returnValue.newDocument = operation.value;
      return returnValue;
    } else if (operation.op === "replace") {
      returnValue.newDocument = operation.value;
      returnValue.removed = document;
      return returnValue;
    } else if (operation.op === "move" || operation.op === "copy") {
      returnValue.newDocument = getValueByPointer(document, operation.from);
      if (operation.op === "move") {
        returnValue.removed = document;
      }
      return returnValue;
    } else if (operation.op === "test") {
      returnValue.test = _areEquals(document, operation.value);
      if (returnValue.test === false) {
        throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
      }
      returnValue.newDocument = document;
      return returnValue;
    } else if (operation.op === "remove") {
      returnValue.removed = document;
      returnValue.newDocument = null;
      return returnValue;
    } else if (operation.op === "_get") {
      operation.value = document;
      return returnValue;
    } else {
      if (validateOperation) {
        throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
      } else {
        return returnValue;
      }
    }
  } else {
    if (!mutateDocument) {
      document = _deepClone(document);
    }
    var path = operation.path || "";
    var keys = path.split("/");
    var obj = document;
    var t = 1;
    var len = keys.length;
    var existingPathFragment = void 0;
    var key = void 0;
    var validateFunction = void 0;
    if (typeof validateOperation == "function") {
      validateFunction = validateOperation;
    } else {
      validateFunction = validator;
    }
    while (true) {
      key = keys[t];
      if (key && key.indexOf("~") != -1) {
        key = unescapePathComponent(key);
      }
      if (banPrototypeModifications && (key == "__proto__" || key == "prototype" && t > 0 && keys[t - 1] == "constructor")) {
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      }
      if (validateOperation) {
        if (existingPathFragment === void 0) {
          if (obj[key] === void 0) {
            existingPathFragment = keys.slice(0, t).join("/");
          } else if (t == len - 1) {
            existingPathFragment = operation.path;
          }
          if (existingPathFragment !== void 0) {
            validateFunction(operation, 0, document, existingPathFragment);
          }
        }
      }
      t++;
      if (Array.isArray(obj)) {
        if (key === "-") {
          key = obj.length;
        } else {
          if (validateOperation && !isInteger(key)) {
            throw new JsonPatchError("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", index, operation, document);
          } else if (isInteger(key)) {
            key = ~~key;
          }
        }
        if (t >= len) {
          if (validateOperation && operation.op === "add" && key > obj.length) {
            throw new JsonPatchError("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", index, operation, document);
          }
          var returnValue = arrOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      } else {
        if (t >= len) {
          var returnValue = objOps[operation.op].call(operation, obj, key, document);
          if (returnValue.test === false) {
            throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
          }
          return returnValue;
        }
      }
      obj = obj[key];
      if (validateOperation && t < len && (!obj || typeof obj !== "object")) {
        throw new JsonPatchError("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {
  if (mutateDocument === void 0) {
    mutateDocument = true;
  }
  if (banPrototypeModifications === void 0) {
    banPrototypeModifications = true;
  }
  if (validateOperation) {
    if (!Array.isArray(patch)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
  }
  if (!mutateDocument) {
    document = _deepClone(document);
  }
  var results = new Array(patch.length);
  for (var i = 0, length_1 = patch.length; i < length_1; i++) {
    results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);
    document = results[i].newDocument;
  }
  results.newDocument = document;
  return results;
}
function applyReducer(document, operation, index) {
  var operationResult = applyOperation(document, operation);
  if (operationResult.test === false) {
    throw new JsonPatchError("Test operation failed", "TEST_OPERATION_FAILED", index, operation, document);
  }
  return operationResult.newDocument;
}
function validator(operation, index, document, existingPathFragment) {
  if (typeof operation !== "object" || operation === null || Array.isArray(operation)) {
    throw new JsonPatchError("Operation is not an object", "OPERATION_NOT_AN_OBJECT", index, operation, document);
  } else if (!objOps[operation.op]) {
    throw new JsonPatchError("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", index, operation, document);
  } else if (typeof operation.path !== "string") {
    throw new JsonPatchError("Operation `path` property is not a string", "OPERATION_PATH_INVALID", index, operation, document);
  } else if (operation.path.indexOf("/") !== 0 && operation.path.length > 0) {
    throw new JsonPatchError('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", index, operation, document);
  } else if ((operation.op === "move" || operation.op === "copy") && typeof operation.from !== "string") {
    throw new JsonPatchError("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && operation.value === void 0) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", index, operation, document);
  } else if ((operation.op === "add" || operation.op === "replace" || operation.op === "test") && hasUndefined(operation.value)) {
    throw new JsonPatchError("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", index, operation, document);
  } else if (document) {
    if (operation.op == "add") {
      var pathLen = operation.path.split("/").length;
      var existingPathLen = existingPathFragment.split("/").length;
      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {
        throw new JsonPatchError("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", index, operation, document);
      }
    } else if (operation.op === "replace" || operation.op === "remove" || operation.op === "_get") {
      if (operation.path !== existingPathFragment) {
        throw new JsonPatchError("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", index, operation, document);
      }
    } else if (operation.op === "move" || operation.op === "copy") {
      var existingValue = { op: "_get", path: operation.from, value: void 0 };
      var error = validate([existingValue], document);
      if (error && error.name === "OPERATION_PATH_UNRESOLVABLE") {
        throw new JsonPatchError("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", index, operation, document);
      }
    }
  }
}
function validate(sequence, document, externalValidator) {
  try {
    if (!Array.isArray(sequence)) {
      throw new JsonPatchError("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    }
    if (document) {
      applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);
    } else {
      externalValidator = externalValidator || validator;
      for (var i = 0; i < sequence.length; i++) {
        externalValidator(sequence[i], i, document, void 0);
      }
    }
  } catch (e) {
    if (e instanceof JsonPatchError) {
      return e;
    } else {
      throw e;
    }
  }
}
function _areEquals(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;
    if (arrA && arrB) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; )
        if (!_areEquals(a[i], b[i]))
          return false;
      return true;
    }
    if (arrA != arrB)
      return false;
    var keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length)
      return false;
    for (i = length; i-- !== 0; )
      if (!b.hasOwnProperty(keys[i]))
        return false;
    for (i = length; i-- !== 0; ) {
      key = keys[i];
      if (!_areEquals(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}

// node_modules/fast-json-patch/module/duplex.mjs
var duplex_exports = {};
__export(duplex_exports, {
  compare: () => compare,
  generate: () => generate2,
  observe: () => observe,
  unobserve: () => unobserve
});
var beforeDict = /* @__PURE__ */ new WeakMap();
var Mirror = (
  /** @class */
  /* @__PURE__ */ (function() {
    function Mirror2(obj) {
      this.observers = /* @__PURE__ */ new Map();
      this.obj = obj;
    }
    return Mirror2;
  })()
);
var ObserverInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ObserverInfo2(callback, observer) {
      this.callback = callback;
      this.observer = observer;
    }
    return ObserverInfo2;
  })()
);
function getMirror(obj) {
  return beforeDict.get(obj);
}
function getObserverFromMirror(mirror, callback) {
  return mirror.observers.get(callback);
}
function removeObserverFromMirror(mirror, observer) {
  mirror.observers.delete(observer.callback);
}
function unobserve(root, observer) {
  observer.unobserve();
}
function observe(obj, callback) {
  var patches = [];
  var observer;
  var mirror = getMirror(obj);
  if (!mirror) {
    mirror = new Mirror(obj);
    beforeDict.set(obj, mirror);
  } else {
    var observerInfo = getObserverFromMirror(mirror, callback);
    observer = observerInfo && observerInfo.observer;
  }
  if (observer) {
    return observer;
  }
  observer = {};
  mirror.value = _deepClone(obj);
  if (callback) {
    observer.callback = callback;
    observer.next = null;
    var dirtyCheck = function() {
      generate2(observer);
    };
    var fastCheck = function() {
      clearTimeout(observer.next);
      observer.next = setTimeout(dirtyCheck);
    };
    if (typeof window !== "undefined") {
      window.addEventListener("mouseup", fastCheck);
      window.addEventListener("keyup", fastCheck);
      window.addEventListener("mousedown", fastCheck);
      window.addEventListener("keydown", fastCheck);
      window.addEventListener("change", fastCheck);
    }
  }
  observer.patches = patches;
  observer.object = obj;
  observer.unobserve = function() {
    generate2(observer);
    clearTimeout(observer.next);
    removeObserverFromMirror(mirror, observer);
    if (typeof window !== "undefined") {
      window.removeEventListener("mouseup", fastCheck);
      window.removeEventListener("keyup", fastCheck);
      window.removeEventListener("mousedown", fastCheck);
      window.removeEventListener("keydown", fastCheck);
      window.removeEventListener("change", fastCheck);
    }
  };
  mirror.observers.set(callback, new ObserverInfo(callback, observer));
  return observer;
}
function generate2(observer, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var mirror = beforeDict.get(observer.object);
  _generate(mirror.value, observer.object, observer.patches, "", invertible);
  if (observer.patches.length) {
    applyPatch(mirror.value, observer.patches);
  }
  var temp = observer.patches;
  if (temp.length > 0) {
    observer.patches = [];
    if (observer.callback) {
      observer.callback(temp);
    }
  }
  return temp;
}
function _generate(mirror, obj, patches, path, invertible) {
  if (obj === mirror) {
    return;
  }
  if (typeof obj.toJSON === "function") {
    obj = obj.toJSON();
  }
  var newKeys = _objectKeys(obj);
  var oldKeys = _objectKeys(mirror);
  var changed = false;
  var deleted = false;
  for (var t = oldKeys.length - 1; t >= 0; t--) {
    var key = oldKeys[t];
    var oldVal = mirror[key];
    if (hasOwnProperty(obj, key) && !(obj[key] === void 0 && oldVal !== void 0 && Array.isArray(obj) === false)) {
      var newVal = obj[key];
      if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {
        _generate(oldVal, newVal, patches, path + "/" + escapePathComponent(key), invertible);
      } else {
        if (oldVal !== newVal) {
          changed = true;
          if (invertible) {
            patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
          }
          patches.push({ op: "replace", path: path + "/" + escapePathComponent(key), value: _deepClone(newVal) });
        }
      }
    } else if (Array.isArray(mirror) === Array.isArray(obj)) {
      if (invertible) {
        patches.push({ op: "test", path: path + "/" + escapePathComponent(key), value: _deepClone(oldVal) });
      }
      patches.push({ op: "remove", path: path + "/" + escapePathComponent(key) });
      deleted = true;
    } else {
      if (invertible) {
        patches.push({ op: "test", path, value: mirror });
      }
      patches.push({ op: "replace", path, value: obj });
      changed = true;
    }
  }
  if (!deleted && newKeys.length == oldKeys.length) {
    return;
  }
  for (var t = 0; t < newKeys.length; t++) {
    var key = newKeys[t];
    if (!hasOwnProperty(mirror, key) && obj[key] !== void 0) {
      patches.push({ op: "add", path: path + "/" + escapePathComponent(key), value: _deepClone(obj[key]) });
    }
  }
}
function compare(tree1, tree2, invertible) {
  if (invertible === void 0) {
    invertible = false;
  }
  var patches = [];
  _generate(tree1, tree2, patches, "", invertible);
  return patches;
}

// node_modules/fast-json-patch/index.mjs
var fast_json_patch_default = Object.assign({}, core_exports, duplex_exports, {
  JsonPatchError: PatchError,
  deepClone: _deepClone,
  escapePathComponent,
  unescapePathComponent
});

// node_modules/untruncate-json/dist/esm/index.js
function isWhitespace(char) {
  return " \r\n	".indexOf(char) >= 0;
}
function untruncateJson(json) {
  var contextStack = [
    "topLevel"
    /* TOP_LEVEL */
  ];
  var position = 0;
  var respawnPosition;
  var respawnStackLength;
  var respawnReason;
  var push = function(context2) {
    return contextStack.push(context2);
  };
  var replace = function(context2) {
    return contextStack[contextStack.length - 1] = context2;
  };
  var setRespawn = function(reason) {
    if (respawnPosition == null) {
      respawnPosition = position;
      respawnStackLength = contextStack.length;
      respawnReason = reason;
    }
  };
  var clearRespawn = function(reason) {
    if (reason === respawnReason) {
      respawnPosition = void 0;
      respawnStackLength = void 0;
      respawnReason = void 0;
    }
  };
  var pop = function() {
    return contextStack.pop();
  };
  var dontConsumeCharacter = function() {
    return position--;
  };
  var startAny = function(char2) {
    if ("0" <= char2 && char2 <= "9") {
      push(
        "number"
        /* NUMBER */
      );
      return;
    }
    switch (char2) {
      case '"':
        push(
          "string"
          /* STRING */
        );
        return;
      case "-":
        push(
          "numberNeedsDigit"
          /* NUMBER_NEEDS_DIGIT */
        );
        return;
      case "t":
        push(
          "true"
          /* TRUE */
        );
        return;
      case "f":
        push(
          "false"
          /* FALSE */
        );
        return;
      case "n":
        push(
          "null"
          /* NULL */
        );
        return;
      case "[":
        push(
          "arrayNeedsValue"
          /* ARRAY_NEEDS_VALUE */
        );
        return;
      case "{":
        push(
          "objectNeedsKey"
          /* OBJECT_NEEDS_KEY */
        );
        return;
    }
  };
  for (var length = json.length; position < length; position++) {
    var char = json[position];
    switch (contextStack[contextStack.length - 1]) {
      case "topLevel":
        startAny(char);
        break;
      case "string":
        switch (char) {
          case '"':
            pop();
            break;
          case "\\":
            setRespawn(
              "stringEscape"
              /* STRING_ESCAPE */
            );
            push(
              "stringEscaped"
              /* STRING_ESCAPED */
            );
            break;
        }
        break;
      case "stringEscaped":
        if (char === "u") {
          push(
            "stringUnicode"
            /* STRING_UNICODE */
          );
        } else {
          clearRespawn(
            "stringEscape"
            /* STRING_ESCAPE */
          );
          pop();
        }
        break;
      case "stringUnicode":
        if (position - json.lastIndexOf("u", position) === 4) {
          clearRespawn(
            "stringEscape"
            /* STRING_ESCAPE */
          );
          pop();
        }
        break;
      case "number":
        if (char === ".") {
          replace(
            "numberNeedsDigit"
            /* NUMBER_NEEDS_DIGIT */
          );
        } else if (char === "e" || char === "E") {
          replace(
            "numberNeedsExponent"
            /* NUMBER_NEEDS_EXPONENT */
          );
        } else if (char < "0" || char > "9") {
          dontConsumeCharacter();
          pop();
        }
        break;
      case "numberNeedsDigit":
        replace(
          "number"
          /* NUMBER */
        );
        break;
      case "numberNeedsExponent":
        if (char === "+" || char === "-") {
          replace(
            "numberNeedsDigit"
            /* NUMBER_NEEDS_DIGIT */
          );
        } else {
          replace(
            "number"
            /* NUMBER */
          );
        }
        break;
      case "true":
      case "false":
      case "null":
        if (char < "a" || char > "z") {
          dontConsumeCharacter();
          pop();
        }
        break;
      case "arrayNeedsValue":
        if (char === "]") {
          pop();
        } else if (!isWhitespace(char)) {
          clearRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "arrayNeedsComma"
            /* ARRAY_NEEDS_COMMA */
          );
          startAny(char);
        }
        break;
      case "arrayNeedsComma":
        if (char === "]") {
          pop();
        } else if (char === ",") {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "arrayNeedsValue"
            /* ARRAY_NEEDS_VALUE */
          );
        }
        break;
      case "objectNeedsKey":
        if (char === "}") {
          pop();
        } else if (char === '"') {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsColon"
            /* OBJECT_NEEDS_COLON */
          );
          push(
            "string"
            /* STRING */
          );
        }
        break;
      case "objectNeedsColon":
        if (char === ":") {
          replace(
            "objectNeedsValue"
            /* OBJECT_NEEDS_VALUE */
          );
        }
        break;
      case "objectNeedsValue":
        if (!isWhitespace(char)) {
          clearRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsComma"
            /* OBJECT_NEEDS_COMMA */
          );
          startAny(char);
        }
        break;
      case "objectNeedsComma":
        if (char === "}") {
          pop();
        } else if (char === ",") {
          setRespawn(
            "collectionItem"
            /* COLLECTION_ITEM */
          );
          replace(
            "objectNeedsKey"
            /* OBJECT_NEEDS_KEY */
          );
        }
        break;
    }
  }
  if (respawnStackLength != null) {
    contextStack.length = respawnStackLength;
  }
  var result = [
    respawnPosition != null ? json.slice(0, respawnPosition) : json
  ];
  var finishWord = function(word) {
    return result.push(word.slice(json.length - json.lastIndexOf(word[0])));
  };
  for (var i = contextStack.length - 1; i >= 0; i--) {
    switch (contextStack[i]) {
      case "string":
        result.push('"');
        break;
      case "numberNeedsDigit":
      case "numberNeedsExponent":
        result.push("0");
        break;
      case "true":
        finishWord("true");
        break;
      case "false":
        finishWord("false");
        break;
      case "null":
        finishWord("null");
        break;
      case "arrayNeedsValue":
      case "arrayNeedsComma":
        result.push("]");
        break;
      case "objectNeedsKey":
      case "objectNeedsColon":
      case "objectNeedsValue":
      case "objectNeedsComma":
        result.push("}");
        break;
    }
  }
  return result.join("");
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b = this.buf[this.pos++];
    lowBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b = this.buf[this.pos++];
    highBits |= (b & 127) << shift;
    if ((b & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b = this.buf[this.pos++];
  let result = b & 127;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 7;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 14;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 127) << 21;
  if ((b & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b = this.buf[this.pos++];
  result |= (b & 15) << 28;
  for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
    b = this.buf[this.pos++];
  if ((b & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (!!globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808");
    const MAX = BigInt("9223372036854775807");
    const UMIN = BigInt("0");
    const UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te3 = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te3.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (_) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
var BinaryWriter = class {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    const tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    const tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
    hi = hi >>> 1 ^ s;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
};
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (Number.isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/descriptors.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js
var unsafeLocal = Symbol.for("reflect unsafe local");

// node_modules/@bufbuild/protobuf/dist/esm/create.js
var tokenZeroMessageField = Symbol();

// node_modules/@copilotkitnext/core/node_modules/@ag-ui/proto/dist/index.mjs
function createBaseStruct() {
  return { fields: {} };
}
var Struct = {
  encode(message, writer = new BinaryWriter()) {
    Object.entries(message.fields).forEach(([key, value]) => {
      if (value !== void 0) {
        Struct_FieldsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
      }
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Struct.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStruct();
    message.fields = Object.entries((_a = object.fields) != null ? _a : {}).reduce(
      (acc, [key, value]) => {
        if (value !== void 0) {
          acc[key] = value;
        }
        return acc;
      },
      {}
    );
    return message;
  },
  wrap(object) {
    const struct = createBaseStruct();
    if (object !== void 0) {
      for (const key of Object.keys(object)) {
        struct.fields[key] = object[key];
      }
    }
    return struct;
  },
  unwrap(message) {
    const object = {};
    if (message.fields) {
      for (const key of Object.keys(message.fields)) {
        object[key] = message.fields[key];
      }
    }
    return object;
  }
};
function createBaseStruct_FieldsEntry() {
  return { key: "", value: void 0 };
}
var Struct_FieldsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStruct_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Struct_FieldsEntry.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseStruct_FieldsEntry();
    message.key = (_a = object.key) != null ? _a : "";
    message.value = (_b = object.value) != null ? _b : void 0;
    return message;
  }
};
function createBaseValue() {
  return {
    nullValue: void 0,
    numberValue: void 0,
    stringValue: void 0,
    boolValue: void 0,
    structValue: void 0,
    listValue: void 0
  };
}
var Value = {
  encode(message, writer = new BinaryWriter()) {
    if (message.nullValue !== void 0) {
      writer.uint32(8).int32(message.nullValue);
    }
    if (message.numberValue !== void 0) {
      writer.uint32(17).double(message.numberValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(26).string(message.stringValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.structValue !== void 0) {
      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();
    }
    if (message.listValue !== void 0) {
      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.nullValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.numberValue = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Value.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseValue();
    message.nullValue = (_a = object.nullValue) != null ? _a : void 0;
    message.numberValue = (_b = object.numberValue) != null ? _b : void 0;
    message.stringValue = (_c = object.stringValue) != null ? _c : void 0;
    message.boolValue = (_d = object.boolValue) != null ? _d : void 0;
    message.structValue = (_e = object.structValue) != null ? _e : void 0;
    message.listValue = (_f = object.listValue) != null ? _f : void 0;
    return message;
  },
  wrap(value) {
    const result = createBaseValue();
    if (value === null) {
      result.nullValue = 0;
    } else if (typeof value === "boolean") {
      result.boolValue = value;
    } else if (typeof value === "number") {
      result.numberValue = value;
    } else if (typeof value === "string") {
      result.stringValue = value;
    } else if (globalThis.Array.isArray(value)) {
      result.listValue = value;
    } else if (typeof value === "object") {
      result.structValue = value;
    } else if (typeof value !== "undefined") {
      throw new globalThis.Error("Unsupported any value type: " + typeof value);
    }
    return result;
  },
  unwrap(message) {
    if (message.stringValue !== void 0) {
      return message.stringValue;
    } else if ((message == null ? void 0 : message.numberValue) !== void 0) {
      return message.numberValue;
    } else if ((message == null ? void 0 : message.boolValue) !== void 0) {
      return message.boolValue;
    } else if ((message == null ? void 0 : message.structValue) !== void 0) {
      return message.structValue;
    } else if ((message == null ? void 0 : message.listValue) !== void 0) {
      return message.listValue;
    } else if ((message == null ? void 0 : message.nullValue) !== void 0) {
      return null;
    }
    return void 0;
  }
};
function createBaseListValue() {
  return { values: [] };
}
var ListValue = {
  encode(message, writer = new BinaryWriter()) {
    for (const v of message.values) {
      Value.encode(Value.wrap(v), writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseListValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ListValue.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseListValue();
    message.values = ((_a = object.values) == null ? void 0 : _a.map((e) => e)) || [];
    return message;
  },
  wrap(array) {
    const result = createBaseListValue();
    result.values = array != null ? array : [];
    return result;
  },
  unwrap(message) {
    if ((message == null ? void 0 : message.hasOwnProperty("values")) && globalThis.Array.isArray(message.values)) {
      return message.values;
    } else {
      return message;
    }
  }
};
var JsonPatchOperationType = ((JsonPatchOperationType22) => {
  JsonPatchOperationType22[JsonPatchOperationType22["ADD"] = 0] = "ADD";
  JsonPatchOperationType22[JsonPatchOperationType22["REMOVE"] = 1] = "REMOVE";
  JsonPatchOperationType22[JsonPatchOperationType22["REPLACE"] = 2] = "REPLACE";
  JsonPatchOperationType22[JsonPatchOperationType22["MOVE"] = 3] = "MOVE";
  JsonPatchOperationType22[JsonPatchOperationType22["COPY"] = 4] = "COPY";
  JsonPatchOperationType22[JsonPatchOperationType22["TEST"] = 5] = "TEST";
  JsonPatchOperationType22[JsonPatchOperationType22["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return JsonPatchOperationType22;
})(JsonPatchOperationType || {});
function createBaseJsonPatchOperation() {
  return { op: 0, path: "", from: void 0, value: void 0 };
}
var JsonPatchOperation = {
  encode(message, writer = new BinaryWriter()) {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    if (message.from !== void 0) {
      writer.uint32(26).string(message.from);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseJsonPatchOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.op = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.from = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return JsonPatchOperation.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseJsonPatchOperation();
    message.op = (_a = object.op) != null ? _a : 0;
    message.path = (_b = object.path) != null ? _b : "";
    message.from = (_c = object.from) != null ? _c : void 0;
    message.value = (_d = object.value) != null ? _d : void 0;
    return message;
  }
};
function createBaseToolCall() {
  return { id: "", type: "", function: void 0 };
}
var ToolCall = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.function !== void 0) {
      ToolCall_Function.encode(message.function, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.function = ToolCall_Function.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCall.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseToolCall();
    message.id = (_a = object.id) != null ? _a : "";
    message.type = (_b = object.type) != null ? _b : "";
    message.function = object.function !== void 0 && object.function !== null ? ToolCall_Function.fromPartial(object.function) : void 0;
    return message;
  }
};
function createBaseToolCall_Function() {
  return { name: "", arguments: "" };
}
var ToolCall_Function = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.arguments !== "") {
      writer.uint32(18).string(message.arguments);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCall_Function();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.arguments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCall_Function.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseToolCall_Function();
    message.name = (_a = object.name) != null ? _a : "";
    message.arguments = (_b = object.arguments) != null ? _b : "";
    return message;
  }
};
function createBaseMessage() {
  return {
    id: "",
    role: "",
    content: void 0,
    name: void 0,
    toolCalls: [],
    toolCallId: void 0,
    error: void 0
  };
}
var Message = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.content !== void 0) {
      writer.uint32(26).string(message.content);
    }
    if (message.name !== void 0) {
      writer.uint32(34).string(message.name);
    }
    for (const v of message.toolCalls) {
      ToolCall.encode(v, writer.uint32(42).fork()).join();
    }
    if (message.toolCallId !== void 0) {
      writer.uint32(50).string(message.toolCallId);
    }
    if (message.error !== void 0) {
      writer.uint32(58).string(message.error);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.toolCallId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Message.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseMessage();
    message.id = (_a = object.id) != null ? _a : "";
    message.role = (_b = object.role) != null ? _b : "";
    message.content = (_c = object.content) != null ? _c : void 0;
    message.name = (_d = object.name) != null ? _d : void 0;
    message.toolCalls = ((_e = object.toolCalls) == null ? void 0 : _e.map((e) => ToolCall.fromPartial(e))) || [];
    message.toolCallId = (_f = object.toolCallId) != null ? _f : void 0;
    message.error = (_g = object.error) != null ? _g : void 0;
    return message;
  }
};
var EventType2 = ((EventType32) => {
  EventType32[EventType32["TEXT_MESSAGE_START"] = 0] = "TEXT_MESSAGE_START";
  EventType32[EventType32["TEXT_MESSAGE_CONTENT"] = 1] = "TEXT_MESSAGE_CONTENT";
  EventType32[EventType32["TEXT_MESSAGE_END"] = 2] = "TEXT_MESSAGE_END";
  EventType32[EventType32["TOOL_CALL_START"] = 3] = "TOOL_CALL_START";
  EventType32[EventType32["TOOL_CALL_ARGS"] = 4] = "TOOL_CALL_ARGS";
  EventType32[EventType32["TOOL_CALL_END"] = 5] = "TOOL_CALL_END";
  EventType32[EventType32["STATE_SNAPSHOT"] = 6] = "STATE_SNAPSHOT";
  EventType32[EventType32["STATE_DELTA"] = 7] = "STATE_DELTA";
  EventType32[EventType32["MESSAGES_SNAPSHOT"] = 8] = "MESSAGES_SNAPSHOT";
  EventType32[EventType32["RAW"] = 9] = "RAW";
  EventType32[EventType32["CUSTOM"] = 10] = "CUSTOM";
  EventType32[EventType32["RUN_STARTED"] = 11] = "RUN_STARTED";
  EventType32[EventType32["RUN_FINISHED"] = 12] = "RUN_FINISHED";
  EventType32[EventType32["RUN_ERROR"] = 13] = "RUN_ERROR";
  EventType32[EventType32["STEP_STARTED"] = 14] = "STEP_STARTED";
  EventType32[EventType32["STEP_FINISHED"] = 15] = "STEP_FINISHED";
  EventType32[EventType32["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return EventType32;
})(EventType2 || {});
function createBaseBaseEvent() {
  return { type: 0, timestamp: void 0, rawEvent: void 0 };
}
var BaseEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.timestamp !== void 0) {
      writer.uint32(16).int64(message.timestamp);
    }
    if (message.rawEvent !== void 0) {
      Value.encode(Value.wrap(message.rawEvent), writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.rawEvent = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BaseEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseBaseEvent();
    message.type = (_a = object.type) != null ? _a : 0;
    message.timestamp = (_b = object.timestamp) != null ? _b : void 0;
    message.rawEvent = (_c = object.rawEvent) != null ? _c : void 0;
    return message;
  }
};
function createBaseTextMessageStartEvent() {
  return { baseEvent: void 0, messageId: "", role: void 0 };
}
var TextMessageStartEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.role !== void 0) {
      writer.uint32(26).string(message.role);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextMessageStartEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return TextMessageStartEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTextMessageStartEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.messageId = (_a = object.messageId) != null ? _a : "";
    message.role = (_b = object.role) != null ? _b : void 0;
    return message;
  }
};
function createBaseTextMessageContentEvent() {
  return { baseEvent: void 0, messageId: "", delta: "" };
}
var TextMessageContentEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextMessageContentEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return TextMessageContentEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTextMessageContentEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.messageId = (_a = object.messageId) != null ? _a : "";
    message.delta = (_b = object.delta) != null ? _b : "";
    return message;
  }
};
function createBaseTextMessageEndEvent() {
  return { baseEvent: void 0, messageId: "" };
}
var TextMessageEndEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== "") {
      writer.uint32(18).string(message.messageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextMessageEndEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return TextMessageEndEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseTextMessageEndEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.messageId = (_a = object.messageId) != null ? _a : "";
    return message;
  }
};
function createBaseToolCallStartEvent() {
  return { baseEvent: void 0, toolCallId: "", toolCallName: "", parentMessageId: void 0 };
}
var ToolCallStartEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.toolCallName !== "") {
      writer.uint32(26).string(message.toolCallName);
    }
    if (message.parentMessageId !== void 0) {
      writer.uint32(34).string(message.parentMessageId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCallStartEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.toolCallName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.parentMessageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCallStartEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseToolCallStartEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.toolCallId = (_a = object.toolCallId) != null ? _a : "";
    message.toolCallName = (_b = object.toolCallName) != null ? _b : "";
    message.parentMessageId = (_c = object.parentMessageId) != null ? _c : void 0;
    return message;
  }
};
function createBaseToolCallArgsEvent() {
  return { baseEvent: void 0, toolCallId: "", delta: "" };
}
var ToolCallArgsEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.delta !== "") {
      writer.uint32(26).string(message.delta);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCallArgsEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCallArgsEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseToolCallArgsEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.toolCallId = (_a = object.toolCallId) != null ? _a : "";
    message.delta = (_b = object.delta) != null ? _b : "";
    return message;
  }
};
function createBaseToolCallEndEvent() {
  return { baseEvent: void 0, toolCallId: "" };
}
var ToolCallEndEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== "") {
      writer.uint32(18).string(message.toolCallId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCallEndEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.toolCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCallEndEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseToolCallEndEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.toolCallId = (_a = object.toolCallId) != null ? _a : "";
    return message;
  }
};
function createBaseStateSnapshotEvent() {
  return { baseEvent: void 0, snapshot: void 0 };
}
var StateSnapshotEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.snapshot !== void 0) {
      Value.encode(Value.wrap(message.snapshot), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStateSnapshotEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.snapshot = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return StateSnapshotEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStateSnapshotEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.snapshot = (_a = object.snapshot) != null ? _a : void 0;
    return message;
  }
};
function createBaseStateDeltaEvent() {
  return { baseEvent: void 0, delta: [] };
}
var StateDeltaEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    for (const v of message.delta) {
      JsonPatchOperation.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStateDeltaEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.delta.push(JsonPatchOperation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return StateDeltaEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStateDeltaEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.delta = ((_a = object.delta) == null ? void 0 : _a.map((e) => JsonPatchOperation.fromPartial(e))) || [];
    return message;
  }
};
function createBaseMessagesSnapshotEvent() {
  return { baseEvent: void 0, messages: [] };
}
var MessagesSnapshotEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMessagesSnapshotEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MessagesSnapshotEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMessagesSnapshotEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.messages = ((_a = object.messages) == null ? void 0 : _a.map((e) => Message.fromPartial(e))) || [];
    return message;
  }
};
function createBaseRawEvent() {
  return { baseEvent: void 0, event: void 0, source: void 0 };
}
var RawEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.event !== void 0) {
      Value.encode(Value.wrap(message.event), writer.uint32(18).fork()).join();
    }
    if (message.source !== void 0) {
      writer.uint32(26).string(message.source);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRawEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.event = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.source = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RawEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseRawEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.event = (_a = object.event) != null ? _a : void 0;
    message.source = (_b = object.source) != null ? _b : void 0;
    return message;
  }
};
function createBaseCustomEvent() {
  return { baseEvent: void 0, name: "", value: void 0 };
}
var CustomEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.value !== void 0) {
      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCustomEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CustomEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCustomEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.name = (_a = object.name) != null ? _a : "";
    message.value = (_b = object.value) != null ? _b : void 0;
    return message;
  }
};
function createBaseRunStartedEvent() {
  return { baseEvent: void 0, threadId: "", runId: "" };
}
var RunStartedEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.threadId !== "") {
      writer.uint32(18).string(message.threadId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRunStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.threadId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.runId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RunStartedEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseRunStartedEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.threadId = (_a = object.threadId) != null ? _a : "";
    message.runId = (_b = object.runId) != null ? _b : "";
    return message;
  }
};
function createBaseRunFinishedEvent() {
  return { baseEvent: void 0, threadId: "", runId: "", result: void 0 };
}
var RunFinishedEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.threadId !== "") {
      writer.uint32(18).string(message.threadId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    if (message.result !== void 0) {
      Value.encode(Value.wrap(message.result), writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRunFinishedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.threadId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.runId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.result = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RunFinishedEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseRunFinishedEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.threadId = (_a = object.threadId) != null ? _a : "";
    message.runId = (_b = object.runId) != null ? _b : "";
    message.result = (_c = object.result) != null ? _c : void 0;
    return message;
  }
};
function createBaseRunErrorEvent() {
  return { baseEvent: void 0, code: void 0, message: "" };
}
var RunErrorEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.code !== void 0) {
      writer.uint32(18).string(message.code);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRunErrorEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.code = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RunErrorEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseRunErrorEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.code = (_a = object.code) != null ? _a : void 0;
    message.message = (_b = object.message) != null ? _b : "";
    return message;
  }
};
function createBaseStepStartedEvent() {
  return { baseEvent: void 0, stepName: "" };
}
var StepStartedEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepStartedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return StepStartedEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStepStartedEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.stepName = (_a = object.stepName) != null ? _a : "";
    return message;
  }
};
function createBaseStepFinishedEvent() {
  return { baseEvent: void 0, stepName: "" };
}
var StepFinishedEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.stepName !== "") {
      writer.uint32(18).string(message.stepName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStepFinishedEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.stepName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return StepFinishedEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStepFinishedEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.stepName = (_a = object.stepName) != null ? _a : "";
    return message;
  }
};
function createBaseTextMessageChunkEvent() {
  return { baseEvent: void 0, messageId: void 0, role: void 0, delta: void 0 };
}
var TextMessageChunkEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.messageId !== void 0) {
      writer.uint32(18).string(message.messageId);
    }
    if (message.role !== void 0) {
      writer.uint32(26).string(message.role);
    }
    if (message.delta !== void 0) {
      writer.uint32(34).string(message.delta);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTextMessageChunkEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.messageId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.role = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return TextMessageChunkEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseTextMessageChunkEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.messageId = (_a = object.messageId) != null ? _a : void 0;
    message.role = (_b = object.role) != null ? _b : void 0;
    message.delta = (_c = object.delta) != null ? _c : void 0;
    return message;
  }
};
function createBaseToolCallChunkEvent() {
  return {
    baseEvent: void 0,
    toolCallId: void 0,
    toolCallName: void 0,
    parentMessageId: void 0,
    delta: void 0
  };
}
var ToolCallChunkEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.baseEvent !== void 0) {
      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();
    }
    if (message.toolCallId !== void 0) {
      writer.uint32(18).string(message.toolCallId);
    }
    if (message.toolCallName !== void 0) {
      writer.uint32(26).string(message.toolCallName);
    }
    if (message.parentMessageId !== void 0) {
      writer.uint32(34).string(message.parentMessageId);
    }
    if (message.delta !== void 0) {
      writer.uint32(42).string(message.delta);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseToolCallChunkEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.baseEvent = BaseEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.toolCallId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.toolCallName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.parentMessageId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.delta = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ToolCallChunkEvent.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseToolCallChunkEvent();
    message.baseEvent = object.baseEvent !== void 0 && object.baseEvent !== null ? BaseEvent.fromPartial(object.baseEvent) : void 0;
    message.toolCallId = (_a = object.toolCallId) != null ? _a : void 0;
    message.toolCallName = (_b = object.toolCallName) != null ? _b : void 0;
    message.parentMessageId = (_c = object.parentMessageId) != null ? _c : void 0;
    message.delta = (_d = object.delta) != null ? _d : void 0;
    return message;
  }
};
function createBaseEvent() {
  return {
    textMessageStart: void 0,
    textMessageContent: void 0,
    textMessageEnd: void 0,
    toolCallStart: void 0,
    toolCallArgs: void 0,
    toolCallEnd: void 0,
    stateSnapshot: void 0,
    stateDelta: void 0,
    messagesSnapshot: void 0,
    raw: void 0,
    custom: void 0,
    runStarted: void 0,
    runFinished: void 0,
    runError: void 0,
    stepStarted: void 0,
    stepFinished: void 0,
    textMessageChunk: void 0,
    toolCallChunk: void 0
  };
}
var Event = {
  encode(message, writer = new BinaryWriter()) {
    if (message.textMessageStart !== void 0) {
      TextMessageStartEvent.encode(message.textMessageStart, writer.uint32(10).fork()).join();
    }
    if (message.textMessageContent !== void 0) {
      TextMessageContentEvent.encode(message.textMessageContent, writer.uint32(18).fork()).join();
    }
    if (message.textMessageEnd !== void 0) {
      TextMessageEndEvent.encode(message.textMessageEnd, writer.uint32(26).fork()).join();
    }
    if (message.toolCallStart !== void 0) {
      ToolCallStartEvent.encode(message.toolCallStart, writer.uint32(34).fork()).join();
    }
    if (message.toolCallArgs !== void 0) {
      ToolCallArgsEvent.encode(message.toolCallArgs, writer.uint32(42).fork()).join();
    }
    if (message.toolCallEnd !== void 0) {
      ToolCallEndEvent.encode(message.toolCallEnd, writer.uint32(50).fork()).join();
    }
    if (message.stateSnapshot !== void 0) {
      StateSnapshotEvent.encode(message.stateSnapshot, writer.uint32(58).fork()).join();
    }
    if (message.stateDelta !== void 0) {
      StateDeltaEvent.encode(message.stateDelta, writer.uint32(66).fork()).join();
    }
    if (message.messagesSnapshot !== void 0) {
      MessagesSnapshotEvent.encode(message.messagesSnapshot, writer.uint32(74).fork()).join();
    }
    if (message.raw !== void 0) {
      RawEvent.encode(message.raw, writer.uint32(82).fork()).join();
    }
    if (message.custom !== void 0) {
      CustomEvent.encode(message.custom, writer.uint32(90).fork()).join();
    }
    if (message.runStarted !== void 0) {
      RunStartedEvent.encode(message.runStarted, writer.uint32(98).fork()).join();
    }
    if (message.runFinished !== void 0) {
      RunFinishedEvent.encode(message.runFinished, writer.uint32(106).fork()).join();
    }
    if (message.runError !== void 0) {
      RunErrorEvent.encode(message.runError, writer.uint32(114).fork()).join();
    }
    if (message.stepStarted !== void 0) {
      StepStartedEvent.encode(message.stepStarted, writer.uint32(122).fork()).join();
    }
    if (message.stepFinished !== void 0) {
      StepFinishedEvent.encode(message.stepFinished, writer.uint32(130).fork()).join();
    }
    if (message.textMessageChunk !== void 0) {
      TextMessageChunkEvent.encode(message.textMessageChunk, writer.uint32(138).fork()).join();
    }
    if (message.toolCallChunk !== void 0) {
      ToolCallChunkEvent.encode(message.toolCallChunk, writer.uint32(146).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.textMessageStart = TextMessageStartEvent.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.textMessageContent = TextMessageContentEvent.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.textMessageEnd = TextMessageEndEvent.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.toolCallStart = ToolCallStartEvent.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.toolCallArgs = ToolCallArgsEvent.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.toolCallEnd = ToolCallEndEvent.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.stateSnapshot = StateSnapshotEvent.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.stateDelta = StateDeltaEvent.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.messagesSnapshot = MessagesSnapshotEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.raw = RawEvent.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.custom = CustomEvent.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.runStarted = RunStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.runFinished = RunFinishedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.runError = RunErrorEvent.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.stepStarted = StepStartedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.stepFinished = StepFinishedEvent.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.textMessageChunk = TextMessageChunkEvent.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.toolCallChunk = ToolCallChunkEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Event.fromPartial(base != null ? base : {});
  },
  fromPartial(object) {
    const message = createBaseEvent();
    message.textMessageStart = object.textMessageStart !== void 0 && object.textMessageStart !== null ? TextMessageStartEvent.fromPartial(object.textMessageStart) : void 0;
    message.textMessageContent = object.textMessageContent !== void 0 && object.textMessageContent !== null ? TextMessageContentEvent.fromPartial(object.textMessageContent) : void 0;
    message.textMessageEnd = object.textMessageEnd !== void 0 && object.textMessageEnd !== null ? TextMessageEndEvent.fromPartial(object.textMessageEnd) : void 0;
    message.toolCallStart = object.toolCallStart !== void 0 && object.toolCallStart !== null ? ToolCallStartEvent.fromPartial(object.toolCallStart) : void 0;
    message.toolCallArgs = object.toolCallArgs !== void 0 && object.toolCallArgs !== null ? ToolCallArgsEvent.fromPartial(object.toolCallArgs) : void 0;
    message.toolCallEnd = object.toolCallEnd !== void 0 && object.toolCallEnd !== null ? ToolCallEndEvent.fromPartial(object.toolCallEnd) : void 0;
    message.stateSnapshot = object.stateSnapshot !== void 0 && object.stateSnapshot !== null ? StateSnapshotEvent.fromPartial(object.stateSnapshot) : void 0;
    message.stateDelta = object.stateDelta !== void 0 && object.stateDelta !== null ? StateDeltaEvent.fromPartial(object.stateDelta) : void 0;
    message.messagesSnapshot = object.messagesSnapshot !== void 0 && object.messagesSnapshot !== null ? MessagesSnapshotEvent.fromPartial(object.messagesSnapshot) : void 0;
    message.raw = object.raw !== void 0 && object.raw !== null ? RawEvent.fromPartial(object.raw) : void 0;
    message.custom = object.custom !== void 0 && object.custom !== null ? CustomEvent.fromPartial(object.custom) : void 0;
    message.runStarted = object.runStarted !== void 0 && object.runStarted !== null ? RunStartedEvent.fromPartial(object.runStarted) : void 0;
    message.runFinished = object.runFinished !== void 0 && object.runFinished !== null ? RunFinishedEvent.fromPartial(object.runFinished) : void 0;
    message.runError = object.runError !== void 0 && object.runError !== null ? RunErrorEvent.fromPartial(object.runError) : void 0;
    message.stepStarted = object.stepStarted !== void 0 && object.stepStarted !== null ? StepStartedEvent.fromPartial(object.stepStarted) : void 0;
    message.stepFinished = object.stepFinished !== void 0 && object.stepFinished !== null ? StepFinishedEvent.fromPartial(object.stepFinished) : void 0;
    message.textMessageChunk = object.textMessageChunk !== void 0 && object.textMessageChunk !== null ? TextMessageChunkEvent.fromPartial(object.textMessageChunk) : void 0;
    message.toolCallChunk = object.toolCallChunk !== void 0 && object.toolCallChunk !== null ? ToolCallChunkEvent.fromPartial(object.toolCallChunk) : void 0;
    return message;
  }
};
function longToNumber(int64) {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}
function decode(data) {
  var _a;
  const event = Event.decode(data);
  const decoded = Object.values(event).find((value) => value !== void 0);
  if (!decoded) {
    throw new Error("Invalid event");
  }
  decoded.type = EventType2[decoded.baseEvent.type];
  decoded.timestamp = decoded.baseEvent.timestamp;
  decoded.rawEvent = decoded.baseEvent.rawEvent;
  if (decoded.type === EventType.MESSAGES_SNAPSHOT) {
    for (const message of decoded.messages) {
      const untypedMessage = message;
      if (((_a = untypedMessage.toolCalls) == null ? void 0 : _a.length) === 0) {
        untypedMessage.toolCalls = void 0;
      }
    }
  }
  if (decoded.type === EventType.STATE_DELTA) {
    for (const operation of decoded.delta) {
      operation.op = JsonPatchOperationType[operation.op].toLowerCase();
      Object.keys(operation).forEach((key) => {
        if (operation[key] === void 0) {
          delete operation[key];
        }
      });
    }
  }
  Object.keys(decoded).forEach((key) => {
    if (decoded[key] === void 0) {
      delete decoded[key];
    }
  });
  return EventSchemas.parse(decoded);
}
var AGUI_MEDIA_TYPE = "application/vnd.ag-ui.event+proto";

// node_modules/compare-versions/lib/esm/utils.js
var semver = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
var validateAndParse = (version) => {
  if (typeof version !== "string") {
    throw new TypeError("Invalid argument expected string");
  }
  const match = version.match(semver);
  if (!match) {
    throw new Error(`Invalid argument not valid semver ('${version}' received)`);
  }
  match.shift();
  return match;
};
var isWildcard = (s) => s === "*" || s === "x" || s === "X";
var tryParse = (v) => {
  const n = parseInt(v, 10);
  return isNaN(n) ? v : n;
};
var forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];
var compareStrings = (a, b) => {
  if (isWildcard(a) || isWildcard(b))
    return 0;
  const [ap, bp] = forceType(tryParse(a), tryParse(b));
  if (ap > bp)
    return 1;
  if (ap < bp)
    return -1;
  return 0;
};
var compareSegments = (a, b) => {
  for (let i = 0; i < Math.max(a.length, b.length); i++) {
    const r = compareStrings(a[i] || "0", b[i] || "0");
    if (r !== 0)
      return r;
  }
  return 0;
};

// node_modules/compare-versions/lib/esm/compareVersions.js
var compareVersions = (v1, v2) => {
  const n1 = validateAndParse(v1);
  const n2 = validateAndParse(v2);
  const p1 = n1.pop();
  const p2 = n2.pop();
  const r = compareSegments(n1, n2);
  if (r !== 0)
    return r;
  if (p1 && p2) {
    return compareSegments(p1.split("."), p2.split("."));
  } else if (p1 || p2) {
    return p1 ? -1 : 1;
  }
  return 0;
};

// node_modules/compare-versions/lib/esm/compare.js
var operatorResMap = {
  ">": [1],
  ">=": [0, 1],
  "=": [0],
  "<=": [-1, 0],
  "<": [-1],
  "!=": [-1, 1]
};
var allowedOperators = Object.keys(operatorResMap);

// node_modules/@copilotkitnext/core/node_modules/@ag-ui/client/dist/index.mjs
var xt = Object.defineProperty;
var _t = Object.defineProperties;
var Nt = Object.getOwnPropertyDescriptors;
var Y = Object.getOwnPropertySymbols;
var it = Object.prototype.hasOwnProperty;
var lt = Object.prototype.propertyIsEnumerable;
var rt = (l, a, e) => a in l ? xt(l, a, { enumerable: true, configurable: true, writable: true, value: e }) : l[a] = e;
var N = (l, a) => {
  for (var e in a || (a = {})) it.call(a, e) && rt(l, e, a[e]);
  if (Y) for (var e of Y(a)) lt.call(a, e) && rt(l, e, a[e]);
  return l;
};
var G = (l, a) => _t(l, Nt(a));
var gt = (l, a) => {
  var e = {};
  for (var n in l) it.call(l, n) && a.indexOf(n) < 0 && (e[n] = l[n]);
  if (l != null && Y) for (var n of Y(l)) a.indexOf(n) < 0 && lt.call(l, n) && (e[n] = l[n]);
  return e;
};
var y = (l) => {
  if (typeof structuredClone == "function") return structuredClone(l);
  try {
    return JSON.parse(JSON.stringify(l));
  } catch (a) {
    return N({}, l);
  }
};
async function x(l, a, e, n) {
  let t = a, s = e, r;
  for (let o of l) try {
    let i = await n(o, y(t), y(s));
    if (i === void 0) continue;
    if (i.messages !== void 0 && (t = i.messages), i.state !== void 0 && (s = i.state), r = i.stopPropagation, r === true) break;
  } catch (i) {
    process.env.JEST_WORKER_ID !== void 0 || console.error("Subscriber error:", i);
    continue;
  }
  return N(N(N({}, JSON.stringify(t) !== JSON.stringify(a) ? { messages: t } : {}), JSON.stringify(s) !== JSON.stringify(e) ? { state: s } : {}), r !== void 0 ? { stopPropagation: r } : {});
}
var $ = (l, a, e, n) => {
  let t = y(e.messages), s = y(l.state), r = {}, o = (d) => {
    d.messages !== void 0 && (t = d.messages, r.messages = d.messages), d.state !== void 0 && (s = d.state, r.state = d.state);
  }, i = () => {
    let d = y(r);
    return r = {}, d.messages !== void 0 || d.state !== void 0 ? of(d) : EMPTY;
  };
  return a.pipe(concatMap(async (d) => {
    var T, v, c, b, U;
    let I = await x(n, t, s, (E, g, p) => {
      var m;
      return (m = E.onEvent) == null ? void 0 : m.call(E, { event: d, agent: e, input: l, messages: g, state: p });
    });
    if (o(I), I.stopPropagation === true) return i();
    switch (d.type) {
      case EventType.TEXT_MESSAGE_START: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onTextMessageStartEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { messageId: g, role: p = "assistant" } = d, m = { id: g, role: p, content: "" };
          t.push(m), o({ messages: t });
        }
        return i();
      }
      case EventType.TEXT_MESSAGE_CONTENT: {
        let { messageId: E, delta: g } = d, p = t.find((u) => u.id === E);
        if (!p) return console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${E}'`), i();
        let m = await x(n, t, s, (u, A, h) => {
          var _;
          return (_ = u.onTextMessageContentEvent) == null ? void 0 : _.call(u, { event: d, messages: A, state: h, agent: e, input: l, textMessageBuffer: typeof p.content == "string" ? p.content : "" });
        });
        if (o(m), m.stopPropagation !== true) {
          let u = typeof p.content == "string" ? p.content : "";
          p.content = `${u}${g}`, o({ messages: t });
        }
        return i();
      }
      case EventType.TEXT_MESSAGE_END: {
        let { messageId: E } = d, g = t.find((m) => m.id === E);
        if (!g) return console.warn(`TEXT_MESSAGE_END: No message found with ID '${E}'`), i();
        let p = await x(n, t, s, (m, u, A) => {
          var h;
          return (h = m.onTextMessageEndEvent) == null ? void 0 : h.call(m, { event: d, messages: u, state: A, agent: e, input: l, textMessageBuffer: typeof g.content == "string" ? g.content : "" });
        });
        return o(p), await Promise.all(n.map((m) => {
          var u;
          (u = m.onNewMessage) == null || u.call(m, { message: g, messages: t, state: s, agent: e, input: l });
        })), i();
      }
      case EventType.TOOL_CALL_START: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onToolCallStartEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { toolCallId: g, toolCallName: p, parentMessageId: m } = d, u;
          m && t.length > 0 && t[t.length - 1].id === m ? u = t[t.length - 1] : (u = { id: m || g, role: "assistant", toolCalls: [] }, t.push(u)), (T = u.toolCalls) != null || (u.toolCalls = []), u.toolCalls.push({ id: g, type: "function", function: { name: p, arguments: "" } }), o({ messages: t });
        }
        return i();
      }
      case EventType.TOOL_CALL_ARGS: {
        let { toolCallId: E, delta: g } = d, p = t.find((A) => {
          var h;
          return (h = A.toolCalls) == null ? void 0 : h.some((_) => _.id === E);
        });
        if (!p) return console.warn(`TOOL_CALL_ARGS: No message found containing tool call with ID '${E}'`), i();
        let m = p.toolCalls.find((A) => A.id === E);
        if (!m) return console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${E}'`), i();
        let u = await x(n, t, s, (A, h, _) => {
          var Z;
          let H = m.function.arguments, F = m.function.name, X = {};
          try {
            X = untruncateJson(H);
          } catch (ye) {
          }
          return (Z = A.onToolCallArgsEvent) == null ? void 0 : Z.call(A, { event: d, messages: h, state: _, agent: e, input: l, toolCallBuffer: H, toolCallName: F, partialToolCallArgs: X });
        });
        return o(u), u.stopPropagation !== true && (m.function.arguments += g, o({ messages: t })), i();
      }
      case EventType.TOOL_CALL_END: {
        let { toolCallId: E } = d, g = t.find((u) => {
          var A;
          return (A = u.toolCalls) == null ? void 0 : A.some((h) => h.id === E);
        });
        if (!g) return console.warn(`TOOL_CALL_END: No message found containing tool call with ID '${E}'`), i();
        let p = g.toolCalls.find((u) => u.id === E);
        if (!p) return console.warn(`TOOL_CALL_END: No tool call found with ID '${E}'`), i();
        let m = await x(n, t, s, (u, A, h) => {
          var X;
          let _ = p.function.arguments, H = p.function.name, F = {};
          try {
            F = JSON.parse(_);
          } catch (Z) {
          }
          return (X = u.onToolCallEndEvent) == null ? void 0 : X.call(u, { event: d, messages: A, state: h, agent: e, input: l, toolCallName: H, toolCallArgs: F });
        });
        return o(m), await Promise.all(n.map((u) => {
          var A;
          (A = u.onNewToolCall) == null || A.call(u, { toolCall: p, messages: t, state: s, agent: e, input: l });
        })), i();
      }
      case EventType.TOOL_CALL_RESULT: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onToolCallResultEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { messageId: g, toolCallId: p, content: m, role: u } = d, A = { id: g, toolCallId: p, role: u || "tool", content: m };
          t.push(A), await Promise.all(n.map((h) => {
            var _;
            (_ = h.onNewMessage) == null || _.call(h, { message: A, messages: t, state: s, agent: e, input: l });
          })), o({ messages: t });
        }
        return i();
      }
      case EventType.STATE_SNAPSHOT: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onStateSnapshotEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { snapshot: g } = d;
          s = g, o({ state: s });
        }
        return i();
      }
      case EventType.STATE_DELTA: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onStateDeltaEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { delta: g } = d;
          try {
            s = applyPatch(s, g, true, false).newDocument, o({ state: s });
          } catch (p) {
            let m = p instanceof Error ? p.message : String(p);
            console.warn(`Failed to apply state patch:
Current state: ${JSON.stringify(s, null, 2)}
Patch operations: ${JSON.stringify(g, null, 2)}
Error: ${m}`);
          }
        }
        return i();
      }
      case EventType.MESSAGES_SNAPSHOT: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onMessagesSnapshotEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let { messages: g } = d;
          t = g, o({ messages: t });
        }
        return i();
      }
      case EventType.ACTIVITY_SNAPSHOT: {
        let E = d, g = t.findIndex((h) => h.id === E.messageId), p = g >= 0 ? t[g] : void 0, m = (p == null ? void 0 : p.role) === "activity" ? p : void 0, u = (v = E.replace) != null ? v : true, A = await x(n, t, s, (h, _, H) => {
          var F;
          return (F = h.onActivitySnapshotEvent) == null ? void 0 : F.call(h, { event: E, messages: _, state: H, agent: e, input: l, activityMessage: m, existingMessage: p });
        });
        if (o(A), A.stopPropagation !== true) {
          let h = { id: E.messageId, role: "activity", activityType: E.activityType, content: y(E.content) }, _;
          g === -1 ? (t.push(h), _ = h) : m ? u && (t[g] = G(N({}, m), { activityType: E.activityType, content: y(E.content) })) : u && (t[g] = h, _ = h), o({ messages: t }), _ && await Promise.all(n.map((H) => {
            var F;
            return (F = H.onNewMessage) == null ? void 0 : F.call(H, { message: _, messages: t, state: s, agent: e, input: l });
          }));
        }
        return i();
      }
      case EventType.ACTIVITY_DELTA: {
        let E = d, g = t.findIndex((A) => A.id === E.messageId);
        if (g === -1) return console.warn(`ACTIVITY_DELTA: No message found with ID '${E.messageId}' to apply patch`), i();
        let p = t[g];
        if (p.role !== "activity") return console.warn(`ACTIVITY_DELTA: Message '${E.messageId}' is not an activity message`), i();
        let m = p, u = await x(n, t, s, (A, h, _) => {
          var H;
          return (H = A.onActivityDeltaEvent) == null ? void 0 : H.call(A, { event: E, messages: h, state: _, agent: e, input: l, activityMessage: m });
        });
        if (o(u), u.stopPropagation !== true) try {
          let A = y((c = m.content) != null ? c : {}), _ = applyPatch(A, (b = E.patch) != null ? b : [], true, false).newDocument;
          t[g] = G(N({}, m), { content: y(_), activityType: E.activityType }), o({ messages: t });
        } catch (A) {
          let h = A instanceof Error ? A.message : String(A);
          console.warn(`Failed to apply activity patch for '${E.messageId}': ${h}`);
        }
        return i();
      }
      case EventType.RAW: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onRawEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        return o(E), i();
      }
      case EventType.CUSTOM: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onCustomEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        return o(E), i();
      }
      case EventType.RUN_STARTED: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onRunStartedEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        if (o(E), E.stopPropagation !== true) {
          let g = d;
          if ((U = g.input) != null && U.messages) {
            for (let p of g.input.messages) t.find((u) => u.id === p.id) || t.push(p);
            o({ messages: t });
          }
        }
        return i();
      }
      case EventType.RUN_FINISHED: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onRunFinishedEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l, result: d.result });
        });
        return o(E), i();
      }
      case EventType.RUN_ERROR: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onRunErrorEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        return o(E), i();
      }
      case EventType.STEP_STARTED: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onStepStartedEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        return o(E), i();
      }
      case EventType.STEP_FINISHED: {
        let E = await x(n, t, s, (g, p, m) => {
          var u;
          return (u = g.onStepFinishedEvent) == null ? void 0 : u.call(g, { event: d, messages: p, state: m, agent: e, input: l });
        });
        return o(E), i();
      }
      case EventType.TEXT_MESSAGE_CHUNK:
        throw new Error("TEXT_MESSAGE_CHUNK must be tranformed before being applied");
      case EventType.TOOL_CALL_CHUNK:
        throw new Error("TOOL_CALL_CHUNK must be tranformed before being applied");
      case EventType.THINKING_START:
        return i();
      case EventType.THINKING_END:
        return i();
      case EventType.THINKING_TEXT_MESSAGE_START:
        return i();
      case EventType.THINKING_TEXT_MESSAGE_CONTENT:
        return i();
      case EventType.THINKING_TEXT_MESSAGE_END:
        return i();
    }
    let S = d.type;
    return i();
  }), mergeAll(), n.length > 0 ? defaultIfEmpty({}) : (d) => d);
};
var z = (l) => (a) => {
  let e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), t = false, s = false, r = false, o = /* @__PURE__ */ new Map(), i = false, d = false, I = false, S = () => {
    e.clear(), n.clear(), o.clear(), i = false, d = false, t = false, s = false, I = true;
  };
  return a.pipe(mergeMap((T) => {
    let v = T.type;
    if (l && console.debug("[VERIFY]:", JSON.stringify(T)), s) return throwError(() => new AGUIError(`Cannot send event type '${v}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`));
    if (t && v !== EventType.RUN_ERROR && v !== EventType.RUN_STARTED) return throwError(() => new AGUIError(`Cannot send event type '${v}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`));
    if (r) {
      if (v === EventType.RUN_STARTED) {
        if (I && !t) return throwError(() => new AGUIError("Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run."));
        t && S();
      }
    } else if (r = true, v !== EventType.RUN_STARTED && v !== EventType.RUN_ERROR) return throwError(() => new AGUIError("First event must be 'RUN_STARTED'"));
    switch (v) {
      case EventType.TEXT_MESSAGE_START: {
        let c = T.messageId;
        return e.has(c) ? throwError(() => new AGUIError(`Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${c}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`)) : (e.set(c, true), of(T));
      }
      case EventType.TEXT_MESSAGE_CONTENT: {
        let c = T.messageId;
        return e.has(c) ? of(T) : throwError(() => new AGUIError(`Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${c}'. Start a text message with 'TEXT_MESSAGE_START' first.`));
      }
      case EventType.TEXT_MESSAGE_END: {
        let c = T.messageId;
        return e.has(c) ? (e.delete(c), of(T)) : throwError(() => new AGUIError(`Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${c}'. A 'TEXT_MESSAGE_START' event must be sent first.`));
      }
      case EventType.TOOL_CALL_START: {
        let c = T.toolCallId;
        return n.has(c) ? throwError(() => new AGUIError(`Cannot send 'TOOL_CALL_START' event: A tool call with ID '${c}' is already in progress. Complete it with 'TOOL_CALL_END' first.`)) : (n.set(c, true), of(T));
      }
      case EventType.TOOL_CALL_ARGS: {
        let c = T.toolCallId;
        return n.has(c) ? of(T) : throwError(() => new AGUIError(`Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${c}'. Start a tool call with 'TOOL_CALL_START' first.`));
      }
      case EventType.TOOL_CALL_END: {
        let c = T.toolCallId;
        return n.has(c) ? (n.delete(c), of(T)) : throwError(() => new AGUIError(`Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${c}'. A 'TOOL_CALL_START' event must be sent first.`));
      }
      case EventType.STEP_STARTED: {
        let c = T.stepName;
        return o.has(c) ? throwError(() => new AGUIError(`Step "${c}" is already active for 'STEP_STARTED'`)) : (o.set(c, true), of(T));
      }
      case EventType.STEP_FINISHED: {
        let c = T.stepName;
        return o.has(c) ? (o.delete(c), of(T)) : throwError(() => new AGUIError(`Cannot send 'STEP_FINISHED' for step "${c}" that was not started`));
      }
      case EventType.RUN_STARTED:
        return I = true, of(T);
      case EventType.RUN_FINISHED: {
        if (o.size > 0) {
          let c = Array.from(o.keys()).join(", ");
          return throwError(() => new AGUIError(`Cannot send 'RUN_FINISHED' while steps are still active: ${c}`));
        }
        if (e.size > 0) {
          let c = Array.from(e.keys()).join(", ");
          return throwError(() => new AGUIError(`Cannot send 'RUN_FINISHED' while text messages are still active: ${c}`));
        }
        if (n.size > 0) {
          let c = Array.from(n.keys()).join(", ");
          return throwError(() => new AGUIError(`Cannot send 'RUN_FINISHED' while tool calls are still active: ${c}`));
        }
        return t = true, of(T);
      }
      case EventType.RUN_ERROR:
        return s = true, of(T);
      case EventType.CUSTOM:
        return of(T);
      case EventType.THINKING_TEXT_MESSAGE_START:
        return i ? d ? throwError(() => new AGUIError("Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.")) : (d = true, of(T)) : throwError(() => new AGUIError("Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first."));
      case EventType.THINKING_TEXT_MESSAGE_CONTENT:
        return d ? of(T) : throwError(() => new AGUIError("Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first."));
      case EventType.THINKING_TEXT_MESSAGE_END:
        return d ? (d = false, of(T)) : throwError(() => new AGUIError("Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first."));
      case EventType.THINKING_START:
        return i ? throwError(() => new AGUIError("Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.")) : (i = true, of(T));
      case EventType.THINKING_END:
        return i ? (i = false, of(T)) : throwError(() => new AGUIError("Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first."));
      default:
        return of(T);
    }
  }));
};
var tt = (l, a) => defer(() => from(fetch(l, a))).pipe(switchMap((e) => {
  var s;
  if (!e.ok) {
    let r = e.headers.get("content-type") || "";
    return from(e.text()).pipe(mergeMap((o) => {
      let i = o;
      if (r.includes("application/json")) try {
        i = JSON.parse(o);
      } catch (I) {
      }
      let d = new Error(`HTTP ${e.status}: ${typeof i == "string" ? i : JSON.stringify(i)}`);
      return d.status = e.status, d.payload = i, throwError(() => d);
    }));
  }
  let n = { type: "headers", status: e.status, headers: e.headers }, t = (s = e.body) == null ? void 0 : s.getReader();
  return t ? new Observable((r) => (r.next(n), (async () => {
    try {
      for (; ; ) {
        let { done: o, value: i } = await t.read();
        if (o) break;
        let d = { type: "data", data: i };
        r.next(d);
      }
      r.complete();
    } catch (o) {
      r.error(o);
    }
  })(), () => {
    t.cancel().catch((o) => {
      if ((o == null ? void 0 : o.name) !== "AbortError") throw o;
    });
  })) : throwError(() => new Error("Failed to getReader() from response"));
}));
var et = (l) => {
  let a = new Subject(), e = new TextDecoder("utf-8", { fatal: false }), n = "";
  l.subscribe({ next: (s) => {
    if (s.type !== "headers" && s.type === "data" && s.data) {
      let r = e.decode(s.data, { stream: true });
      n += r;
      let o = n.split(/\n\n/);
      n = o.pop() || "";
      for (let i of o) t(i);
    }
  }, error: (s) => a.error(s), complete: () => {
    n && (n += e.decode(), t(n)), a.complete();
  } });
  function t(s) {
    let r = s.split(`
`), o = [];
    for (let i of r) i.startsWith("data: ") && o.push(i.slice(6));
    if (o.length > 0) try {
      let i = o.join(`
`), d = JSON.parse(i);
      a.next(d);
    } catch (i) {
      a.error(i);
    }
  }
  return a.asObservable();
};
var nt = (l) => {
  let a = new Subject(), e = new Uint8Array(0);
  l.subscribe({ next: (t) => {
    if (t.type !== "headers" && t.type === "data" && t.data) {
      let s = new Uint8Array(e.length + t.data.length);
      s.set(e, 0), s.set(t.data, e.length), e = s, n();
    }
  }, error: (t) => a.error(t), complete: () => {
    if (e.length > 0) try {
      n();
    } catch (t) {
      console.warn("Incomplete or invalid protocol buffer data at stream end");
    }
    a.complete();
  } });
  function n() {
    for (; e.length >= 4; ) {
      let r = 4 + new DataView(e.buffer, e.byteOffset, 4).getUint32(0, false);
      if (e.length < r) break;
      try {
        let o = e.slice(4, r), i = decode(o);
        a.next(i), e = e.slice(r);
      } catch (o) {
        let i = o instanceof Error ? o.message : String(o);
        a.error(new Error(`Failed to decode protocol buffer message: ${i}`));
        return;
      }
    }
  }
  return a.asObservable();
};
var st = (l) => {
  let a = new Subject(), e = new ReplaySubject(), n = false;
  return l.subscribe({ next: (t) => {
    e.next(t), t.type === "headers" && !n ? (n = true, t.headers.get("content-type") === AGUI_MEDIA_TYPE ? nt(e).subscribe({ next: (r) => a.next(r), error: (r) => a.error(r), complete: () => a.complete() }) : et(e).subscribe({ next: (r) => {
      try {
        let o = EventSchemas.parse(r);
        a.next(o);
      } catch (o) {
        a.error(o);
      }
    }, error: (r) => {
      if ((r == null ? void 0 : r.name) === "AbortError") {
        a.next({ type: EventType.RUN_ERROR, rawEvent: r }), a.complete();
        return;
      }
      return a.error(r);
    }, complete: () => a.complete() })) : n || a.error(new Error("No headers event received before data events"));
  }, error: (t) => {
    e.error(t), a.error(t);
  }, complete: () => {
    e.complete();
  } }), a.asObservable();
};
var C = external_exports.enum(["TextMessageStart", "TextMessageContent", "TextMessageEnd", "ActionExecutionStart", "ActionExecutionArgs", "ActionExecutionEnd", "ActionExecutionResult", "AgentStateMessage", "MetaEvent", "RunStarted", "RunFinished", "RunError", "NodeStarted", "NodeFinished"]);
var Vt = external_exports.enum(["LangGraphInterruptEvent", "PredictState", "Exit"]);
var Wt = external_exports.object({ type: external_exports.literal(C.enum.TextMessageStart), messageId: external_exports.string(), parentMessageId: external_exports.string().optional(), role: external_exports.string().optional() });
var Yt = external_exports.object({ type: external_exports.literal(C.enum.TextMessageContent), messageId: external_exports.string(), content: external_exports.string() });
var qt = external_exports.object({ type: external_exports.literal(C.enum.TextMessageEnd), messageId: external_exports.string() });
var Qt = external_exports.object({ type: external_exports.literal(C.enum.ActionExecutionStart), actionExecutionId: external_exports.string(), actionName: external_exports.string(), parentMessageId: external_exports.string().optional() });
var Zt = external_exports.object({ type: external_exports.literal(C.enum.ActionExecutionArgs), actionExecutionId: external_exports.string(), args: external_exports.string() });
var te = external_exports.object({ type: external_exports.literal(C.enum.ActionExecutionEnd), actionExecutionId: external_exports.string() });
var ee = external_exports.object({ type: external_exports.literal(C.enum.ActionExecutionResult), actionName: external_exports.string(), actionExecutionId: external_exports.string(), result: external_exports.string() });
var ne = external_exports.object({ type: external_exports.literal(C.enum.AgentStateMessage), threadId: external_exports.string(), agentName: external_exports.string(), nodeName: external_exports.string(), runId: external_exports.string(), active: external_exports.boolean(), role: external_exports.string(), state: external_exports.string(), running: external_exports.boolean() });
var se = external_exports.object({ type: external_exports.literal(C.enum.MetaEvent), name: Vt, value: external_exports.any() });
var ae = external_exports.object({ type: external_exports.literal(C.enum.RunError), message: external_exports.string(), code: external_exports.string().optional() });
var Qn = external_exports.discriminatedUnion("type", [Wt, Yt, qt, Qt, Zt, te, ee, ne, se, ae]);
var Zn = external_exports.object({ id: external_exports.string(), role: external_exports.string(), content: external_exports.string(), parentMessageId: external_exports.string().optional() });
var ts = external_exports.object({ id: external_exports.string(), name: external_exports.string(), arguments: external_exports.any(), parentMessageId: external_exports.string().optional() });
var es = external_exports.object({ id: external_exports.string(), result: external_exports.any(), actionExecutionId: external_exports.string(), actionName: external_exports.string() });
var le = (l) => {
  if (typeof l == "string") return l;
  if (!Array.isArray(l)) return;
  let a = l.filter((e) => e.type === "text").map((e) => e.text).filter((e) => e.length > 0);
  if (a.length !== 0) return a.join(`
`);
};
var at = (l, a, e) => (n) => {
  let t = {}, s = true, r = true, o = "", i = null, d = null, I = [], S = {}, T = (v) => {
    typeof v == "object" && v !== null && ("messages" in v && delete v.messages, t = v);
  };
  return n.pipe(mergeMap((v) => {
    switch (v.type) {
      case EventType.TEXT_MESSAGE_START: {
        let c = v;
        return [{ type: C.enum.TextMessageStart, messageId: c.messageId, role: c.role }];
      }
      case EventType.TEXT_MESSAGE_CONTENT: {
        let c = v;
        return [{ type: C.enum.TextMessageContent, messageId: c.messageId, content: c.delta }];
      }
      case EventType.TEXT_MESSAGE_END: {
        let c = v;
        return [{ type: C.enum.TextMessageEnd, messageId: c.messageId }];
      }
      case EventType.TOOL_CALL_START: {
        let c = v;
        return I.push({ id: c.toolCallId, type: "function", function: { name: c.toolCallName, arguments: "" } }), r = true, S[c.toolCallId] = c.toolCallName, [{ type: C.enum.ActionExecutionStart, actionExecutionId: c.toolCallId, actionName: c.toolCallName, parentMessageId: c.parentMessageId }];
      }
      case EventType.TOOL_CALL_ARGS: {
        let c = v, b = I.find((E) => E.id === c.toolCallId);
        if (!b) return console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${c.toolCallId}'`), [];
        b.function.arguments += c.delta;
        let U = false;
        if (d) {
          let E = d.find((g) => g.tool == b.function.name);
          if (E) try {
            let g = JSON.parse(untruncateJson(b.function.arguments));
            E.tool_argument && E.tool_argument in g ? (T(G(N({}, t), { [E.state_key]: g[E.tool_argument] })), U = true) : E.tool_argument || (T(G(N({}, t), { [E.state_key]: g })), U = true);
          } catch (g) {
          }
        }
        return [{ type: C.enum.ActionExecutionArgs, actionExecutionId: c.toolCallId, args: c.delta }, ...U ? [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(t), active: r }] : []];
      }
      case EventType.TOOL_CALL_END: {
        let c = v;
        return [{ type: C.enum.ActionExecutionEnd, actionExecutionId: c.toolCallId }];
      }
      case EventType.TOOL_CALL_RESULT: {
        let c = v;
        return [{ type: C.enum.ActionExecutionResult, actionExecutionId: c.toolCallId, result: c.content, actionName: S[c.toolCallId] || "unknown" }];
      }
      case EventType.RAW:
        return [];
      case EventType.CUSTOM: {
        let c = v;
        switch (c.name) {
          case "Exit":
            s = false;
            break;
          case "PredictState":
            d = c.value;
            break;
        }
        return [{ type: C.enum.MetaEvent, name: c.name, value: c.value }];
      }
      case EventType.STATE_SNAPSHOT:
        return T(v.snapshot), [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(t), active: r }];
      case EventType.STATE_DELTA: {
        let b = applyPatch(t, v.delta, true, false);
        return b ? (T(b.newDocument), [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(t), active: r }]) : [];
      }
      case EventType.MESSAGES_SNAPSHOT:
        return i = v.messages, [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(N(N({}, t), i ? { messages: i } : {})), active: true }];
      case EventType.RUN_STARTED:
        return [];
      case EventType.RUN_FINISHED:
        return i && (t.messages = i), Object.keys(t).length === 0 ? [] : [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(N(N({}, t), i ? { messages: ge(i) } : {})), active: false }];
      case EventType.RUN_ERROR: {
        let c = v;
        return [{ type: C.enum.RunError, message: c.message, code: c.code }];
      }
      case EventType.STEP_STARTED:
        return o = v.stepName, I = [], d = null, [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(t), active: true }];
      case EventType.STEP_FINISHED:
        return I = [], d = null, [{ type: C.enum.AgentStateMessage, threadId: l, agentName: e, nodeName: o, runId: a, running: s, role: "assistant", state: JSON.stringify(t), active: false }];
      default:
        return [];
    }
  }));
};
function ge(l) {
  var e;
  let a = [];
  for (let n of l) if (n.role === "assistant" || n.role === "user" || n.role === "system") {
    let t = le(n.content);
    if (t) {
      let s = { id: n.id, role: n.role, content: t };
      a.push(s);
    }
    if (n.role === "assistant" && n.toolCalls && n.toolCalls.length > 0) for (let s of n.toolCalls) {
      let r = { id: s.id, name: s.function.name, arguments: JSON.parse(s.function.arguments), parentMessageId: n.id };
      a.push(r);
    }
  } else if (n.role === "tool") {
    let t = "unknown";
    for (let r of l) if (r.role === "assistant" && ((e = r.toolCalls) != null && e.length)) {
      for (let o of r.toolCalls) if (o.id === n.toolCallId) {
        t = o.function.name;
        break;
      }
    }
    let s = { id: n.id, result: n.content, actionExecutionId: n.toolCallId, actionName: t };
    a.push(s);
  }
  return a;
}
var j = (l) => (a) => {
  let e, n, t, s = () => {
    if (!e || t !== "text") throw new Error("No text message to close");
    let i = { type: EventType.TEXT_MESSAGE_END, messageId: e.messageId };
    return t = void 0, e = void 0, l && console.debug("[TRANSFORM]: TEXT_MESSAGE_END", JSON.stringify(i)), i;
  }, r = () => {
    if (!n || t !== "tool") throw new Error("No tool call to close");
    let i = { type: EventType.TOOL_CALL_END, toolCallId: n.toolCallId };
    return t = void 0, n = void 0, l && console.debug("[TRANSFORM]: TOOL_CALL_END", JSON.stringify(i)), i;
  }, o = () => t === "text" ? [s()] : t === "tool" ? [r()] : [];
  return a.pipe(mergeMap((i) => {
    switch (i.type) {
      case EventType.TEXT_MESSAGE_START:
      case EventType.TEXT_MESSAGE_CONTENT:
      case EventType.TEXT_MESSAGE_END:
      case EventType.TOOL_CALL_START:
      case EventType.TOOL_CALL_ARGS:
      case EventType.TOOL_CALL_END:
      case EventType.TOOL_CALL_RESULT:
      case EventType.STATE_SNAPSHOT:
      case EventType.STATE_DELTA:
      case EventType.MESSAGES_SNAPSHOT:
      case EventType.CUSTOM:
      case EventType.RUN_STARTED:
      case EventType.RUN_FINISHED:
      case EventType.RUN_ERROR:
      case EventType.STEP_STARTED:
      case EventType.STEP_FINISHED:
      case EventType.THINKING_START:
      case EventType.THINKING_END:
      case EventType.THINKING_TEXT_MESSAGE_START:
      case EventType.THINKING_TEXT_MESSAGE_CONTENT:
      case EventType.THINKING_TEXT_MESSAGE_END:
        return [...o(), i];
      case EventType.RAW:
      case EventType.ACTIVITY_SNAPSHOT:
      case EventType.ACTIVITY_DELTA:
        return [i];
      case EventType.TEXT_MESSAGE_CHUNK:
        let I = i, S = [];
        if ((t !== "text" || I.messageId !== void 0 && I.messageId !== (e == null ? void 0 : e.messageId)) && S.push(...o()), t !== "text") {
          if (I.messageId === void 0) throw new Error("First TEXT_MESSAGE_CHUNK must have a messageId");
          e = { messageId: I.messageId }, t = "text";
          let c = { type: EventType.TEXT_MESSAGE_START, messageId: I.messageId, role: I.role || "assistant" };
          S.push(c), l && console.debug("[TRANSFORM]: TEXT_MESSAGE_START", JSON.stringify(c));
        }
        if (I.delta !== void 0) {
          let c = { type: EventType.TEXT_MESSAGE_CONTENT, messageId: e.messageId, delta: I.delta };
          S.push(c), l && console.debug("[TRANSFORM]: TEXT_MESSAGE_CONTENT", JSON.stringify(c));
        }
        return S;
      case EventType.TOOL_CALL_CHUNK:
        let T = i, v = [];
        if ((t !== "tool" || T.toolCallId !== void 0 && T.toolCallId !== (n == null ? void 0 : n.toolCallId)) && v.push(...o()), t !== "tool") {
          if (T.toolCallId === void 0) throw new Error("First TOOL_CALL_CHUNK must have a toolCallId");
          if (T.toolCallName === void 0) throw new Error("First TOOL_CALL_CHUNK must have a toolCallName");
          n = { toolCallId: T.toolCallId, toolCallName: T.toolCallName, parentMessageId: T.parentMessageId }, t = "tool";
          let c = { type: EventType.TOOL_CALL_START, toolCallId: T.toolCallId, toolCallName: T.toolCallName, parentMessageId: T.parentMessageId };
          v.push(c), l && console.debug("[TRANSFORM]: TOOL_CALL_START", JSON.stringify(c));
        }
        if (T.delta !== void 0) {
          let c = { type: EventType.TOOL_CALL_ARGS, toolCallId: n.toolCallId, delta: T.delta };
          v.push(c), l && console.debug("[TRANSFORM]: TOOL_CALL_ARGS", JSON.stringify(c));
        }
        return v;
    }
    let d = i.type;
    return [];
  }), finalize(() => {
    o();
  }));
};
var k = class {
  runNext(a, e) {
    return e.run(a).pipe(j(false));
  }
  runNextWithState(a, e) {
    let n = y(a.messages || []), t = y(a.state || {}), s = new ReplaySubject();
    return $(a, s, e, []).subscribe((o) => {
      o.messages !== void 0 && (n = o.messages), o.state !== void 0 && (t = o.state);
    }), this.runNext(a, e).pipe(concatMap(async (o) => (s.next(o), await new Promise((i) => setTimeout(i, 0)), { event: o, messages: y(n), state: y(t) })));
  }
};
var K = class extends k {
  constructor(e) {
    super();
    this.fn = e;
  }
  run(e, n) {
    return this.fn(e, n);
  }
};
function me(l) {
  let a = l.content;
  if (Array.isArray(a)) {
    let e = a.filter((n) => typeof n == "object" && n !== null && "type" in n && n.type === "text" && typeof n.text == "string").map((n) => n.text).join("");
    return G(N({}, l), { content: e });
  }
  return typeof a == "string" ? l : G(N({}, l), { content: "" });
}
var J = class extends k {
  run(a, e) {
    let r = a, { parentRunId: n } = r, t = gt(r, ["parentRunId"]), s = G(N({}, t), { messages: t.messages.map(me) });
    return this.runNext(s, e);
  }
};
var mt = { name: "@ag-ui/client", author: "Markus Ecker <markus.ecker@gmail.com>", version: "0.0.42", private: false, publishConfig: { access: "public" }, main: "./dist/index.js", module: "./dist/index.mjs", types: "./dist/index.d.ts", sideEffects: false, files: ["dist/**", "README.md"], scripts: { build: "tsup", dev: "tsup --watch", clean: "rm -rf dist .turbo node_modules", typecheck: "tsc --noEmit", test: "jest", "link:global": "pnpm link --global", "unlink:global": "pnpm unlink --global" }, dependencies: { "@ag-ui/core": "workspace:*", "@ag-ui/encoder": "workspace:*", "@ag-ui/proto": "workspace:*", "@types/uuid": "^10.0.0", "compare-versions": "^6.1.1", "fast-json-patch": "^3.1.1", rxjs: "7.8.1", "untruncate-json": "^0.0.1", uuid: "^11.1.0", zod: "^3.22.4" }, devDependencies: { "@types/jest": "^29.5.14", "@types/node": "^20.11.19", jest: "^29.7.0", "ts-jest": "^29.1.2", tsup: "^8.0.2", typescript: "^5.3.3" } };
var W = class {
  constructor({ agentId: a, description: e, threadId: n, initialMessages: t, initialState: s, debug: r } = {}) {
    this.debug = false;
    this.subscribers = [];
    this.isRunning = false;
    this.middlewares = [];
    this.agentId = a, this.description = e != null ? e : "", this.threadId = n != null ? n : v4_default(), this.messages = y(t != null ? t : []), this.state = y(s != null ? s : {}), this.debug = r != null ? r : false, compareVersions(this.maxVersion, "0.0.39") <= 0 && this.middlewares.unshift(new J());
  }
  get maxVersion() {
    return mt.version;
  }
  subscribe(a) {
    return this.subscribers.push(a), { unsubscribe: () => {
      this.subscribers = this.subscribers.filter((e) => e !== a);
    } };
  }
  use(...a) {
    let e = a.map((n) => typeof n == "function" ? new K(n) : n);
    return this.middlewares.push(...e), this;
  }
  async runAgent(a, e) {
    var n;
    try {
      this.isRunning = true, this.agentId = (n = this.agentId) != null ? n : v4_default();
      let t = this.prepareRunAgentInput(a), s, r = new Set(this.messages.map((S) => S.id)), o = [{ onRunFinishedEvent: (S) => {
        s = S.result;
      } }, ...this.subscribers, e != null ? e : {}];
      await this.onInitialize(t, o), this.activeRunDetach$ = new Subject();
      let i;
      this.activeRunCompletionPromise = new Promise((S) => {
        i = S;
      });
      let d = pipe(() => this.middlewares.length === 0 ? this.run(t) : this.middlewares.reduceRight((T, v) => ({ run: (c) => v.run(c, T) }), this).run(t), j(this.debug), z(this.debug), (S) => S.pipe(takeUntil(this.activeRunDetach$)), (S) => this.apply(t, S, o), (S) => this.processApplyEvents(t, S, o), catchError((S) => (this.isRunning = false, this.onError(t, S, o))), finalize(() => {
        this.isRunning = false, this.onFinalize(t, o), i == null || i(), i = void 0, this.activeRunCompletionPromise = void 0, this.activeRunDetach$ = void 0;
      }));
      await lastValueFrom(d(of(null)));
      let I = y(this.messages).filter((S) => !r.has(S.id));
      return { result: s, newMessages: I };
    } finally {
      this.isRunning = false;
    }
  }
  connect(a) {
    throw new AGUIConnectNotImplementedError();
  }
  async connectAgent(a, e) {
    var n;
    try {
      this.isRunning = true, this.agentId = (n = this.agentId) != null ? n : v4_default();
      let t = this.prepareRunAgentInput(a), s, r = new Set(this.messages.map((S) => S.id)), o = [{ onRunFinishedEvent: (S) => {
        s = S.result;
      } }, ...this.subscribers, e != null ? e : {}];
      await this.onInitialize(t, o), this.activeRunDetach$ = new Subject();
      let i;
      this.activeRunCompletionPromise = new Promise((S) => {
        i = S;
      });
      let d = pipe(() => this.connect(t), j(this.debug), z(this.debug), (S) => S.pipe(takeUntil(this.activeRunDetach$)), (S) => this.apply(t, S, o), (S) => this.processApplyEvents(t, S, o), catchError((S) => (this.isRunning = false, S instanceof AGUIConnectNotImplementedError ? EMPTY : this.onError(t, S, o))), finalize(() => {
        this.isRunning = false, this.onFinalize(t, o), i == null || i(), i = void 0, this.activeRunCompletionPromise = void 0, this.activeRunDetach$ = void 0;
      }));
      await lastValueFrom(d(of(null)));
      let I = y(this.messages).filter((S) => !r.has(S.id));
      return { result: s, newMessages: I };
    } finally {
      this.isRunning = false;
    }
  }
  abortRun() {
  }
  async detachActiveRun() {
    var e, n;
    if (!this.activeRunDetach$) return;
    let a = (e = this.activeRunCompletionPromise) != null ? e : Promise.resolve();
    this.activeRunDetach$.next(), (n = this.activeRunDetach$) == null || n.complete(), await a;
  }
  apply(a, e, n) {
    return $(a, e, this, n);
  }
  processApplyEvents(a, e, n) {
    return e.pipe(tap((t) => {
      t.messages && (this.messages = t.messages, n.forEach((s) => {
        var r;
        (r = s.onMessagesChanged) == null || r.call(s, { messages: this.messages, state: this.state, agent: this, input: a });
      })), t.state && (this.state = t.state, n.forEach((s) => {
        var r;
        (r = s.onStateChanged) == null || r.call(s, { state: this.state, messages: this.messages, agent: this, input: a });
      }));
    }));
  }
  prepareRunAgentInput(a) {
    var t, s, r;
    let n = y(this.messages).filter((o) => o.role !== "activity");
    return { threadId: this.threadId, runId: (a == null ? void 0 : a.runId) || v4_default(), tools: y((t = a == null ? void 0 : a.tools) != null ? t : []), context: y((s = a == null ? void 0 : a.context) != null ? s : []), forwardedProps: y((r = a == null ? void 0 : a.forwardedProps) != null ? r : {}), state: y(this.state), messages: n };
  }
  async onInitialize(a, e) {
    let n = await x(e, this.messages, this.state, (t, s, r) => {
      var o;
      return (o = t.onRunInitialized) == null ? void 0 : o.call(t, { messages: s, state: r, agent: this, input: a });
    });
    (n.messages !== void 0 || n.state !== void 0) && (n.messages && (this.messages = n.messages, a.messages = n.messages, e.forEach((t) => {
      var s;
      (s = t.onMessagesChanged) == null || s.call(t, { messages: this.messages, state: this.state, agent: this, input: a });
    })), n.state && (this.state = n.state, a.state = n.state, e.forEach((t) => {
      var s;
      (s = t.onStateChanged) == null || s.call(t, { state: this.state, messages: this.messages, agent: this, input: a });
    })));
  }
  onError(a, e, n) {
    return from(x(n, this.messages, this.state, (t, s, r) => {
      var o;
      return (o = t.onRunFailed) == null ? void 0 : o.call(t, { error: e, messages: s, state: r, agent: this, input: a });
    })).pipe(map((t) => {
      let s = t;
      if ((s.messages !== void 0 || s.state !== void 0) && (s.messages !== void 0 && (this.messages = s.messages, n.forEach((r) => {
        var o;
        (o = r.onMessagesChanged) == null || o.call(r, { messages: this.messages, state: this.state, agent: this, input: a });
      })), s.state !== void 0 && (this.state = s.state, n.forEach((r) => {
        var o;
        (o = r.onStateChanged) == null || o.call(r, { state: this.state, messages: this.messages, agent: this, input: a });
      }))), s.stopPropagation !== true) throw console.error("Agent execution failed:", e), e;
      return {};
    }));
  }
  async onFinalize(a, e) {
    let n = await x(e, this.messages, this.state, (t, s, r) => {
      var o;
      return (o = t.onRunFinalized) == null ? void 0 : o.call(t, { messages: s, state: r, agent: this, input: a });
    });
    (n.messages !== void 0 || n.state !== void 0) && (n.messages !== void 0 && (this.messages = n.messages, e.forEach((t) => {
      var s;
      (s = t.onMessagesChanged) == null || s.call(t, { messages: this.messages, state: this.state, agent: this, input: a });
    })), n.state !== void 0 && (this.state = n.state, e.forEach((t) => {
      var s;
      (s = t.onStateChanged) == null || s.call(t, { state: this.state, messages: this.messages, agent: this, input: a });
    })));
  }
  clone() {
    let a = Object.create(Object.getPrototypeOf(this));
    return a.agentId = this.agentId, a.description = this.description, a.threadId = this.threadId, a.messages = y(this.messages), a.state = y(this.state), a.debug = this.debug, a.isRunning = this.isRunning, a.subscribers = [...this.subscribers], a.middlewares = [...this.middlewares], a;
  }
  addMessage(a) {
    this.messages.push(a), (async () => {
      var e, n, t;
      for (let s of this.subscribers) await ((e = s.onNewMessage) == null ? void 0 : e.call(s, { message: a, messages: this.messages, state: this.state, agent: this }));
      if (a.role === "assistant" && a.toolCalls) for (let s of a.toolCalls) for (let r of this.subscribers) await ((n = r.onNewToolCall) == null ? void 0 : n.call(r, { toolCall: s, messages: this.messages, state: this.state, agent: this }));
      for (let s of this.subscribers) await ((t = s.onMessagesChanged) == null ? void 0 : t.call(s, { messages: this.messages, state: this.state, agent: this }));
    })();
  }
  addMessages(a) {
    this.messages.push(...a), (async () => {
      var e, n, t;
      for (let s of a) {
        for (let r of this.subscribers) await ((e = r.onNewMessage) == null ? void 0 : e.call(r, { message: s, messages: this.messages, state: this.state, agent: this }));
        if (s.role === "assistant" && s.toolCalls) for (let r of s.toolCalls) for (let o of this.subscribers) await ((n = o.onNewToolCall) == null ? void 0 : n.call(o, { toolCall: r, messages: this.messages, state: this.state, agent: this }));
      }
      for (let s of this.subscribers) await ((t = s.onMessagesChanged) == null ? void 0 : t.call(s, { messages: this.messages, state: this.state, agent: this }));
    })();
  }
  setMessages(a) {
    this.messages = y(a), (async () => {
      var e;
      for (let n of this.subscribers) await ((e = n.onMessagesChanged) == null ? void 0 : e.call(n, { messages: this.messages, state: this.state, agent: this }));
    })();
  }
  setState(a) {
    this.state = y(a), (async () => {
      var e;
      for (let n of this.subscribers) await ((e = n.onStateChanged) == null ? void 0 : e.call(n, { messages: this.messages, state: this.state, agent: this }));
    })();
  }
  legacy_to_be_removed_runAgentBridged(a) {
    var t;
    this.agentId = (t = this.agentId) != null ? t : v4_default();
    let e = this.prepareRunAgentInput(a);
    return (this.middlewares.length === 0 ? this.run(e) : this.middlewares.reduceRight((r, o) => ({ run: (i) => o.run(i, r) }), this).run(e)).pipe(j(this.debug), z(this.debug), at(this.threadId, e.runId, this.agentId), (s) => s.pipe(map((r) => (this.debug && console.debug("[LEGACY]:", JSON.stringify(r)), r))));
  }
};
var ot = class extends W {
  constructor(e) {
    var n;
    super(e);
    this.abortController = new AbortController();
    this.url = e.url, this.headers = y((n = e.headers) != null ? n : {});
  }
  requestInit(e) {
    return { method: "POST", headers: G(N({}, this.headers), { "Content-Type": "application/json", Accept: "text/event-stream" }), body: JSON.stringify(e), signal: this.abortController.signal };
  }
  runAgent(e, n) {
    var t;
    return this.abortController = (t = e == null ? void 0 : e.abortController) != null ? t : new AbortController(), super.runAgent(e, n);
  }
  abortRun() {
    this.abortController.abort(), super.abortRun();
  }
  run(e) {
    let n = tt(this.url, this.requestInit(e));
    return st(n);
  }
  clone() {
    var s;
    let e = super.clone();
    e.url = this.url, e.headers = y((s = this.headers) != null ? s : {});
    let n = new AbortController(), t = this.abortController.signal;
    return t.aborted && n.abort(t.reason), e.abortController = n, e;
  }
};

// node_modules/@copilotkitnext/shared/dist/index.mjs
var PartialJSON = __toESM(require_dist(), 1);

// node_modules/@copilotkitnext/shared/node_modules/@ag-ui/core/dist/index.mjs
var FunctionCallSchema2 = external_exports.object({
  name: external_exports.string(),
  arguments: external_exports.string()
});
var ToolCallSchema2 = external_exports.object({
  id: external_exports.string(),
  type: external_exports.literal("function"),
  function: FunctionCallSchema2
});
var BaseMessageSchema2 = external_exports.object({
  id: external_exports.string(),
  role: external_exports.string(),
  content: external_exports.string().optional(),
  name: external_exports.string().optional()
});
var TextInputContentSchema2 = external_exports.object({
  type: external_exports.literal("text"),
  text: external_exports.string()
});
var BinaryInputContentObjectSchema2 = external_exports.object({
  type: external_exports.literal("binary"),
  mimeType: external_exports.string(),
  id: external_exports.string().optional(),
  url: external_exports.string().optional(),
  data: external_exports.string().optional(),
  filename: external_exports.string().optional()
});
var ensureBinaryPayload2 = (value, ctx) => {
  if (!value.id && !value.url && !value.data) {
    ctx.addIssue({
      code: external_exports.ZodIssueCode.custom,
      message: "BinaryInputContent requires at least one of id, url, or data.",
      path: ["id"]
    });
  }
};
var BinaryInputContentSchema2 = BinaryInputContentObjectSchema2.superRefine((value, ctx) => {
  ensureBinaryPayload2(value, ctx);
});
var InputContentBaseSchema2 = external_exports.discriminatedUnion("type", [
  TextInputContentSchema2,
  BinaryInputContentObjectSchema2
]);
var InputContentSchema2 = InputContentBaseSchema2.superRefine((value, ctx) => {
  if (value.type === "binary") {
    ensureBinaryPayload2(value, ctx);
  }
});
var DeveloperMessageSchema2 = BaseMessageSchema2.extend({
  role: external_exports.literal("developer"),
  content: external_exports.string()
});
var SystemMessageSchema2 = BaseMessageSchema2.extend({
  role: external_exports.literal("system"),
  content: external_exports.string()
});
var AssistantMessageSchema2 = BaseMessageSchema2.extend({
  role: external_exports.literal("assistant"),
  content: external_exports.string().optional(),
  toolCalls: external_exports.array(ToolCallSchema2).optional()
});
var UserMessageSchema2 = BaseMessageSchema2.extend({
  role: external_exports.literal("user"),
  content: external_exports.union([external_exports.string(), external_exports.array(InputContentSchema2)])
});
var ToolMessageSchema2 = external_exports.object({
  id: external_exports.string(),
  content: external_exports.string(),
  role: external_exports.literal("tool"),
  toolCallId: external_exports.string(),
  error: external_exports.string().optional()
});
var ActivityMessageSchema2 = external_exports.object({
  id: external_exports.string(),
  role: external_exports.literal("activity"),
  activityType: external_exports.string(),
  content: external_exports.record(external_exports.any())
});
var MessageSchema2 = external_exports.discriminatedUnion("role", [
  DeveloperMessageSchema2,
  SystemMessageSchema2,
  AssistantMessageSchema2,
  UserMessageSchema2,
  ToolMessageSchema2,
  ActivityMessageSchema2
]);
var RoleSchema2 = external_exports.union([
  external_exports.literal("developer"),
  external_exports.literal("system"),
  external_exports.literal("assistant"),
  external_exports.literal("user"),
  external_exports.literal("tool"),
  external_exports.literal("activity")
]);
var ContextSchema2 = external_exports.object({
  description: external_exports.string(),
  value: external_exports.string()
});
var ToolSchema2 = external_exports.object({
  name: external_exports.string(),
  description: external_exports.string(),
  parameters: external_exports.any()
  // JSON Schema for the tool parameters
});
var RunAgentInputSchema2 = external_exports.object({
  threadId: external_exports.string(),
  runId: external_exports.string(),
  parentRunId: external_exports.string().optional(),
  state: external_exports.any(),
  messages: external_exports.array(MessageSchema2),
  tools: external_exports.array(ToolSchema2),
  context: external_exports.array(ContextSchema2),
  forwardedProps: external_exports.any()
});
var StateSchema2 = external_exports.any();
var TextMessageRoleSchema2 = external_exports.union([
  external_exports.literal("developer"),
  external_exports.literal("system"),
  external_exports.literal("assistant"),
  external_exports.literal("user")
]);
var EventType3 = ((EventType22) => {
  EventType22["TEXT_MESSAGE_START"] = "TEXT_MESSAGE_START";
  EventType22["TEXT_MESSAGE_CONTENT"] = "TEXT_MESSAGE_CONTENT";
  EventType22["TEXT_MESSAGE_END"] = "TEXT_MESSAGE_END";
  EventType22["TEXT_MESSAGE_CHUNK"] = "TEXT_MESSAGE_CHUNK";
  EventType22["THINKING_TEXT_MESSAGE_START"] = "THINKING_TEXT_MESSAGE_START";
  EventType22["THINKING_TEXT_MESSAGE_CONTENT"] = "THINKING_TEXT_MESSAGE_CONTENT";
  EventType22["THINKING_TEXT_MESSAGE_END"] = "THINKING_TEXT_MESSAGE_END";
  EventType22["TOOL_CALL_START"] = "TOOL_CALL_START";
  EventType22["TOOL_CALL_ARGS"] = "TOOL_CALL_ARGS";
  EventType22["TOOL_CALL_END"] = "TOOL_CALL_END";
  EventType22["TOOL_CALL_CHUNK"] = "TOOL_CALL_CHUNK";
  EventType22["TOOL_CALL_RESULT"] = "TOOL_CALL_RESULT";
  EventType22["THINKING_START"] = "THINKING_START";
  EventType22["THINKING_END"] = "THINKING_END";
  EventType22["STATE_SNAPSHOT"] = "STATE_SNAPSHOT";
  EventType22["STATE_DELTA"] = "STATE_DELTA";
  EventType22["MESSAGES_SNAPSHOT"] = "MESSAGES_SNAPSHOT";
  EventType22["ACTIVITY_SNAPSHOT"] = "ACTIVITY_SNAPSHOT";
  EventType22["ACTIVITY_DELTA"] = "ACTIVITY_DELTA";
  EventType22["RAW"] = "RAW";
  EventType22["CUSTOM"] = "CUSTOM";
  EventType22["RUN_STARTED"] = "RUN_STARTED";
  EventType22["RUN_FINISHED"] = "RUN_FINISHED";
  EventType22["RUN_ERROR"] = "RUN_ERROR";
  EventType22["STEP_STARTED"] = "STEP_STARTED";
  EventType22["STEP_FINISHED"] = "STEP_FINISHED";
  return EventType22;
})(EventType3 || {});
var BaseEventSchema2 = external_exports.object({
  type: external_exports.nativeEnum(EventType3),
  timestamp: external_exports.number().optional(),
  rawEvent: external_exports.any().optional()
});
var TextMessageStartEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_START"
    /* TEXT_MESSAGE_START */
  ),
  messageId: external_exports.string(),
  role: TextMessageRoleSchema2.default("assistant")
});
var TextMessageContentEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_CONTENT"
    /* TEXT_MESSAGE_CONTENT */
  ),
  messageId: external_exports.string(),
  delta: external_exports.string().refine((s) => s.length > 0, "Delta must not be an empty string")
});
var TextMessageEndEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_END"
    /* TEXT_MESSAGE_END */
  ),
  messageId: external_exports.string()
});
var TextMessageChunkEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TEXT_MESSAGE_CHUNK"
    /* TEXT_MESSAGE_CHUNK */
  ),
  messageId: external_exports.string().optional(),
  role: TextMessageRoleSchema2.optional(),
  delta: external_exports.string().optional()
});
var ThinkingTextMessageStartEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_START"
    /* THINKING_TEXT_MESSAGE_START */
  )
});
var ThinkingTextMessageContentEventSchema2 = TextMessageContentEventSchema2.omit({
  messageId: true,
  type: true
}).extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_CONTENT"
    /* THINKING_TEXT_MESSAGE_CONTENT */
  )
});
var ThinkingTextMessageEndEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "THINKING_TEXT_MESSAGE_END"
    /* THINKING_TEXT_MESSAGE_END */
  )
});
var ToolCallStartEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TOOL_CALL_START"
    /* TOOL_CALL_START */
  ),
  toolCallId: external_exports.string(),
  toolCallName: external_exports.string(),
  parentMessageId: external_exports.string().optional()
});
var ToolCallArgsEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TOOL_CALL_ARGS"
    /* TOOL_CALL_ARGS */
  ),
  toolCallId: external_exports.string(),
  delta: external_exports.string()
});
var ToolCallEndEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TOOL_CALL_END"
    /* TOOL_CALL_END */
  ),
  toolCallId: external_exports.string()
});
var ToolCallResultEventSchema2 = BaseEventSchema2.extend({
  messageId: external_exports.string(),
  type: external_exports.literal(
    "TOOL_CALL_RESULT"
    /* TOOL_CALL_RESULT */
  ),
  toolCallId: external_exports.string(),
  content: external_exports.string(),
  role: external_exports.literal("tool").optional()
});
var ToolCallChunkEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "TOOL_CALL_CHUNK"
    /* TOOL_CALL_CHUNK */
  ),
  toolCallId: external_exports.string().optional(),
  toolCallName: external_exports.string().optional(),
  parentMessageId: external_exports.string().optional(),
  delta: external_exports.string().optional()
});
var ThinkingStartEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "THINKING_START"
    /* THINKING_START */
  ),
  title: external_exports.string().optional()
});
var ThinkingEndEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "THINKING_END"
    /* THINKING_END */
  )
});
var StateSnapshotEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "STATE_SNAPSHOT"
    /* STATE_SNAPSHOT */
  ),
  snapshot: StateSchema2
});
var StateDeltaEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "STATE_DELTA"
    /* STATE_DELTA */
  ),
  delta: external_exports.array(external_exports.any())
  // JSON Patch (RFC 6902)
});
var MessagesSnapshotEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "MESSAGES_SNAPSHOT"
    /* MESSAGES_SNAPSHOT */
  ),
  messages: external_exports.array(MessageSchema2)
});
var ActivitySnapshotEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "ACTIVITY_SNAPSHOT"
    /* ACTIVITY_SNAPSHOT */
  ),
  messageId: external_exports.string(),
  activityType: external_exports.string(),
  content: external_exports.record(external_exports.any()),
  replace: external_exports.boolean().optional().default(true)
});
var ActivityDeltaEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "ACTIVITY_DELTA"
    /* ACTIVITY_DELTA */
  ),
  messageId: external_exports.string(),
  activityType: external_exports.string(),
  patch: external_exports.array(external_exports.any())
});
var RawEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "RAW"
    /* RAW */
  ),
  event: external_exports.any(),
  source: external_exports.string().optional()
});
var CustomEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "CUSTOM"
    /* CUSTOM */
  ),
  name: external_exports.string(),
  value: external_exports.any()
});
var RunStartedEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "RUN_STARTED"
    /* RUN_STARTED */
  ),
  threadId: external_exports.string(),
  runId: external_exports.string(),
  parentRunId: external_exports.string().optional(),
  input: RunAgentInputSchema2.optional()
});
var RunFinishedEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "RUN_FINISHED"
    /* RUN_FINISHED */
  ),
  threadId: external_exports.string(),
  runId: external_exports.string(),
  result: external_exports.any().optional()
});
var RunErrorEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "RUN_ERROR"
    /* RUN_ERROR */
  ),
  message: external_exports.string(),
  code: external_exports.string().optional()
});
var StepStartedEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "STEP_STARTED"
    /* STEP_STARTED */
  ),
  stepName: external_exports.string()
});
var StepFinishedEventSchema2 = BaseEventSchema2.extend({
  type: external_exports.literal(
    "STEP_FINISHED"
    /* STEP_FINISHED */
  ),
  stepName: external_exports.string()
});
var EventSchemas2 = external_exports.discriminatedUnion("type", [
  TextMessageStartEventSchema2,
  TextMessageContentEventSchema2,
  TextMessageEndEventSchema2,
  TextMessageChunkEventSchema2,
  ThinkingStartEventSchema2,
  ThinkingEndEventSchema2,
  ThinkingTextMessageStartEventSchema2,
  ThinkingTextMessageContentEventSchema2,
  ThinkingTextMessageEndEventSchema2,
  ToolCallStartEventSchema2,
  ToolCallArgsEventSchema2,
  ToolCallEndEventSchema2,
  ToolCallChunkEventSchema2,
  ToolCallResultEventSchema2,
  StateSnapshotEventSchema2,
  StateDeltaEventSchema2,
  MessagesSnapshotEventSchema2,
  ActivitySnapshotEventSchema2,
  ActivityDeltaEventSchema2,
  RawEventSchema2,
  CustomEventSchema2,
  RunStartedEventSchema2,
  RunFinishedEventSchema2,
  RunErrorEventSchema2,
  StepStartedEventSchema2,
  StepFinishedEventSchema2
]);

// node_modules/@copilotkitnext/shared/node_modules/@ag-ui/proto/dist/index.mjs
var JsonPatchOperationType2 = ((JsonPatchOperationType22) => {
  JsonPatchOperationType22[JsonPatchOperationType22["ADD"] = 0] = "ADD";
  JsonPatchOperationType22[JsonPatchOperationType22["REMOVE"] = 1] = "REMOVE";
  JsonPatchOperationType22[JsonPatchOperationType22["REPLACE"] = 2] = "REPLACE";
  JsonPatchOperationType22[JsonPatchOperationType22["MOVE"] = 3] = "MOVE";
  JsonPatchOperationType22[JsonPatchOperationType22["COPY"] = 4] = "COPY";
  JsonPatchOperationType22[JsonPatchOperationType22["TEST"] = 5] = "TEST";
  JsonPatchOperationType22[JsonPatchOperationType22["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return JsonPatchOperationType22;
})(JsonPatchOperationType2 || {});
var EventType4 = ((EventType32) => {
  EventType32[EventType32["TEXT_MESSAGE_START"] = 0] = "TEXT_MESSAGE_START";
  EventType32[EventType32["TEXT_MESSAGE_CONTENT"] = 1] = "TEXT_MESSAGE_CONTENT";
  EventType32[EventType32["TEXT_MESSAGE_END"] = 2] = "TEXT_MESSAGE_END";
  EventType32[EventType32["TOOL_CALL_START"] = 3] = "TOOL_CALL_START";
  EventType32[EventType32["TOOL_CALL_ARGS"] = 4] = "TOOL_CALL_ARGS";
  EventType32[EventType32["TOOL_CALL_END"] = 5] = "TOOL_CALL_END";
  EventType32[EventType32["STATE_SNAPSHOT"] = 6] = "STATE_SNAPSHOT";
  EventType32[EventType32["STATE_DELTA"] = 7] = "STATE_DELTA";
  EventType32[EventType32["MESSAGES_SNAPSHOT"] = 8] = "MESSAGES_SNAPSHOT";
  EventType32[EventType32["RAW"] = 9] = "RAW";
  EventType32[EventType32["CUSTOM"] = 10] = "CUSTOM";
  EventType32[EventType32["RUN_STARTED"] = 11] = "RUN_STARTED";
  EventType32[EventType32["RUN_FINISHED"] = 12] = "RUN_FINISHED";
  EventType32[EventType32["RUN_ERROR"] = 13] = "RUN_ERROR";
  EventType32[EventType32["STEP_STARTED"] = 14] = "STEP_STARTED";
  EventType32[EventType32["STEP_FINISHED"] = 15] = "STEP_FINISHED";
  EventType32[EventType32["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
  return EventType32;
})(EventType4 || {});

// node_modules/@copilotkitnext/shared/node_modules/@ag-ui/client/dist/index.mjs
var C2 = external_exports.enum(["TextMessageStart", "TextMessageContent", "TextMessageEnd", "ActionExecutionStart", "ActionExecutionArgs", "ActionExecutionEnd", "ActionExecutionResult", "AgentStateMessage", "MetaEvent", "RunStarted", "RunFinished", "RunError", "NodeStarted", "NodeFinished"]);
var Vt2 = external_exports.enum(["LangGraphInterruptEvent", "PredictState", "Exit"]);
var Wt2 = external_exports.object({ type: external_exports.literal(C2.enum.TextMessageStart), messageId: external_exports.string(), parentMessageId: external_exports.string().optional(), role: external_exports.string().optional() });
var Yt2 = external_exports.object({ type: external_exports.literal(C2.enum.TextMessageContent), messageId: external_exports.string(), content: external_exports.string() });
var qt2 = external_exports.object({ type: external_exports.literal(C2.enum.TextMessageEnd), messageId: external_exports.string() });
var Qt2 = external_exports.object({ type: external_exports.literal(C2.enum.ActionExecutionStart), actionExecutionId: external_exports.string(), actionName: external_exports.string(), parentMessageId: external_exports.string().optional() });
var Zt2 = external_exports.object({ type: external_exports.literal(C2.enum.ActionExecutionArgs), actionExecutionId: external_exports.string(), args: external_exports.string() });
var te2 = external_exports.object({ type: external_exports.literal(C2.enum.ActionExecutionEnd), actionExecutionId: external_exports.string() });
var ee2 = external_exports.object({ type: external_exports.literal(C2.enum.ActionExecutionResult), actionName: external_exports.string(), actionExecutionId: external_exports.string(), result: external_exports.string() });
var ne2 = external_exports.object({ type: external_exports.literal(C2.enum.AgentStateMessage), threadId: external_exports.string(), agentName: external_exports.string(), nodeName: external_exports.string(), runId: external_exports.string(), active: external_exports.boolean(), role: external_exports.string(), state: external_exports.string(), running: external_exports.boolean() });
var se2 = external_exports.object({ type: external_exports.literal(C2.enum.MetaEvent), name: Vt2, value: external_exports.any() });
var ae2 = external_exports.object({ type: external_exports.literal(C2.enum.RunError), message: external_exports.string(), code: external_exports.string().optional() });
var Qn2 = external_exports.discriminatedUnion("type", [Wt2, Yt2, qt2, Qt2, Zt2, te2, ee2, ne2, se2, ae2]);
var Zn2 = external_exports.object({ id: external_exports.string(), role: external_exports.string(), content: external_exports.string(), parentMessageId: external_exports.string().optional() });
var ts2 = external_exports.object({ id: external_exports.string(), name: external_exports.string(), arguments: external_exports.any(), parentMessageId: external_exports.string().optional() });
var es2 = external_exports.object({ id: external_exports.string(), result: external_exports.any(), actionExecutionId: external_exports.string(), actionName: external_exports.string() });

// node_modules/@copilotkitnext/shared/dist/index.mjs
function randomUUID() {
  return v4_default();
}
function partialJSONParse(json) {
  try {
    return PartialJSON.parse(json);
  } catch (error) {
    return {};
  }
}
var logger = console;
var DEFAULT_AGENT_ID = "default";
var TranscriptionErrorCode = ((TranscriptionErrorCode2) => {
  TranscriptionErrorCode2["SERVICE_NOT_CONFIGURED"] = "service_not_configured";
  TranscriptionErrorCode2["INVALID_AUDIO_FORMAT"] = "invalid_audio_format";
  TranscriptionErrorCode2["AUDIO_TOO_LONG"] = "audio_too_long";
  TranscriptionErrorCode2["AUDIO_TOO_SHORT"] = "audio_too_short";
  TranscriptionErrorCode2["RATE_LIMITED"] = "rate_limited";
  TranscriptionErrorCode2["AUTH_FAILED"] = "auth_failed";
  TranscriptionErrorCode2["PROVIDER_ERROR"] = "provider_error";
  TranscriptionErrorCode2["NETWORK_ERROR"] = "network_error";
  TranscriptionErrorCode2["INVALID_REQUEST"] = "invalid_request";
  return TranscriptionErrorCode2;
})(TranscriptionErrorCode || {});

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!(refs == null ? void 0 : refs.errorMessages))
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  var _a, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check.value,
          // This is in milliseconds
          check.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x2) => !!x2);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x2) => x2.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x2) => x2.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e, _f;
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && ((_a = def.keyType) == null ? void 0 : _a._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x2) => x2._def.typeName in primitiveMappings && (!x2._def.checks || !x2._def.checks.length))) {
    const types = options.reduce((types2, x2) => {
      const type = primitiveMappings[x2._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x2) => x2._def.typeName === "ZodLiteral" && !x2.description)) {
    const types = options.reduce((acc, x2) => {
      const type = typeof x2._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x2._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x2, i, a) => a.indexOf(x2) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x2) => {
          return acc.includes(x2._def.value) ? acc : [...acc, x2._def.value];
        }, [])
      };
    }
  } else if (options.every((x2) => x2._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x2) => [
        ...acc,
        ...x2._def.values.filter((x3) => !acc.includes(x3))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x2, i) => parseDef(x2._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x2) => !!x2 && (!refs.strictUnions || typeof x2 === "object" && Object.keys(x2).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check.value, check.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check.inclusive) {
            setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check.value, check.message, refs);
          }
        } else {
          if (!check.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check.value, check.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check.value, check.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x2) => x2 !== void 0)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x2, i) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x2, i) => parseDef(x2._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x2) => x2 === void 0 ? acc : [...acc, x2], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  var _a;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(refs, def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// node_modules/@copilotkitnext/core/dist/index.mjs
var ProxiedCopilotRuntimeAgent = class extends ot {
  constructor(config2) {
    const normalizedRuntimeUrl = config2.runtimeUrl ? config2.runtimeUrl.replace(/\/$/, "") : void 0;
    const transport = config2.transport ?? "rest";
    const runUrl = transport === "single" ? normalizedRuntimeUrl ?? config2.runtimeUrl ?? "" : `${normalizedRuntimeUrl ?? config2.runtimeUrl}/agent/${encodeURIComponent(config2.agentId ?? "")}/run`;
    if (!runUrl) {
      throw new Error("ProxiedCopilotRuntimeAgent requires a runtimeUrl when transport is set to 'single'.");
    }
    super({
      ...config2,
      url: runUrl
    });
    __publicField(this, "runtimeUrl");
    __publicField(this, "credentials");
    __publicField(this, "transport");
    __publicField(this, "singleEndpointUrl");
    this.runtimeUrl = normalizedRuntimeUrl ?? config2.runtimeUrl;
    this.credentials = config2.credentials;
    this.transport = transport;
    if (this.transport === "single") {
      this.singleEndpointUrl = this.runtimeUrl;
    }
  }
  abortRun() {
    if (!this.agentId || !this.threadId) {
      return;
    }
    if (typeof fetch === "undefined") {
      return;
    }
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        return;
      }
      const headers = new Headers({ ...this.headers, "Content-Type": "application/json" });
      void fetch(this.singleEndpointUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({
          method: "agent/stop",
          params: {
            agentId: this.agentId,
            threadId: this.threadId
          }
        }),
        ...this.credentials ? { credentials: this.credentials } : {}
      }).catch((error) => {
        console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
      });
      return;
    }
    if (!this.runtimeUrl) {
      return;
    }
    const stopPath = `${this.runtimeUrl}/agent/${encodeURIComponent(this.agentId)}/stop/${encodeURIComponent(this.threadId)}`;
    const origin = typeof window !== "undefined" && window.location ? window.location.origin : "http://localhost";
    const base = new URL(this.runtimeUrl, origin);
    const stopUrl = new URL(stopPath, base);
    void fetch(stopUrl.toString(), {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...this.headers
      },
      ...this.credentials ? { credentials: this.credentials } : {}
    }).catch((error) => {
      console.error("ProxiedCopilotRuntimeAgent: stop request failed", error);
    });
  }
  connect(input) {
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        throw new Error("Single endpoint transport requires a runtimeUrl");
      }
      const requestInit = this.createSingleRouteRequestInit(input, "agent/connect", {
        agentId: this.agentId
      });
      const httpEvents2 = tt(this.singleEndpointUrl, requestInit);
      return st(httpEvents2);
    }
    const httpEvents = tt(`${this.runtimeUrl}/agent/${this.agentId}/connect`, this.requestInit(input));
    return st(httpEvents);
  }
  run(input) {
    if (this.transport === "single") {
      if (!this.singleEndpointUrl) {
        throw new Error("Single endpoint transport requires a runtimeUrl");
      }
      const requestInit = this.createSingleRouteRequestInit(input, "agent/run", {
        agentId: this.agentId
      });
      const httpEvents = tt(this.singleEndpointUrl, requestInit);
      return st(httpEvents);
    }
    return super.run(input);
  }
  clone() {
    const cloned = super.clone();
    cloned.runtimeUrl = this.runtimeUrl;
    cloned.credentials = this.credentials;
    cloned.transport = this.transport;
    cloned.singleEndpointUrl = this.singleEndpointUrl;
    return cloned;
  }
  createSingleRouteRequestInit(input, method, params) {
    if (!this.agentId) {
      throw new Error("ProxiedCopilotRuntimeAgent requires agentId to make runtime requests");
    }
    const baseInit = super.requestInit(input);
    const headers = new Headers(baseInit.headers ?? {});
    headers.set("Content-Type", "application/json");
    headers.set("Accept", headers.get("Accept") ?? "text/event-stream");
    let originalBody = void 0;
    if (typeof baseInit.body === "string") {
      try {
        originalBody = JSON.parse(baseInit.body);
      } catch (error) {
        console.warn("ProxiedCopilotRuntimeAgent: failed to parse request body for single route transport", error);
        originalBody = void 0;
      }
    }
    const envelope = {
      method
    };
    if (params && Object.keys(params).length > 0) {
      envelope.params = params;
    }
    if (originalBody !== void 0) {
      envelope.body = originalBody;
    }
    return {
      ...baseInit,
      headers,
      body: JSON.stringify(envelope),
      ...this.credentials ? { credentials: this.credentials } : {}
    };
  }
};
var AgentRegistry = class {
  constructor(core) {
    __publicField(this, "_agents", {});
    __publicField(this, "localAgents", {});
    __publicField(this, "remoteAgents", {});
    __publicField(this, "_runtimeUrl");
    __publicField(this, "_runtimeVersion");
    __publicField(this, "_runtimeConnectionStatus", "disconnected");
    __publicField(this, "_runtimeTransport", "rest");
    __publicField(this, "_audioFileTranscriptionEnabled", false);
    this.core = core;
  }
  /**
   * Get all agents as a readonly record
   */
  get agents() {
    return this._agents;
  }
  get runtimeUrl() {
    return this._runtimeUrl;
  }
  get runtimeVersion() {
    return this._runtimeVersion;
  }
  get runtimeConnectionStatus() {
    return this._runtimeConnectionStatus;
  }
  get runtimeTransport() {
    return this._runtimeTransport;
  }
  get audioFileTranscriptionEnabled() {
    return this._audioFileTranscriptionEnabled;
  }
  /**
   * Initialize agents from configuration
   */
  initialize(agents) {
    this.localAgents = this.assignAgentIds(agents);
    this.applyHeadersToAgents(this.localAgents);
    this._agents = this.localAgents;
  }
  /**
   * Set the runtime URL and update connection
   */
  setRuntimeUrl(runtimeUrl) {
    const normalizedRuntimeUrl = runtimeUrl ? runtimeUrl.replace(/\/$/, "") : void 0;
    if (this._runtimeUrl === normalizedRuntimeUrl) {
      return;
    }
    this._runtimeUrl = normalizedRuntimeUrl;
    void this.updateRuntimeConnection();
  }
  setRuntimeTransport(runtimeTransport) {
    if (this._runtimeTransport === runtimeTransport) {
      return;
    }
    this._runtimeTransport = runtimeTransport;
    void this.updateRuntimeConnection();
  }
  /**
   * Set all agents at once (for development use)
   */
  setAgents__unsafe_dev_only(agents) {
    Object.entries(agents).forEach(([id, agent]) => {
      if (agent) {
        this.validateAndAssignAgentId(id, agent);
      }
    });
    this.localAgents = agents;
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    this.applyHeadersToAgents(this._agents);
    void this.notifyAgentsChanged();
  }
  /**
   * Add a single agent (for development use)
   */
  addAgent__unsafe_dev_only({ id, agent }) {
    this.validateAndAssignAgentId(id, agent);
    this.localAgents[id] = agent;
    this.applyHeadersToAgent(agent);
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    void this.notifyAgentsChanged();
  }
  /**
   * Remove an agent by ID (for development use)
   */
  removeAgent__unsafe_dev_only(id) {
    delete this.localAgents[id];
    this._agents = { ...this.localAgents, ...this.remoteAgents };
    void this.notifyAgentsChanged();
  }
  /**
   * Get an agent by ID
   */
  getAgent(id) {
    if (id in this._agents) {
      return this._agents[id];
    }
    if (this.runtimeUrl !== void 0 && (this.runtimeConnectionStatus === "disconnected" || this.runtimeConnectionStatus === "connecting")) {
      return void 0;
    }
    console.warn(`Agent ${id} not found`);
    return void 0;
  }
  /**
   * Apply current headers to an agent
   */
  applyHeadersToAgent(agent) {
    if (agent instanceof ot) {
      agent.headers = { ...this.core.headers };
    }
  }
  /**
   * Apply current headers to all agents
   */
  applyHeadersToAgents(agents) {
    Object.values(agents).forEach((agent) => {
      this.applyHeadersToAgent(agent);
    });
  }
  /**
   * Apply current credentials to an agent
   */
  applyCredentialsToAgent(agent) {
    if (agent instanceof ProxiedCopilotRuntimeAgent) {
      agent.credentials = this.core.credentials;
    }
  }
  /**
   * Apply current credentials to all agents
   */
  applyCredentialsToAgents(agents) {
    Object.values(agents).forEach((agent) => {
      this.applyCredentialsToAgent(agent);
    });
  }
  /**
   * Update runtime connection and fetch remote agents
   */
  async updateRuntimeConnection() {
    if (typeof window === "undefined") {
      return;
    }
    if (!this.runtimeUrl) {
      this._runtimeConnectionStatus = "disconnected";
      this._runtimeVersion = void 0;
      this._audioFileTranscriptionEnabled = false;
      this.remoteAgents = {};
      this._agents = this.localAgents;
      await this.notifyRuntimeStatusChanged(
        "disconnected"
        /* Disconnected */
      );
      await this.notifyAgentsChanged();
      return;
    }
    this._runtimeConnectionStatus = "connecting";
    await this.notifyRuntimeStatusChanged(
      "connecting"
      /* Connecting */
    );
    try {
      const runtimeInfoResponse = await this.fetchRuntimeInfo();
      const {
        version,
        ...runtimeInfo
      } = runtimeInfoResponse;
      const credentials = this.core.credentials;
      const agents = Object.fromEntries(
        Object.entries(runtimeInfo.agents).map(([id, { description }]) => {
          const agent = new ProxiedCopilotRuntimeAgent({
            runtimeUrl: this.runtimeUrl,
            agentId: id,
            // Runtime agents always have their ID set correctly
            description,
            transport: this._runtimeTransport,
            credentials
          });
          this.applyHeadersToAgent(agent);
          return [id, agent];
        })
      );
      this.remoteAgents = agents;
      this._agents = { ...this.localAgents, ...this.remoteAgents };
      this._runtimeConnectionStatus = "connected";
      this._runtimeVersion = version;
      this._audioFileTranscriptionEnabled = runtimeInfoResponse.audioFileTranscriptionEnabled ?? false;
      await this.notifyRuntimeStatusChanged(
        "connected"
        /* Connected */
      );
      await this.notifyAgentsChanged();
    } catch (error) {
      this._runtimeConnectionStatus = "error";
      this._runtimeVersion = void 0;
      this._audioFileTranscriptionEnabled = false;
      this.remoteAgents = {};
      this._agents = this.localAgents;
      await this.notifyRuntimeStatusChanged(
        "error"
        /* Error */
      );
      await this.notifyAgentsChanged();
      const message = error instanceof Error ? error.message : JSON.stringify(error);
      logger.warn(`Failed to load runtime info (${this.runtimeUrl}/info): ${message}`);
      const runtimeError = error instanceof Error ? error : new Error(String(error));
      await this.core.emitError({
        error: runtimeError,
        code: "runtime_info_fetch_failed",
        context: {
          runtimeUrl: this.runtimeUrl
        }
      });
    }
  }
  async fetchRuntimeInfo() {
    if (!this.runtimeUrl) {
      throw new Error("Runtime URL is not set");
    }
    const baseHeaders = this.core.headers;
    const credentials = this.core.credentials;
    const headers = {
      ...baseHeaders
    };
    if (this._runtimeTransport === "single") {
      if (!headers["Content-Type"]) {
        headers["Content-Type"] = "application/json";
      }
      const response2 = await fetch(this.runtimeUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({ method: "info" }),
        ...credentials ? { credentials } : {}
      });
      if ("ok" in response2 && !response2.ok) {
        throw new Error(`Runtime info request failed with status ${response2.status}`);
      }
      return await response2.json();
    }
    const response = await fetch(`${this.runtimeUrl}/info`, {
      headers,
      ...credentials ? { credentials } : {}
    });
    if ("ok" in response && !response.ok) {
      throw new Error(`Runtime info request failed with status ${response.status}`);
    }
    return await response.json();
  }
  /**
   * Assign agent IDs to a record of agents
   */
  assignAgentIds(agents) {
    Object.entries(agents).forEach(([id, agent]) => {
      if (agent) {
        this.validateAndAssignAgentId(id, agent);
      }
    });
    return agents;
  }
  /**
   * Validate and assign an agent ID
   */
  validateAndAssignAgentId(registrationId, agent) {
    if (agent.agentId && agent.agentId !== registrationId) {
      throw new Error(
        `Agent registration mismatch: Agent with ID "${agent.agentId}" cannot be registered under key "${registrationId}". The agent ID must match the registration key or be undefined.`
      );
    }
    if (!agent.agentId) {
      agent.agentId = registrationId;
    }
  }
  /**
   * Notify subscribers of runtime status changes
   */
  async notifyRuntimeStatusChanged(status) {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onRuntimeConnectionStatusChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          status
        });
      },
      "Error in CopilotKitCore subscriber (onRuntimeConnectionStatusChanged):"
    );
  }
  /**
   * Notify subscribers of agent changes
   */
  async notifyAgentsChanged() {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onAgentsChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          agents: this._agents
        });
      },
      "Subscriber onAgentsChanged error:"
    );
  }
};
var ContextStore = class {
  constructor(core) {
    __publicField(this, "_context", {});
    this.core = core;
  }
  /**
   * Get all context entries as a readonly record
   */
  get context() {
    return this._context;
  }
  /**
   * Add a new context entry
   * @returns The ID of the created context entry
   */
  addContext({ description, value }) {
    const id = randomUUID();
    this._context[id] = { description, value };
    void this.notifySubscribers();
    return id;
  }
  /**
   * Remove a context entry by ID
   */
  removeContext(id) {
    delete this._context[id];
    void this.notifySubscribers();
  }
  /**
   * Notify all subscribers of context changes
   */
  async notifySubscribers() {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onContextChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          context: this._context
        });
      },
      "Subscriber onContextChanged error:"
    );
  }
};
var SuggestionEngine = class {
  constructor(core) {
    __publicField(this, "_suggestionsConfig", {});
    __publicField(this, "_suggestions", {});
    __publicField(this, "_runningSuggestions", {});
    this.core = core;
  }
  /**
   * Initialize with suggestion configs
   */
  initialize(suggestionsConfig) {
    for (const config2 of suggestionsConfig) {
      this._suggestionsConfig[randomUUID()] = config2;
    }
  }
  /**
   * Add a suggestion configuration
   * @returns The ID of the created config
   */
  addSuggestionsConfig(config2) {
    const id = randomUUID();
    this._suggestionsConfig[id] = config2;
    void this.notifySuggestionsConfigChanged();
    return id;
  }
  /**
   * Remove a suggestion configuration by ID
   */
  removeSuggestionsConfig(id) {
    delete this._suggestionsConfig[id];
    void this.notifySuggestionsConfigChanged();
  }
  /**
   * Reload suggestions for a specific agent
   * This triggers generation of new suggestions based on current configs
   */
  reloadSuggestions(agentId) {
    var _a;
    this.clearSuggestions(agentId);
    const agent = this.core.getAgent(agentId);
    if (!agent) {
      return;
    }
    const messageCount = ((_a = agent.messages) == null ? void 0 : _a.length) ?? 0;
    let hasAnySuggestions = false;
    for (const config2 of Object.values(this._suggestionsConfig)) {
      if (config2.consumerAgentId !== void 0 && config2.consumerAgentId !== "*" && config2.consumerAgentId !== agentId) {
        continue;
      }
      if (!this.shouldShowSuggestions(config2, messageCount)) {
        continue;
      }
      const suggestionId = randomUUID();
      if (isDynamicSuggestionsConfig(config2)) {
        if (!hasAnySuggestions) {
          hasAnySuggestions = true;
          void this.notifySuggestionsStartedLoading(agentId);
        }
        void this.generateSuggestions(suggestionId, config2, agentId);
      } else if (isStaticSuggestionsConfig(config2)) {
        this.addStaticSuggestions(suggestionId, config2, agentId);
      }
    }
  }
  /**
   * Clear all suggestions for a specific agent
   */
  clearSuggestions(agentId) {
    const runningAgents = this._runningSuggestions[agentId];
    if (runningAgents) {
      for (const agent of runningAgents) {
        agent.abortRun();
      }
      delete this._runningSuggestions[agentId];
    }
    this._suggestions[agentId] = {};
    void this.notifySuggestionsChanged(agentId, []);
  }
  /**
   * Get current suggestions for an agent
   */
  getSuggestions(agentId) {
    var _a;
    const suggestions = Object.values(this._suggestions[agentId] ?? {}).flat();
    const isLoading = (((_a = this._runningSuggestions[agentId]) == null ? void 0 : _a.length) ?? 0) > 0;
    return { suggestions, isLoading };
  }
  /**
   * Generate suggestions using a provider agent
   */
  async generateSuggestions(suggestionId, config2, consumerAgentId) {
    let agent = void 0;
    try {
      const suggestionsProviderAgent = this.core.getAgent(
        config2.providerAgentId ?? "default"
      );
      if (!suggestionsProviderAgent) {
        throw new Error(`Suggestions provider agent not found: ${config2.providerAgentId}`);
      }
      const suggestionsConsumerAgent = this.core.getAgent(consumerAgentId);
      if (!suggestionsConsumerAgent) {
        throw new Error(`Suggestions consumer agent not found: ${consumerAgentId}`);
      }
      const clonedAgent = suggestionsProviderAgent.clone();
      agent = clonedAgent;
      agent.threadId = suggestionId;
      agent.messages = JSON.parse(JSON.stringify(suggestionsConsumerAgent.messages));
      agent.state = JSON.parse(JSON.stringify(suggestionsConsumerAgent.state));
      this._suggestions[consumerAgentId] = {
        ...this._suggestions[consumerAgentId] ?? {},
        [suggestionId]: []
      };
      this._runningSuggestions[consumerAgentId] = [...this._runningSuggestions[consumerAgentId] ?? [], agent];
      agent.addMessage({
        id: suggestionId,
        role: "user",
        content: [
          `Suggest what the user could say next. Provide clear, highly relevant suggestions by calling the \`copilotkitSuggest\` tool.`,
          `Provide at least ${config2.minSuggestions ?? 1} and at most ${config2.maxSuggestions ?? 3} suggestions.`,
          `The user has the following tools available: ${JSON.stringify(this.core.buildFrontendTools(consumerAgentId))}.`,
          ` ${config2.instructions}`
        ].join("\n")
      });
      await agent.runAgent(
        {
          context: Object.values(this.core.context),
          forwardedProps: {
            ...this.core.properties,
            toolChoice: { type: "function", function: { name: "copilotkitSuggest" } }
          },
          tools: [SUGGEST_TOOL]
        },
        {
          onMessagesChanged: ({ messages }) => {
            this.extractSuggestions(messages, suggestionId, consumerAgentId, true);
          }
        }
      );
    } catch (error) {
      console.warn("Error generating suggestions:", error);
    } finally {
      this.finalizeSuggestions(suggestionId, consumerAgentId);
      const runningAgents = this._runningSuggestions[consumerAgentId];
      if (agent && runningAgents) {
        const filteredAgents = runningAgents.filter((a) => a !== agent);
        this._runningSuggestions[consumerAgentId] = filteredAgents;
        if (filteredAgents.length === 0) {
          delete this._runningSuggestions[consumerAgentId];
          await this.notifySuggestionsFinishedLoading(consumerAgentId);
        }
      }
    }
  }
  /**
   * Finalize suggestions by marking them as no longer loading
   */
  finalizeSuggestions(suggestionId, consumerAgentId) {
    const agentSuggestions = this._suggestions[consumerAgentId];
    const currentSuggestions = agentSuggestions == null ? void 0 : agentSuggestions[suggestionId];
    if (agentSuggestions && currentSuggestions && currentSuggestions.length > 0) {
      const finalizedSuggestions = currentSuggestions.filter((suggestion) => suggestion.title !== "" || suggestion.message !== "").map((suggestion) => ({
        ...suggestion,
        isLoading: false
      }));
      if (finalizedSuggestions.length > 0) {
        agentSuggestions[suggestionId] = finalizedSuggestions;
      } else {
        delete agentSuggestions[suggestionId];
      }
      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "finalized");
    }
  }
  /**
   * Extract suggestions from messages (called during streaming)
   */
  extractSuggestions(messages, suggestionId, consumerAgentId, isRunning) {
    const idx = messages.findIndex((message) => message.id === suggestionId);
    if (idx == -1) {
      return;
    }
    const suggestions = [];
    const newMessages = messages.slice(idx + 1);
    for (const message of newMessages) {
      if (message.role === "assistant" && message.toolCalls) {
        for (const toolCall of message.toolCalls) {
          if (toolCall.function.name === "copilotkitSuggest") {
            const fullArgs = Array.isArray(toolCall.function.arguments) ? toolCall.function.arguments.join("") : toolCall.function.arguments;
            const parsed = partialJSONParse(fullArgs);
            if (parsed && typeof parsed === "object" && "suggestions" in parsed) {
              const parsedSuggestions = parsed.suggestions;
              if (Array.isArray(parsedSuggestions)) {
                for (const item of parsedSuggestions) {
                  if (item && typeof item === "object" && "title" in item) {
                    suggestions.push({
                      title: item.title ?? "",
                      message: item.message ?? "",
                      isLoading: false
                      // Will be set correctly below
                    });
                  }
                }
              }
            }
          }
        }
      }
    }
    if (isRunning && suggestions.length > 0) {
      suggestions[suggestions.length - 1].isLoading = true;
    }
    const agentSuggestions = this._suggestions[consumerAgentId];
    if (agentSuggestions) {
      agentSuggestions[suggestionId] = suggestions;
      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "suggestions changed");
    }
  }
  /**
   * Notify subscribers of suggestions config changes
   */
  async notifySuggestionsConfigChanged() {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onSuggestionsConfigChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          suggestionsConfig: this._suggestionsConfig
        });
      },
      "Subscriber onSuggestionsConfigChanged error:"
    );
  }
  /**
   * Notify subscribers of suggestions changes
   */
  async notifySuggestionsChanged(agentId, suggestions, context2 = "") {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onSuggestionsChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          agentId,
          suggestions
        });
      },
      `Subscriber onSuggestionsChanged error: ${context2}`
    );
  }
  /**
   * Notify subscribers that suggestions started loading
   */
  async notifySuggestionsStartedLoading(agentId) {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onSuggestionsStartedLoading) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          agentId
        });
      },
      "Subscriber onSuggestionsStartedLoading error:"
    );
  }
  /**
   * Notify subscribers that suggestions finished loading
   */
  async notifySuggestionsFinishedLoading(agentId) {
    await this.core.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onSuggestionsFinishedLoading) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this.core,
          agentId
        });
      },
      "Subscriber onSuggestionsFinishedLoading error:"
    );
  }
  /**
   * Check if suggestions should be shown based on availability and message count
   */
  shouldShowSuggestions(config2, messageCount) {
    const availability = config2.available;
    if (!availability) {
      if (isDynamicSuggestionsConfig(config2)) {
        return messageCount > 0;
      } else {
        return messageCount === 0;
      }
    }
    switch (availability) {
      case "disabled":
        return false;
      case "before-first-message":
        return messageCount === 0;
      case "after-first-message":
        return messageCount > 0;
      case "always":
        return true;
      default:
        return false;
    }
  }
  /**
   * Add static suggestions directly without AI generation
   */
  addStaticSuggestions(suggestionId, config2, consumerAgentId) {
    const suggestions = config2.suggestions.map((s) => ({
      ...s,
      isLoading: false
    }));
    this._suggestions[consumerAgentId] = {
      ...this._suggestions[consumerAgentId] ?? {},
      [suggestionId]: suggestions
    };
    const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();
    void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, "static suggestions added");
  }
};
function isDynamicSuggestionsConfig(config2) {
  return "instructions" in config2;
}
function isStaticSuggestionsConfig(config2) {
  return "suggestions" in config2;
}
var SUGGEST_TOOL = {
  name: "copilotkitSuggest",
  description: "Suggest what the user could say next",
  parameters: {
    type: "object",
    properties: {
      suggestions: {
        type: "array",
        description: "List of suggestions shown to the user as buttons.",
        items: {
          type: "object",
          properties: {
            title: {
              type: "string",
              description: "The title of the suggestion. This is shown as a button and should be short."
            },
            message: {
              type: "string",
              description: "The message to send when the suggestion is clicked. This should be a clear, complete sentence and will be sent as an instruction to the AI."
            }
          },
          required: ["title", "message"]
        }
      }
    },
    required: ["suggestions"]
  }
};
var RunHandler = class {
  constructor(core) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __publicField(this, "_tools", []);
    this.core = core;
  }
  /**
   * Get all tools as a readonly array
   */
  get tools() {
    return this._tools;
  }
  /**
   * Initialize with tools
   */
  initialize(tools) {
    this._tools = tools;
  }
  /**
   * Add a tool to the registry
   */
  addTool(tool) {
    const existingToolIndex = this._tools.findIndex((t) => t.name === tool.name && t.agentId === tool.agentId);
    if (existingToolIndex !== -1) {
      logger.warn(`Tool already exists: '${tool.name}' for agent '${tool.agentId || "global"}', skipping.`);
      return;
    }
    this._tools.push(tool);
  }
  /**
   * Remove a tool by name and optionally by agentId
   */
  removeTool(id, agentId) {
    this._tools = this._tools.filter((tool) => {
      if (agentId !== void 0) {
        return !(tool.name === id && tool.agentId === agentId);
      }
      return !(tool.name === id && !tool.agentId);
    });
  }
  /**
   * Get a tool by name and optionally by agentId.
   * If agentId is provided, it will first look for an agent-specific tool,
   * then fall back to a global tool with the same name.
   */
  getTool(params) {
    const { toolName, agentId } = params;
    if (agentId) {
      const agentTool = this._tools.find((tool) => tool.name === toolName && tool.agentId === agentId);
      if (agentTool) {
        return agentTool;
      }
    }
    return this._tools.find((tool) => tool.name === toolName && !tool.agentId);
  }
  /**
   * Set all tools at once. Replaces existing tools.
   */
  setTools(tools) {
    this._tools = [...tools];
  }
  /**
   * Connect an agent (establish initial connection)
   */
  async connectAgent({ agent }) {
    try {
      await agent.detachActiveRun();
      agent.setMessages([]);
      agent.setState({});
      if (agent instanceof ot) {
        agent.headers = { ...this.core.headers };
      }
      const runAgentResult = await agent.connectAgent(
        {
          forwardedProps: this.core.properties,
          tools: this.buildFrontendTools(agent.agentId)
        },
        this.createAgentErrorSubscriber(agent)
      );
      return this.processAgentResult({ runAgentResult, agent });
    } catch (error) {
      const connectError = error instanceof Error ? error : new Error(String(error));
      const context2 = {};
      if (agent.agentId) {
        context2.agentId = agent.agentId;
      }
      await this.core.emitError({
        error: connectError,
        code: "agent_connect_failed",
        context: context2
      });
      throw error;
    }
  }
  /**
   * Run an agent
   */
  async runAgent({ agent }) {
    if (agent.agentId) {
      void this.core.suggestionEngine.clearSuggestions(agent.agentId);
    }
    if (agent instanceof ot) {
      agent.headers = { ...this.core.headers };
    }
    try {
      const runAgentResult = await agent.runAgent(
        {
          forwardedProps: this.core.properties,
          tools: this.buildFrontendTools(agent.agentId),
          context: Object.values(this.core.context)
        },
        this.createAgentErrorSubscriber(agent)
      );
      return this.processAgentResult({ runAgentResult, agent });
    } catch (error) {
      const runError = error instanceof Error ? error : new Error(String(error));
      const context2 = {};
      if (agent.agentId) {
        context2.agentId = agent.agentId;
      }
      await this.core.emitError({
        error: runError,
        code: "agent_run_failed",
        context: context2
      });
      throw error;
    }
  }
  /**
   * Process agent result and execute tools
   */
  async processAgentResult({
    runAgentResult,
    agent
  }) {
    const { newMessages } = runAgentResult;
    const agentId = agent.agentId;
    let needsFollowUp = false;
    for (const message of newMessages) {
      if (message.role === "assistant") {
        for (const toolCall of message.toolCalls || []) {
          if (newMessages.findIndex((m) => m.role === "tool" && m.toolCallId === toolCall.id) === -1) {
            const tool = this.getTool({
              toolName: toolCall.function.name,
              agentId: agent.agentId
            });
            if (tool) {
              const followUp = await this.executeSpecificTool(tool, toolCall, message, agent, agentId);
              if (followUp) {
                needsFollowUp = true;
              }
            } else {
              const wildcardTool = this.getTool({ toolName: "*", agentId: agent.agentId });
              if (wildcardTool) {
                const followUp = await this.executeWildcardTool(wildcardTool, toolCall, message, agent, agentId);
                if (followUp) {
                  needsFollowUp = true;
                }
              }
            }
          }
        }
      }
    }
    if (needsFollowUp) {
      return await this.runAgent({ agent });
    }
    void this.core.suggestionEngine.reloadSuggestions(agentId);
    return runAgentResult;
  }
  /**
   * Execute a specific tool
   */
  async executeSpecificTool(tool, toolCall, message, agent, agentId) {
    if ((tool == null ? void 0 : tool.agentId) && tool.agentId !== agent.agentId) {
      return false;
    }
    let toolCallResult = "";
    let errorMessage;
    let isArgumentError = false;
    if (tool == null ? void 0 : tool.handler) {
      let parsedArgs;
      try {
        parsedArgs = JSON.parse(toolCall.function.arguments);
      } catch (error) {
        const parseError = error instanceof Error ? error : new Error(String(error));
        errorMessage = parseError.message;
        isArgumentError = true;
        await this.core.emitError({
          error: parseError,
          code: "tool_argument_parse_failed",
          context: {
            agentId,
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            rawArguments: toolCall.function.arguments,
            toolType: "specific",
            messageId: message.id
          }
        });
      }
      await this.core.notifySubscribers(
        (subscriber) => {
          var _a;
          return (_a = subscriber.onToolExecutionStart) == null ? void 0 : _a.call(subscriber, {
            copilotkit: this.core,
            toolCallId: toolCall.id,
            agentId,
            toolName: toolCall.function.name,
            args: parsedArgs
          });
        },
        "Subscriber onToolExecutionStart error:"
      );
      if (!errorMessage) {
        try {
          const result = await tool.handler(parsedArgs, toolCall);
          if (result === void 0 || result === null) {
            toolCallResult = "";
          } else if (typeof result === "string") {
            toolCallResult = result;
          } else {
            toolCallResult = JSON.stringify(result);
          }
        } catch (error) {
          const handlerError = error instanceof Error ? error : new Error(String(error));
          errorMessage = handlerError.message;
          await this.core.emitError({
            error: handlerError,
            code: "tool_handler_failed",
            context: {
              agentId,
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              parsedArgs,
              toolType: "specific",
              messageId: message.id
            }
          });
        }
      }
      if (errorMessage) {
        toolCallResult = `Error: ${errorMessage}`;
      }
      await this.core.notifySubscribers(
        (subscriber) => {
          var _a;
          return (_a = subscriber.onToolExecutionEnd) == null ? void 0 : _a.call(subscriber, {
            copilotkit: this.core,
            toolCallId: toolCall.id,
            agentId,
            toolName: toolCall.function.name,
            result: errorMessage ? "" : toolCallResult,
            error: errorMessage
          });
        },
        "Subscriber onToolExecutionEnd error:"
      );
      if (isArgumentError) {
        throw new Error(errorMessage ?? "Tool execution failed");
      }
    }
    if (!errorMessage || !isArgumentError) {
      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);
      const toolMessage = {
        id: randomUUID(),
        role: "tool",
        toolCallId: toolCall.id,
        content: toolCallResult
      };
      agent.messages.splice(messageIndex + 1, 0, toolMessage);
      if (!errorMessage && (tool == null ? void 0 : tool.followUp) !== false) {
        return true;
      }
    }
    return false;
  }
  /**
   * Execute a wildcard tool
   */
  async executeWildcardTool(wildcardTool, toolCall, message, agent, agentId) {
    if ((wildcardTool == null ? void 0 : wildcardTool.agentId) && wildcardTool.agentId !== agent.agentId) {
      return false;
    }
    let toolCallResult = "";
    let errorMessage;
    let isArgumentError = false;
    if (wildcardTool == null ? void 0 : wildcardTool.handler) {
      let parsedArgs;
      try {
        parsedArgs = JSON.parse(toolCall.function.arguments);
      } catch (error) {
        const parseError = error instanceof Error ? error : new Error(String(error));
        errorMessage = parseError.message;
        isArgumentError = true;
        await this.core.emitError({
          error: parseError,
          code: "tool_argument_parse_failed",
          context: {
            agentId,
            toolCallId: toolCall.id,
            toolName: toolCall.function.name,
            rawArguments: toolCall.function.arguments,
            toolType: "wildcard",
            messageId: message.id
          }
        });
      }
      const wildcardArgs = {
        toolName: toolCall.function.name,
        args: parsedArgs
      };
      await this.core.notifySubscribers(
        (subscriber) => {
          var _a;
          return (_a = subscriber.onToolExecutionStart) == null ? void 0 : _a.call(subscriber, {
            copilotkit: this.core,
            toolCallId: toolCall.id,
            agentId,
            toolName: toolCall.function.name,
            args: wildcardArgs
          });
        },
        "Subscriber onToolExecutionStart error:"
      );
      if (!errorMessage) {
        try {
          const result = await wildcardTool.handler(wildcardArgs, toolCall);
          if (result === void 0 || result === null) {
            toolCallResult = "";
          } else if (typeof result === "string") {
            toolCallResult = result;
          } else {
            toolCallResult = JSON.stringify(result);
          }
        } catch (error) {
          const handlerError = error instanceof Error ? error : new Error(String(error));
          errorMessage = handlerError.message;
          await this.core.emitError({
            error: handlerError,
            code: "tool_handler_failed",
            context: {
              agentId,
              toolCallId: toolCall.id,
              toolName: toolCall.function.name,
              parsedArgs: wildcardArgs,
              toolType: "wildcard",
              messageId: message.id
            }
          });
        }
      }
      if (errorMessage) {
        toolCallResult = `Error: ${errorMessage}`;
      }
      await this.core.notifySubscribers(
        (subscriber) => {
          var _a;
          return (_a = subscriber.onToolExecutionEnd) == null ? void 0 : _a.call(subscriber, {
            copilotkit: this.core,
            toolCallId: toolCall.id,
            agentId,
            toolName: toolCall.function.name,
            result: errorMessage ? "" : toolCallResult,
            error: errorMessage
          });
        },
        "Subscriber onToolExecutionEnd error:"
      );
      if (isArgumentError) {
        throw new Error(errorMessage ?? "Tool execution failed");
      }
    }
    if (!errorMessage || !isArgumentError) {
      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);
      const toolMessage = {
        id: randomUUID(),
        role: "tool",
        toolCallId: toolCall.id,
        content: toolCallResult
      };
      agent.messages.splice(messageIndex + 1, 0, toolMessage);
      if (!errorMessage && (wildcardTool == null ? void 0 : wildcardTool.followUp) !== false) {
        return true;
      }
    }
    return false;
  }
  /**
   * Build frontend tools for an agent
   */
  buildFrontendTools(agentId) {
    return this._tools.filter((tool) => !tool.agentId || tool.agentId === agentId).map((tool) => ({
      name: tool.name,
      description: tool.description ?? "",
      parameters: createToolSchema(tool)
    }));
  }
  /**
   * Create an agent error subscriber
   */
  createAgentErrorSubscriber(agent) {
    const emitAgentError = async (error, code, extraContext = {}) => {
      const context2 = { ...extraContext };
      if (agent.agentId) {
        context2.agentId = agent.agentId;
      }
      await this.core.emitError({
        error,
        code,
        context: context2
      });
    };
    return {
      onRunFailed: async ({ error }) => {
        await emitAgentError(error, "agent_run_failed_event", {
          source: "onRunFailed"
        });
      },
      onRunErrorEvent: async ({ event }) => {
        var _a, _b;
        const eventError = (event == null ? void 0 : event.rawEvent) instanceof Error ? event.rawEvent : ((_a = event == null ? void 0 : event.rawEvent) == null ? void 0 : _a.error) instanceof Error ? event.rawEvent.error : void 0;
        const errorMessage = typeof ((_b = event == null ? void 0 : event.rawEvent) == null ? void 0 : _b.error) === "string" ? event.rawEvent.error : (event == null ? void 0 : event.message) ?? "Agent run error";
        const rawError = eventError ?? new Error(errorMessage);
        if ((event == null ? void 0 : event.code) && !rawError.code) {
          rawError.code = event.code;
        }
        await emitAgentError(rawError, "agent_run_error_event", {
          source: "onRunErrorEvent",
          event,
          runtimeErrorCode: event == null ? void 0 : event.code
        });
      }
    };
  }
};
var EMPTY_TOOL_SCHEMA = {
  type: "object",
  properties: {}
};
function createToolSchema(tool) {
  if (!tool.parameters) {
    return { ...EMPTY_TOOL_SCHEMA };
  }
  const rawSchema = zodToJsonSchema(tool.parameters, {
    $refStrategy: "none"
  });
  if (!rawSchema || typeof rawSchema !== "object") {
    return { ...EMPTY_TOOL_SCHEMA };
  }
  const { $schema, ...schema } = rawSchema;
  if (typeof schema.type !== "string") {
    schema.type = "object";
  }
  if (typeof schema.properties !== "object" || schema.properties === null) {
    schema.properties = {};
  }
  stripAdditionalProperties(schema);
  return schema;
}
function stripAdditionalProperties(schema) {
  if (!schema || typeof schema !== "object") {
    return;
  }
  if (Array.isArray(schema)) {
    schema.forEach(stripAdditionalProperties);
    return;
  }
  const record = schema;
  if (record.additionalProperties !== void 0) {
    delete record.additionalProperties;
  }
  for (const value of Object.values(record)) {
    stripAdditionalProperties(value);
  }
}
var StateManager = class {
  constructor(core) {
    // State tracking: agentId -> threadId -> runId -> state
    __publicField(this, "stateByRun", /* @__PURE__ */ new Map());
    // Message tracking: agentId -> threadId -> messageId -> runId
    __publicField(this, "messageToRun", /* @__PURE__ */ new Map());
    // Agent subscriptions for cleanup
    __publicField(this, "agentSubscriptions", /* @__PURE__ */ new Map());
    this.core = core;
  }
  /**
   * Initialize state tracking for an agent
   */
  initialize() {
  }
  /**
   * Subscribe to an agent's events to track state and messages
   */
  subscribeToAgent(agent) {
    if (!agent.agentId) {
      return;
    }
    const agentId = agent.agentId;
    this.unsubscribeFromAgent(agentId);
    const { unsubscribe } = agent.subscribe({
      onRunStartedEvent: ({ event, state }) => {
        this.handleRunStarted(agent, event, state);
      },
      onRunFinishedEvent: ({ event, state }) => {
        this.handleRunFinished(agent, event, state);
      },
      onStateSnapshotEvent: ({ event, input, state }) => {
        this.handleStateSnapshot(agent, event, input, state);
      },
      onStateDeltaEvent: ({ event, input, state }) => {
        this.handleStateDelta(agent, event, input, state);
      },
      onMessagesSnapshotEvent: ({ event, input, messages }) => {
        this.handleMessagesSnapshot(agent, event, input, messages);
      },
      onNewMessage: ({ message, input }) => {
        this.handleNewMessage(agent, message, input);
      }
    });
    this.agentSubscriptions.set(agentId, unsubscribe);
  }
  /**
   * Unsubscribe from an agent's events
   */
  unsubscribeFromAgent(agentId) {
    const unsubscribe = this.agentSubscriptions.get(agentId);
    if (unsubscribe) {
      unsubscribe();
      this.agentSubscriptions.delete(agentId);
    }
  }
  /**
   * Get state for a specific run
   * Returns a deep copy to prevent external mutations
   */
  getStateByRun(agentId, threadId, runId) {
    var _a, _b;
    const state = (_b = (_a = this.stateByRun.get(agentId)) == null ? void 0 : _a.get(threadId)) == null ? void 0 : _b.get(runId);
    if (!state) return void 0;
    return JSON.parse(JSON.stringify(state));
  }
  /**
   * Get runId associated with a message
   */
  getRunIdForMessage(agentId, threadId, messageId) {
    var _a, _b;
    return (_b = (_a = this.messageToRun.get(agentId)) == null ? void 0 : _a.get(threadId)) == null ? void 0 : _b.get(messageId);
  }
  /**
   * Get all states for an agent's thread
   */
  getStatesForThread(agentId, threadId) {
    var _a;
    return ((_a = this.stateByRun.get(agentId)) == null ? void 0 : _a.get(threadId)) ?? /* @__PURE__ */ new Map();
  }
  /**
   * Get all run IDs for an agent's thread
   */
  getRunIdsForThread(agentId, threadId) {
    var _a;
    const threadStates = (_a = this.stateByRun.get(agentId)) == null ? void 0 : _a.get(threadId);
    return threadStates ? Array.from(threadStates.keys()) : [];
  }
  /**
   * Handle run started event
   */
  handleRunStarted(agent, event, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = event;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle run finished event
   */
  handleRunFinished(agent, event, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = event;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle state snapshot event
   */
  handleStateSnapshot(agent, event, input, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    const mergedState = { ...state, ...event.snapshot };
    this.saveState(agent.agentId, threadId, runId, mergedState);
  }
  /**
   * Handle state delta event
   */
  handleStateDelta(agent, event, input, state) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    this.saveState(agent.agentId, threadId, runId, state);
  }
  /**
   * Handle messages snapshot event
   */
  handleMessagesSnapshot(agent, event, input, messages) {
    if (!agent.agentId) return;
    const { threadId, runId } = input;
    for (const message of event.messages) {
      this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
    }
  }
  /**
   * Handle new message event
   */
  handleNewMessage(agent, message, input) {
    if (!agent.agentId || !input) return;
    const { threadId, runId } = input;
    this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);
  }
  /**
   * Save state for a specific run
   */
  saveState(agentId, threadId, runId, state) {
    if (!this.stateByRun.has(agentId)) {
      this.stateByRun.set(agentId, /* @__PURE__ */ new Map());
    }
    const agentStates = this.stateByRun.get(agentId);
    if (!agentStates.has(threadId)) {
      agentStates.set(threadId, /* @__PURE__ */ new Map());
    }
    const threadStates = agentStates.get(threadId);
    threadStates.set(runId, JSON.parse(JSON.stringify(state)));
  }
  /**
   * Associate a message with a run
   */
  associateMessageWithRun(agentId, threadId, messageId, runId) {
    if (!this.messageToRun.has(agentId)) {
      this.messageToRun.set(agentId, /* @__PURE__ */ new Map());
    }
    const agentMessages = this.messageToRun.get(agentId);
    if (!agentMessages.has(threadId)) {
      agentMessages.set(threadId, /* @__PURE__ */ new Map());
    }
    const threadMessages = agentMessages.get(threadId);
    threadMessages.set(messageId, runId);
  }
  /**
   * Clear all state for an agent
   */
  clearAgentState(agentId) {
    this.stateByRun.delete(agentId);
    this.messageToRun.delete(agentId);
  }
  /**
   * Clear all state for a thread
   */
  clearThreadState(agentId, threadId) {
    var _a, _b;
    (_a = this.stateByRun.get(agentId)) == null ? void 0 : _a.delete(threadId);
    (_b = this.messageToRun.get(agentId)) == null ? void 0 : _b.delete(threadId);
  }
};
var CopilotKitCoreErrorCode = ((CopilotKitCoreErrorCode2) => {
  CopilotKitCoreErrorCode2["RUNTIME_INFO_FETCH_FAILED"] = "runtime_info_fetch_failed";
  CopilotKitCoreErrorCode2["AGENT_CONNECT_FAILED"] = "agent_connect_failed";
  CopilotKitCoreErrorCode2["AGENT_RUN_FAILED"] = "agent_run_failed";
  CopilotKitCoreErrorCode2["AGENT_RUN_FAILED_EVENT"] = "agent_run_failed_event";
  CopilotKitCoreErrorCode2["AGENT_RUN_ERROR_EVENT"] = "agent_run_error_event";
  CopilotKitCoreErrorCode2["TOOL_ARGUMENT_PARSE_FAILED"] = "tool_argument_parse_failed";
  CopilotKitCoreErrorCode2["TOOL_HANDLER_FAILED"] = "tool_handler_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_FAILED"] = "transcription_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_SERVICE_NOT_CONFIGURED"] = "transcription_service_not_configured";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_INVALID_AUDIO"] = "transcription_invalid_audio";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_RATE_LIMITED"] = "transcription_rate_limited";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_AUTH_FAILED"] = "transcription_auth_failed";
  CopilotKitCoreErrorCode2["TRANSCRIPTION_NETWORK_ERROR"] = "transcription_network_error";
  return CopilotKitCoreErrorCode2;
})(CopilotKitCoreErrorCode || {});
var CopilotKitCoreRuntimeConnectionStatus = ((CopilotKitCoreRuntimeConnectionStatus2) => {
  CopilotKitCoreRuntimeConnectionStatus2["Disconnected"] = "disconnected";
  CopilotKitCoreRuntimeConnectionStatus2["Connected"] = "connected";
  CopilotKitCoreRuntimeConnectionStatus2["Connecting"] = "connecting";
  CopilotKitCoreRuntimeConnectionStatus2["Error"] = "error";
  return CopilotKitCoreRuntimeConnectionStatus2;
})(CopilotKitCoreRuntimeConnectionStatus || {});
var CopilotKitCore = class {
  constructor({
    runtimeUrl,
    runtimeTransport = "rest",
    headers = {},
    credentials,
    properties = {},
    agents__unsafe_dev_only = {},
    tools = [],
    suggestionsConfig = []
  }) {
    __publicField(this, "_headers");
    __publicField(this, "_credentials");
    __publicField(this, "_properties");
    __publicField(this, "subscribers", /* @__PURE__ */ new Set());
    // Delegate classes
    __publicField(this, "agentRegistry");
    __publicField(this, "contextStore");
    __publicField(this, "suggestionEngine");
    __publicField(this, "runHandler");
    __publicField(this, "stateManager");
    this._headers = headers;
    this._credentials = credentials;
    this._properties = properties;
    this.agentRegistry = new AgentRegistry(this);
    this.contextStore = new ContextStore(this);
    this.suggestionEngine = new SuggestionEngine(this);
    this.runHandler = new RunHandler(this);
    this.stateManager = new StateManager(this);
    this.agentRegistry.initialize(agents__unsafe_dev_only);
    this.runHandler.initialize(tools);
    this.suggestionEngine.initialize(suggestionsConfig);
    this.stateManager.initialize();
    this.agentRegistry.setRuntimeTransport(runtimeTransport);
    this.agentRegistry.setRuntimeUrl(runtimeUrl);
    this.subscribe({
      onAgentsChanged: ({ agents }) => {
        Object.values(agents).forEach((agent) => {
          if (agent.agentId) {
            this.stateManager.subscribeToAgent(agent);
          }
        });
      }
    });
  }
  /**
   * Internal method used by delegate classes and subclasses to notify subscribers
   */
  async notifySubscribers(handler, errorMessage) {
    await Promise.all(
      Array.from(this.subscribers).map(async (subscriber) => {
        try {
          await handler(subscriber);
        } catch (error) {
          console.error(errorMessage, error);
        }
      })
    );
  }
  /**
   * Internal method used by delegate classes to emit errors
   */
  async emitError({
    error,
    code,
    context: context2 = {}
  }) {
    await this.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onError) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this,
          error,
          code,
          context: context2
        });
      },
      "Subscriber onError error:"
    );
  }
  /**
   * Snapshot accessors
   */
  get context() {
    return this.contextStore.context;
  }
  get agents() {
    return this.agentRegistry.agents;
  }
  get tools() {
    return this.runHandler.tools;
  }
  get runtimeUrl() {
    return this.agentRegistry.runtimeUrl;
  }
  setRuntimeUrl(runtimeUrl) {
    this.agentRegistry.setRuntimeUrl(runtimeUrl);
  }
  get runtimeTransport() {
    return this.agentRegistry.runtimeTransport;
  }
  setRuntimeTransport(runtimeTransport) {
    this.agentRegistry.setRuntimeTransport(runtimeTransport);
  }
  get runtimeVersion() {
    return this.agentRegistry.runtimeVersion;
  }
  get headers() {
    return this._headers;
  }
  get credentials() {
    return this._credentials;
  }
  get properties() {
    return this._properties;
  }
  get runtimeConnectionStatus() {
    return this.agentRegistry.runtimeConnectionStatus;
  }
  get audioFileTranscriptionEnabled() {
    return this.agentRegistry.audioFileTranscriptionEnabled;
  }
  /**
   * Configuration updates
   */
  setHeaders(headers) {
    this._headers = headers;
    this.agentRegistry.applyHeadersToAgents(this.agentRegistry.agents);
    void this.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onHeadersChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this,
          headers: this.headers
        });
      },
      "Subscriber onHeadersChanged error:"
    );
  }
  setCredentials(credentials) {
    this._credentials = credentials;
    this.agentRegistry.applyCredentialsToAgents(this.agentRegistry.agents);
  }
  setProperties(properties) {
    this._properties = properties;
    void this.notifySubscribers(
      (subscriber) => {
        var _a;
        return (_a = subscriber.onPropertiesChanged) == null ? void 0 : _a.call(subscriber, {
          copilotkit: this,
          properties: this.properties
        });
      },
      "Subscriber onPropertiesChanged error:"
    );
  }
  /**
   * Agent management (delegated to AgentRegistry)
   */
  setAgents__unsafe_dev_only(agents) {
    this.agentRegistry.setAgents__unsafe_dev_only(agents);
  }
  addAgent__unsafe_dev_only(params) {
    this.agentRegistry.addAgent__unsafe_dev_only(params);
  }
  removeAgent__unsafe_dev_only(id) {
    this.agentRegistry.removeAgent__unsafe_dev_only(id);
  }
  getAgent(id) {
    return this.agentRegistry.getAgent(id);
  }
  /**
   * Context management (delegated to ContextStore)
   */
  addContext(context2) {
    return this.contextStore.addContext(context2);
  }
  removeContext(id) {
    this.contextStore.removeContext(id);
  }
  /**
   * Suggestions management (delegated to SuggestionEngine)
   */
  addSuggestionsConfig(config2) {
    return this.suggestionEngine.addSuggestionsConfig(config2);
  }
  removeSuggestionsConfig(id) {
    this.suggestionEngine.removeSuggestionsConfig(id);
  }
  reloadSuggestions(agentId) {
    this.suggestionEngine.reloadSuggestions(agentId);
  }
  clearSuggestions(agentId) {
    this.suggestionEngine.clearSuggestions(agentId);
  }
  getSuggestions(agentId) {
    return this.suggestionEngine.getSuggestions(agentId);
  }
  /**
   * Tool management (delegated to RunHandler)
   */
  addTool(tool) {
    this.runHandler.addTool(tool);
  }
  removeTool(id, agentId) {
    this.runHandler.removeTool(id, agentId);
  }
  getTool(params) {
    return this.runHandler.getTool(params);
  }
  setTools(tools) {
    this.runHandler.setTools(tools);
  }
  /**
   * Subscription lifecycle
   */
  subscribe(subscriber) {
    this.subscribers.add(subscriber);
    return {
      unsubscribe: () => {
        this.subscribers.delete(subscriber);
      }
    };
  }
  /**
   * Agent connectivity (delegated to RunHandler)
   */
  async connectAgent(params) {
    return this.runHandler.connectAgent(params);
  }
  stopAgent(params) {
    params.agent.abortRun();
  }
  async runAgent(params) {
    return this.runHandler.runAgent(params);
  }
  /**
   * State management (delegated to StateManager)
   */
  getStateByRun(agentId, threadId, runId) {
    return this.stateManager.getStateByRun(agentId, threadId, runId);
  }
  getRunIdForMessage(agentId, threadId, messageId) {
    return this.stateManager.getRunIdForMessage(agentId, threadId, messageId);
  }
  getRunIdsForThread(agentId, threadId) {
    return this.stateManager.getRunIdsForThread(agentId, threadId);
  }
  /**
   * Internal method used by RunHandler to build frontend tools
   */
  buildFrontendTools(agentId) {
    return this.runHandler.buildFrontendTools(agentId);
  }
};
var ToolCallStatus = ((ToolCallStatus2) => {
  ToolCallStatus2["InProgress"] = "inProgress";
  ToolCallStatus2["Executing"] = "executing";
  ToolCallStatus2["Complete"] = "complete";
  return ToolCallStatus2;
})(ToolCallStatus || {});

export {
  external_exports,
  __extends,
  __assign,
  __rest,
  __awaiter,
  __generator,
  __spreadArray,
  untruncateJson,
  randomUUID,
  partialJSONParse,
  DEFAULT_AGENT_ID,
  TranscriptionErrorCode,
  ProxiedCopilotRuntimeAgent,
  CopilotKitCoreRuntimeConnectionStatus,
  CopilotKitCore,
  ToolCallStatus
};
/*! Bundled license information:

fast-json-patch/module/helpers.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2022 Joachim Wester
   * MIT licensed
   *)

fast-json-patch/module/duplex.mjs:
  (*!
   * https://github.com/Starcounter-Jack/JSON-Patch
   * (c) 2017-2021 Joachim Wester
   * MIT license
   *)
*/
//# sourceMappingURL=chunk-4RP4FUON.js.map
