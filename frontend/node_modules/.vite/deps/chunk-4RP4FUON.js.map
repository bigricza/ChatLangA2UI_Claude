{
  "version": 3,
  "sources": ["../../partial-json/dist/options.js", "../../partial-json/dist/index.js", "../../zod/v3/external.js", "../../zod/v3/helpers/util.js", "../../zod/v3/ZodError.js", "../../zod/v3/locales/en.js", "../../zod/v3/errors.js", "../../zod/v3/helpers/parseUtil.js", "../../zod/v3/helpers/errorUtil.js", "../../zod/v3/types.js", "../../@copilotkitnext/core/node_modules/@ag-ui/core/src/types.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/core/src/events.ts", "../../rxjs/src/internal/util/isFunction.ts", "../../rxjs/src/internal/util/lift.ts", "../../tslib/tslib.es6.mjs", "../../rxjs/src/internal/util/isArrayLike.ts", "../../rxjs/src/internal/util/isPromise.ts", "../../rxjs/src/internal/util/createErrorClass.ts", "../../rxjs/src/internal/util/UnsubscriptionError.ts", "../../rxjs/src/internal/util/arrRemove.ts", "../../rxjs/src/internal/Subscription.ts", "../../rxjs/src/internal/config.ts", "../../rxjs/src/internal/scheduler/timeoutProvider.ts", "../../rxjs/src/internal/util/reportUnhandledError.ts", "../../rxjs/src/internal/util/noop.ts", "../../rxjs/src/internal/NotificationFactories.ts", "../../rxjs/src/internal/util/errorContext.ts", "../../rxjs/src/internal/Subscriber.ts", "../../rxjs/src/internal/symbol/observable.ts", "../../rxjs/src/internal/util/identity.ts", "../../rxjs/src/internal/util/pipe.ts", "../../rxjs/src/internal/Observable.ts", "../../rxjs/src/internal/util/isInteropObservable.ts", "../../rxjs/src/internal/util/isAsyncIterable.ts", "../../rxjs/src/internal/util/throwUnobservableError.ts", "../../rxjs/src/internal/symbol/iterator.ts", "../../rxjs/src/internal/util/isIterable.ts", "../../rxjs/src/internal/util/isReadableStreamLike.ts", "../../rxjs/src/internal/observable/innerFrom.ts", "../../rxjs/src/internal/operators/OperatorSubscriber.ts", "../../rxjs/src/internal/scheduler/Action.ts", "../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../rxjs/src/internal/Scheduler.ts", "../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../rxjs/src/internal/scheduler/async.ts", "../../rxjs/src/internal/util/isScheduler.ts", "../../rxjs/src/internal/util/args.ts", "../../rxjs/src/internal/util/executeSchedule.ts", "../../rxjs/src/internal/operators/catchError.ts", "../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../rxjs/src/internal/operators/observeOn.ts", "../../rxjs/src/internal/operators/subscribeOn.ts", "../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../rxjs/src/internal/scheduled/scheduled.ts", "../../rxjs/src/internal/observable/from.ts", "../../rxjs/src/internal/operators/map.ts", "../../rxjs/src/internal/operators/mergeInternals.ts", "../../rxjs/src/internal/operators/mergeMap.ts", "../../rxjs/src/internal/operators/mergeAll.ts", "../../rxjs/src/internal/operators/concatMap.ts", "../../rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../rxjs/src/internal/Subject.ts", "../../rxjs/src/internal/operators/defaultIfEmpty.ts", "../../rxjs/src/internal/observable/empty.ts", "../../rxjs/src/internal/observable/of.ts", "../../rxjs/src/internal/observable/throwError.ts", "../../rxjs/src/internal/Notification.ts", "../../rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../rxjs/src/internal/util/EmptyError.ts", "../../rxjs/src/internal/operators/finalize.ts", "../../rxjs/src/internal/operators/refCount.ts", "../../rxjs/src/internal/observable/ConnectableObservable.ts", "../../rxjs/src/internal/BehaviorSubject.ts", "../../rxjs/src/internal/AsyncSubject.ts", "../../rxjs/src/internal/ReplaySubject.ts", "../../rxjs/src/internal/util/SequenceError.ts", "../../rxjs/src/internal/util/NotFoundError.ts", "../../rxjs/src/internal/operators/switchMap.ts", "../../rxjs/src/internal/operators/takeUntil.ts", "../../rxjs/src/internal/operators/tap.ts", "../../rxjs/src/internal/operators/timeout.ts", "../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../rxjs/src/internal/lastValueFrom.ts", "../../rxjs/src/internal/observable/defer.ts", "../../rxjs/src/internal/observable/never.ts", "../../fast-json-patch/module/core.mjs", "../../fast-json-patch/module/helpers.mjs", "../../fast-json-patch/module/duplex.mjs", "../../fast-json-patch/index.mjs", "../../untruncate-json/src/index.ts", "../../@bufbuild/protobuf/dist/esm/wire/varint.js", "../../@bufbuild/protobuf/dist/esm/proto-int64.js", "../../@bufbuild/protobuf/dist/esm/wire/text-encoding.js", "../../@bufbuild/protobuf/dist/esm/wire/binary-encoding.js", "../../@bufbuild/protobuf/dist/esm/descriptors.js", "../../@bufbuild/protobuf/dist/esm/reflect/unsafe.js", "../../@bufbuild/protobuf/dist/esm/create.js", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/proto.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/generated/events.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/generated/google/protobuf/struct.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/generated/patch.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/generated/types.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/proto/src/index.ts", "../../compare-versions/src/utils.ts", "../../compare-versions/src/compareVersions.ts", "../../compare-versions/src/compare.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/apply/default.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/utils.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/agent/subscriber.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/verify/verify.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/transform/http.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/run/http-request.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/transform/sse.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/transform/proto.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/legacy/convert.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/legacy/types.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/agent/agent.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/chunks/transform.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/middleware/middleware.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/middleware/filter-tool-calls.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/middleware/backward-compatibility-0-0-39.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/package.json", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/agent/http.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/compact/compact.ts", "../../@copilotkitnext/core/node_modules/@ag-ui/client/src/index.ts", "../../@copilotkitnext/shared/src/utils.ts", "../../@copilotkitnext/shared/src/logger.ts", "../../@copilotkitnext/shared/src/constants.ts", "../../@copilotkitnext/shared/src/finalize-events.ts", "../../@copilotkitnext/shared/src/transcription-errors.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/core/src/types.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/core/src/events.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/proto.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/generated/events.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/generated/google/protobuf/struct.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/generated/patch.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/generated/types.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/proto/src/index.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/apply/default.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/utils.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/agent/subscriber.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/verify/verify.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/transform/http.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/run/http-request.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/transform/sse.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/transform/proto.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/legacy/convert.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/legacy/types.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/agent/agent.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/chunks/transform.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/middleware/middleware.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/middleware/filter-tool-calls.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/middleware/backward-compatibility-0-0-39.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/package.json", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/agent/http.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/compact/compact.ts", "../../@copilotkitnext/shared/node_modules/@ag-ui/client/src/index.ts", "../../zod-to-json-schema/dist/esm/Options.js", "../../zod-to-json-schema/dist/esm/Refs.js", "../../zod-to-json-schema/dist/esm/errorMessages.js", "../../zod-to-json-schema/dist/esm/getRelativePath.js", "../../zod-to-json-schema/dist/esm/parsers/any.js", "../../zod-to-json-schema/dist/esm/parsers/array.js", "../../zod-to-json-schema/dist/esm/parsers/bigint.js", "../../zod-to-json-schema/dist/esm/parsers/boolean.js", "../../zod-to-json-schema/dist/esm/parsers/branded.js", "../../zod-to-json-schema/dist/esm/parsers/catch.js", "../../zod-to-json-schema/dist/esm/parsers/date.js", "../../zod-to-json-schema/dist/esm/parsers/default.js", "../../zod-to-json-schema/dist/esm/parsers/effects.js", "../../zod-to-json-schema/dist/esm/parsers/enum.js", "../../zod-to-json-schema/dist/esm/parsers/intersection.js", "../../zod-to-json-schema/dist/esm/parsers/literal.js", "../../zod-to-json-schema/dist/esm/parsers/string.js", "../../zod-to-json-schema/dist/esm/parsers/record.js", "../../zod-to-json-schema/dist/esm/parsers/map.js", "../../zod-to-json-schema/dist/esm/parsers/nativeEnum.js", "../../zod-to-json-schema/dist/esm/parsers/never.js", "../../zod-to-json-schema/dist/esm/parsers/null.js", "../../zod-to-json-schema/dist/esm/parsers/union.js", "../../zod-to-json-schema/dist/esm/parsers/nullable.js", "../../zod-to-json-schema/dist/esm/parsers/number.js", "../../zod-to-json-schema/dist/esm/parsers/object.js", "../../zod-to-json-schema/dist/esm/parsers/optional.js", "../../zod-to-json-schema/dist/esm/parsers/pipeline.js", "../../zod-to-json-schema/dist/esm/parsers/promise.js", "../../zod-to-json-schema/dist/esm/parsers/set.js", "../../zod-to-json-schema/dist/esm/parsers/tuple.js", "../../zod-to-json-schema/dist/esm/parsers/undefined.js", "../../zod-to-json-schema/dist/esm/parsers/unknown.js", "../../zod-to-json-schema/dist/esm/parsers/readonly.js", "../../zod-to-json-schema/dist/esm/selectParser.js", "../../zod-to-json-schema/dist/esm/parseDef.js", "../../zod-to-json-schema/dist/esm/zodToJsonSchema.js", "../../@copilotkitnext/core/src/core/agent-registry.ts", "../../@copilotkitnext/core/src/agent.ts", "../../@copilotkitnext/core/src/core/context-store.ts", "../../@copilotkitnext/core/src/core/suggestion-engine.ts", "../../@copilotkitnext/core/src/core/run-handler.ts", "../../@copilotkitnext/core/src/core/state-manager.ts", "../../@copilotkitnext/core/src/core/core.ts", "../../@copilotkitnext/core/src/types.ts", "../../@copilotkitnext/core/src/utils/markdown.ts"],
  "sourcesContent": ["\"use strict\";\n/**\n * Sometimes you don't allow every type to be partially parsed.\n * For example, you may not want a partial number because it may increase its size gradually before it's complete.\n * In this case, you can use the `Allow` object to control what types you allow to be partially parsed.\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Allow = exports.ALL = exports.COLLECTION = exports.ATOM = exports.SPECIAL = exports.INF = exports._INFINITY = exports.INFINITY = exports.NAN = exports.BOOL = exports.NULL = exports.OBJ = exports.ARR = exports.NUM = exports.STR = void 0;\n/**\n * allow partial strings like `\"hello \\u12` to be parsed as `\"hello \"`\n */\nexports.STR = 0b000000001;\n/**\n * allow partial numbers like `123.` to be parsed as `123`\n */\nexports.NUM = 0b000000010;\n/**\n * allow partial arrays like `[1, 2,` to be parsed as `[1, 2]`\n */\nexports.ARR = 0b000000100;\n/**\n * allow partial objects like `{\"a\": 1, \"b\":` to be parsed as `{\"a\": 1}`\n */\nexports.OBJ = 0b000001000;\n/**\n * allow `nu` to be parsed as `null`\n */\nexports.NULL = 0b000010000;\n/**\n * allow `tr` to be parsed as `true`, and `fa` to be parsed as `false`\n */\nexports.BOOL = 0b000100000;\n/**\n * allow `Na` to be parsed as `NaN`\n */\nexports.NAN = 0b001000000;\n/**\n * allow `Inf` to be parsed as `Infinity`\n */\nexports.INFINITY = 0b010000000;\n/**\n * allow `-Inf` to be parsed as `-Infinity`\n */\nexports._INFINITY = 0b100000000;\nexports.INF = exports.INFINITY | exports._INFINITY;\nexports.SPECIAL = exports.NULL | exports.BOOL | exports.INF | exports.NAN;\nexports.ATOM = exports.STR | exports.NUM | exports.SPECIAL;\nexports.COLLECTION = exports.ARR | exports.OBJ;\nexports.ALL = exports.ATOM | exports.COLLECTION;\n/**\n * Control what types you allow to be partially parsed.\n * The default is to allow all types to be partially parsed, which in most casees is the best option.\n * @example\n * If you don't want to allow partial objects, you can use the following code:\n * ```ts\n * import { Allow, parse } from \"partial-json\";\n * parse(`[{\"a\": 1, \"b\": 2}, {\"a\": 3,`, Allow.ARR); // [ { a: 1, b: 2 } ]\n * ```\n * Or you can use `~` to disallow a type:\n * ```ts\n * parse(`[{\"a\": 1, \"b\": 2}, {\"a\": 3,`, ~Allow.OBJ); // [ { a: 1, b: 2 } ]\n * ```\n * @example\n * If you don't want to allow partial strings, you can use the following code:\n * ```ts\n * import { Allow, parse } from \"partial-json\";\n * parse(`[\"complete string\", \"incompl`, ~Allow.STR); // [ 'complete string' ]\n * ```\n */\nexports.Allow = { STR: exports.STR, NUM: exports.NUM, ARR: exports.ARR, OBJ: exports.OBJ, NULL: exports.NULL, BOOL: exports.BOOL, NAN: exports.NAN, INFINITY: exports.INFINITY, _INFINITY: exports._INFINITY, INF: exports.INF, SPECIAL: exports.SPECIAL, ATOM: exports.ATOM, COLLECTION: exports.COLLECTION, ALL: exports.ALL };\nexports.default = exports.Allow;\n", "\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Allow = exports.MalformedJSON = exports.PartialJSON = exports.parseJSON = exports.parse = void 0;\nconst options_1 = require(\"./options\");\nObject.defineProperty(exports, \"Allow\", { enumerable: true, get: function () { return options_1.Allow; } });\n__exportStar(require(\"./options\"), exports);\nclass PartialJSON extends Error {\n}\nexports.PartialJSON = PartialJSON;\nclass MalformedJSON extends Error {\n}\nexports.MalformedJSON = MalformedJSON;\n/**\n * Parse incomplete JSON\n * @param {string} jsonString Partial JSON to be parsed\n * @param {number} allowPartial Specify what types are allowed to be partial, see {@link Allow} for details\n * @returns The parsed JSON\n * @throws {PartialJSON} If the JSON is incomplete (related to the `allow` parameter)\n * @throws {MalformedJSON} If the JSON is malformed\n */\nfunction parseJSON(jsonString, allowPartial = options_1.Allow.ALL) {\n    if (typeof jsonString !== \"string\") {\n        throw new TypeError(`expecting str, got ${typeof jsonString}`);\n    }\n    if (!jsonString.trim()) {\n        throw new Error(`${jsonString} is empty`);\n    }\n    return _parseJSON(jsonString.trim(), allowPartial);\n}\nexports.parseJSON = parseJSON;\n;\nconst _parseJSON = (jsonString, allow) => {\n    const length = jsonString.length;\n    let index = 0;\n    const markPartialJSON = (msg) => {\n        throw new PartialJSON(`${msg} at position ${index}`);\n    };\n    const throwMalformedError = (msg) => {\n        throw new MalformedJSON(`${msg} at position ${index}`);\n    };\n    const parseAny = () => {\n        skipBlank();\n        if (index >= length)\n            markPartialJSON(\"Unexpected end of input\");\n        if (jsonString[index] === '\"')\n            return parseStr();\n        if (jsonString[index] === \"{\")\n            return parseObj();\n        if (jsonString[index] === \"[\")\n            return parseArr();\n        if (jsonString.substring(index, index + 4) === \"null\" || (options_1.Allow.NULL & allow && length - index < 4 && \"null\".startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return null;\n        }\n        if (jsonString.substring(index, index + 4) === \"true\" || (options_1.Allow.BOOL & allow && length - index < 4 && \"true\".startsWith(jsonString.substring(index)))) {\n            index += 4;\n            return true;\n        }\n        if (jsonString.substring(index, index + 5) === \"false\" || (options_1.Allow.BOOL & allow && length - index < 5 && \"false\".startsWith(jsonString.substring(index)))) {\n            index += 5;\n            return false;\n        }\n        if (jsonString.substring(index, index + 8) === \"Infinity\" || (options_1.Allow.INFINITY & allow && length - index < 8 && \"Infinity\".startsWith(jsonString.substring(index)))) {\n            index += 8;\n            return Infinity;\n        }\n        if (jsonString.substring(index, index + 9) === \"-Infinity\" || (options_1.Allow._INFINITY & allow && 1 < length - index && length - index < 9 && \"-Infinity\".startsWith(jsonString.substring(index)))) {\n            index += 9;\n            return -Infinity;\n        }\n        if (jsonString.substring(index, index + 3) === \"NaN\" || (options_1.Allow.NAN & allow && length - index < 3 && \"NaN\".startsWith(jsonString.substring(index)))) {\n            index += 3;\n            return NaN;\n        }\n        return parseNum();\n    };\n    const parseStr = () => {\n        const start = index;\n        let escape = false;\n        index++; // skip initial quote\n        while (index < length && (jsonString[index] !== '\"' || (escape && jsonString[index - 1] === \"\\\\\"))) {\n            escape = jsonString[index] === \"\\\\\" ? !escape : false;\n            index++;\n        }\n        if (jsonString.charAt(index) == '\"') {\n            try {\n                return JSON.parse(jsonString.substring(start, ++index - Number(escape)));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n        else if (options_1.Allow.STR & allow) {\n            try {\n                return JSON.parse(jsonString.substring(start, index - Number(escape)) + '\"');\n            }\n            catch (e) {\n                // SyntaxError: Invalid escape sequence\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf(\"\\\\\")) + '\"');\n            }\n        }\n        markPartialJSON(\"Unterminated string literal\");\n    };\n    const parseObj = () => {\n        index++; // skip initial brace\n        skipBlank();\n        const obj = {};\n        try {\n            while (jsonString[index] !== \"}\") {\n                skipBlank();\n                if (index >= length && options_1.Allow.OBJ & allow)\n                    return obj;\n                const key = parseStr();\n                skipBlank();\n                index++; // skip colon\n                try {\n                    const value = parseAny();\n                    obj[key] = value;\n                }\n                catch (e) {\n                    if (options_1.Allow.OBJ & allow)\n                        return obj;\n                    else\n                        throw e;\n                }\n                skipBlank();\n                if (jsonString[index] === \",\")\n                    index++; // skip comma\n            }\n        }\n        catch (e) {\n            if (options_1.Allow.OBJ & allow)\n                return obj;\n            else\n                markPartialJSON(\"Expected '}' at end of object\");\n        }\n        index++; // skip final brace\n        return obj;\n    };\n    const parseArr = () => {\n        index++; // skip initial bracket\n        const arr = [];\n        try {\n            while (jsonString[index] !== \"]\") {\n                arr.push(parseAny());\n                skipBlank();\n                if (jsonString[index] === \",\") {\n                    index++; // skip comma\n                }\n            }\n        }\n        catch (e) {\n            if (options_1.Allow.ARR & allow) {\n                return arr;\n            }\n            markPartialJSON(\"Expected ']' at end of array\");\n        }\n        index++; // skip final bracket\n        return arr;\n    };\n    const parseNum = () => {\n        if (index === 0) {\n            if (jsonString === \"-\")\n                throwMalformedError(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString);\n            }\n            catch (e) {\n                if (options_1.Allow.NUM & allow)\n                    try {\n                        return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(\"e\")));\n                    }\n                    catch (e) { }\n                throwMalformedError(String(e));\n            }\n        }\n        const start = index;\n        if (jsonString[index] === \"-\")\n            index++;\n        while (jsonString[index] && \",]}\".indexOf(jsonString[index]) === -1)\n            index++;\n        if (index == length && !(options_1.Allow.NUM & allow))\n            markPartialJSON(\"Unterminated number literal\");\n        try {\n            return JSON.parse(jsonString.substring(start, index));\n        }\n        catch (e) {\n            if (jsonString.substring(start, index) === \"-\")\n                markPartialJSON(\"Not sure what '-' is\");\n            try {\n                return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf(\"e\")));\n            }\n            catch (e) {\n                throwMalformedError(String(e));\n            }\n        }\n    };\n    const skipBlank = () => {\n        while (index < length && \" \\n\\r\\t\".includes(jsonString[index])) {\n            index++;\n        }\n    };\n    return parseAny();\n};\nconst parse = parseJSON;\nexports.parse = parse;\n", "export * from \"./errors.js\";\nexport * from \"./helpers/parseUtil.js\";\nexport * from \"./helpers/typeAliases.js\";\nexport * from \"./helpers/util.js\";\nexport * from \"./types.js\";\nexport * from \"./ZodError.js\";\n", "export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n", "import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n", "import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n", "import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n", "import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n", "export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n", "import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n", "import { z } from \"zod\";\n\nexport const FunctionCallSchema = z.object({\n  name: z.string(),\n  arguments: z.string(),\n});\n\nexport const ToolCallSchema = z.object({\n  id: z.string(),\n  type: z.literal(\"function\"),\n  function: FunctionCallSchema,\n});\n\nexport const BaseMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string().optional(),\n  name: z.string().optional(),\n});\n\nexport const TextInputContentSchema = z.object({\n  type: z.literal(\"text\"),\n  text: z.string(),\n});\n\nconst BinaryInputContentObjectSchema = z.object({\n  type: z.literal(\"binary\"),\n  mimeType: z.string(),\n  id: z.string().optional(),\n  url: z.string().optional(),\n  data: z.string().optional(),\n  filename: z.string().optional(),\n});\n\nconst ensureBinaryPayload = (\n  value: { id?: string; url?: string; data?: string },\n  ctx: z.RefinementCtx,\n) => {\n  if (!value.id && !value.url && !value.data) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"BinaryInputContent requires at least one of id, url, or data.\",\n      path: [\"id\"],\n    });\n  }\n};\n\nexport const BinaryInputContentSchema = BinaryInputContentObjectSchema.superRefine((value, ctx) => {\n  ensureBinaryPayload(value, ctx);\n});\n\nconst InputContentBaseSchema = z.discriminatedUnion(\"type\", [\n  TextInputContentSchema,\n  BinaryInputContentObjectSchema,\n]);\n\nexport const InputContentSchema = InputContentBaseSchema.superRefine((value, ctx) => {\n  if (value.type === \"binary\") {\n    ensureBinaryPayload(value, ctx);\n  }\n});\n\nexport const DeveloperMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"developer\"),\n  content: z.string(),\n});\n\nexport const SystemMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"system\"),\n  content: z.string(),\n});\n\nexport const AssistantMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"assistant\"),\n  content: z.string().optional(),\n  toolCalls: z.array(ToolCallSchema).optional(),\n});\n\nexport const UserMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"user\"),\n  content: z.union([z.string(), z.array(InputContentSchema)]),\n});\n\nexport const ToolMessageSchema = z.object({\n  id: z.string(),\n  content: z.string(),\n  role: z.literal(\"tool\"),\n  toolCallId: z.string(),\n  error: z.string().optional(),\n});\n\nexport const ActivityMessageSchema = z.object({\n  id: z.string(),\n  role: z.literal(\"activity\"),\n  activityType: z.string(),\n  content: z.record(z.any()),\n});\n\nexport const MessageSchema = z.discriminatedUnion(\"role\", [\n  DeveloperMessageSchema,\n  SystemMessageSchema,\n  AssistantMessageSchema,\n  UserMessageSchema,\n  ToolMessageSchema,\n  ActivityMessageSchema,\n]);\n\nexport const RoleSchema = z.union([\n  z.literal(\"developer\"),\n  z.literal(\"system\"),\n  z.literal(\"assistant\"),\n  z.literal(\"user\"),\n  z.literal(\"tool\"),\n  z.literal(\"activity\"),\n]);\n\nexport const ContextSchema = z.object({\n  description: z.string(),\n  value: z.string(),\n});\n\nexport const ToolSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  parameters: z.any(), // JSON Schema for the tool parameters\n});\n\nexport const RunAgentInputSchema = z.object({\n  threadId: z.string(),\n  runId: z.string(),\n  parentRunId: z.string().optional(),\n  state: z.any(),\n  messages: z.array(MessageSchema),\n  tools: z.array(ToolSchema),\n  context: z.array(ContextSchema),\n  forwardedProps: z.any(),\n});\n\nexport const StateSchema = z.any();\n\nexport type ToolCall = z.infer<typeof ToolCallSchema>;\nexport type FunctionCall = z.infer<typeof FunctionCallSchema>;\nexport type TextInputContent = z.infer<typeof TextInputContentSchema>;\nexport type BinaryInputContent = z.infer<typeof BinaryInputContentSchema>;\nexport type InputContent = z.infer<typeof InputContentSchema>;\nexport type DeveloperMessage = z.infer<typeof DeveloperMessageSchema>;\nexport type SystemMessage = z.infer<typeof SystemMessageSchema>;\nexport type AssistantMessage = z.infer<typeof AssistantMessageSchema>;\nexport type UserMessage = z.infer<typeof UserMessageSchema>;\nexport type ToolMessage = z.infer<typeof ToolMessageSchema>;\nexport type ActivityMessage = z.infer<typeof ActivityMessageSchema>;\nexport type Message = z.infer<typeof MessageSchema>;\nexport type Context = z.infer<typeof ContextSchema>;\nexport type Tool = z.infer<typeof ToolSchema>;\nexport type RunAgentInput = z.infer<typeof RunAgentInputSchema>;\nexport type State = z.infer<typeof StateSchema>;\nexport type Role = z.infer<typeof RoleSchema>;\n\nexport class AGUIError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class AGUIConnectNotImplementedError extends AGUIError {\n  constructor() {\n    super(\"Connect not implemented. This method is not supported by the current agent.\");\n  }\n}\n", "import { z } from \"zod\";\nimport { MessageSchema, StateSchema, RunAgentInputSchema } from \"./types\";\n\n// Text messages can have any role except \"tool\"\nconst TextMessageRoleSchema = z.union([\n  z.literal(\"developer\"),\n  z.literal(\"system\"),\n  z.literal(\"assistant\"),\n  z.literal(\"user\"),\n]);\n\nexport enum EventType {\n  TEXT_MESSAGE_START = \"TEXT_MESSAGE_START\",\n  TEXT_MESSAGE_CONTENT = \"TEXT_MESSAGE_CONTENT\",\n  TEXT_MESSAGE_END = \"TEXT_MESSAGE_END\",\n  TEXT_MESSAGE_CHUNK = \"TEXT_MESSAGE_CHUNK\",\n  THINKING_TEXT_MESSAGE_START = \"THINKING_TEXT_MESSAGE_START\",\n  THINKING_TEXT_MESSAGE_CONTENT = \"THINKING_TEXT_MESSAGE_CONTENT\",\n  THINKING_TEXT_MESSAGE_END = \"THINKING_TEXT_MESSAGE_END\",\n  TOOL_CALL_START = \"TOOL_CALL_START\",\n  TOOL_CALL_ARGS = \"TOOL_CALL_ARGS\",\n  TOOL_CALL_END = \"TOOL_CALL_END\",\n  TOOL_CALL_CHUNK = \"TOOL_CALL_CHUNK\",\n  TOOL_CALL_RESULT = \"TOOL_CALL_RESULT\",\n  THINKING_START = \"THINKING_START\",\n  THINKING_END = \"THINKING_END\",\n  STATE_SNAPSHOT = \"STATE_SNAPSHOT\",\n  STATE_DELTA = \"STATE_DELTA\",\n  MESSAGES_SNAPSHOT = \"MESSAGES_SNAPSHOT\",\n  ACTIVITY_SNAPSHOT = \"ACTIVITY_SNAPSHOT\",\n  ACTIVITY_DELTA = \"ACTIVITY_DELTA\",\n  RAW = \"RAW\",\n  CUSTOM = \"CUSTOM\",\n  RUN_STARTED = \"RUN_STARTED\",\n  RUN_FINISHED = \"RUN_FINISHED\",\n  RUN_ERROR = \"RUN_ERROR\",\n  STEP_STARTED = \"STEP_STARTED\",\n  STEP_FINISHED = \"STEP_FINISHED\",\n}\n\nexport const BaseEventSchema = z.object({\n  type: z.nativeEnum(EventType),\n  timestamp: z.number().optional(),\n  rawEvent: z.any().optional(),\n});\n\nexport const TextMessageStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_START),\n  messageId: z.string(),\n  role: TextMessageRoleSchema.default(\"assistant\"),\n});\n\nexport const TextMessageContentEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_CONTENT),\n  messageId: z.string(),\n  delta: z.string().refine((s) => s.length > 0, \"Delta must not be an empty string\"),\n});\n\nexport const TextMessageEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_END),\n  messageId: z.string(),\n});\n\nexport const TextMessageChunkEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_CHUNK),\n  messageId: z.string().optional(),\n  role: TextMessageRoleSchema.optional(),\n  delta: z.string().optional(),\n});\n\nexport const ThinkingTextMessageStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_START),\n});\n\nexport const ThinkingTextMessageContentEventSchema = TextMessageContentEventSchema.omit({\n  messageId: true,\n  type: true,\n}).extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_CONTENT),\n});\n\nexport const ThinkingTextMessageEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_END),\n});\n\nexport const ToolCallStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_START),\n  toolCallId: z.string(),\n  toolCallName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const ToolCallArgsEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_ARGS),\n  toolCallId: z.string(),\n  delta: z.string(),\n});\n\nexport const ToolCallEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_END),\n  toolCallId: z.string(),\n});\n\nexport const ToolCallResultEventSchema = BaseEventSchema.extend({\n  messageId: z.string(),\n  type: z.literal(EventType.TOOL_CALL_RESULT),\n  toolCallId: z.string(),\n  content: z.string(),\n  role: z.literal(\"tool\").optional(),\n});\n\nexport const ToolCallChunkEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_CHUNK),\n  toolCallId: z.string().optional(),\n  toolCallName: z.string().optional(),\n  parentMessageId: z.string().optional(),\n  delta: z.string().optional(),\n});\n\nexport const ThinkingStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_START),\n  title: z.string().optional(),\n});\n\nexport const ThinkingEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_END),\n});\n\nexport const StateSnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STATE_SNAPSHOT),\n  snapshot: StateSchema,\n});\n\nexport const StateDeltaEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STATE_DELTA),\n  delta: z.array(z.any()), // JSON Patch (RFC 6902)\n});\n\nexport const MessagesSnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.MESSAGES_SNAPSHOT),\n  messages: z.array(MessageSchema),\n});\n\nexport const ActivitySnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.ACTIVITY_SNAPSHOT),\n  messageId: z.string(),\n  activityType: z.string(),\n  content: z.record(z.any()),\n  replace: z.boolean().optional().default(true),\n});\n\nexport const ActivityDeltaEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.ACTIVITY_DELTA),\n  messageId: z.string(),\n  activityType: z.string(),\n  patch: z.array(z.any()),\n});\n\nexport const RawEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RAW),\n  event: z.any(),\n  source: z.string().optional(),\n});\n\nexport const CustomEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.CUSTOM),\n  name: z.string(),\n  value: z.any(),\n});\n\nexport const RunStartedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_STARTED),\n  threadId: z.string(),\n  runId: z.string(),\n  parentRunId: z.string().optional(),\n  input: RunAgentInputSchema.optional(),\n});\n\nexport const RunFinishedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_FINISHED),\n  threadId: z.string(),\n  runId: z.string(),\n  result: z.any().optional(),\n});\n\nexport const RunErrorEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_ERROR),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const StepStartedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STEP_STARTED),\n  stepName: z.string(),\n});\n\nexport const StepFinishedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STEP_FINISHED),\n  stepName: z.string(),\n});\n\nexport const EventSchemas = z.discriminatedUnion(\"type\", [\n  TextMessageStartEventSchema,\n  TextMessageContentEventSchema,\n  TextMessageEndEventSchema,\n  TextMessageChunkEventSchema,\n  ThinkingStartEventSchema,\n  ThinkingEndEventSchema,\n  ThinkingTextMessageStartEventSchema,\n  ThinkingTextMessageContentEventSchema,\n  ThinkingTextMessageEndEventSchema,\n  ToolCallStartEventSchema,\n  ToolCallArgsEventSchema,\n  ToolCallEndEventSchema,\n  ToolCallChunkEventSchema,\n  ToolCallResultEventSchema,\n  StateSnapshotEventSchema,\n  StateDeltaEventSchema,\n  MessagesSnapshotEventSchema,\n  ActivitySnapshotEventSchema,\n  ActivityDeltaEventSchema,\n  RawEventSchema,\n  CustomEventSchema,\n  RunStartedEventSchema,\n  RunFinishedEventSchema,\n  RunErrorEventSchema,\n  StepStartedEventSchema,\n  StepFinishedEventSchema,\n]);\n\nexport type BaseEvent = z.infer<typeof BaseEventSchema>;\nexport type TextMessageStartEvent = z.infer<typeof TextMessageStartEventSchema>;\nexport type TextMessageContentEvent = z.infer<typeof TextMessageContentEventSchema>;\nexport type TextMessageEndEvent = z.infer<typeof TextMessageEndEventSchema>;\nexport type TextMessageChunkEvent = z.infer<typeof TextMessageChunkEventSchema>;\nexport type ThinkingTextMessageStartEvent = z.infer<typeof ThinkingTextMessageStartEventSchema>;\nexport type ThinkingTextMessageContentEvent = z.infer<typeof ThinkingTextMessageContentEventSchema>;\nexport type ThinkingTextMessageEndEvent = z.infer<typeof ThinkingTextMessageEndEventSchema>;\nexport type ToolCallStartEvent = z.infer<typeof ToolCallStartEventSchema>;\nexport type ToolCallArgsEvent = z.infer<typeof ToolCallArgsEventSchema>;\nexport type ToolCallEndEvent = z.infer<typeof ToolCallEndEventSchema>;\nexport type ToolCallChunkEvent = z.infer<typeof ToolCallChunkEventSchema>;\nexport type ToolCallResultEvent = z.infer<typeof ToolCallResultEventSchema>;\nexport type ThinkingStartEvent = z.infer<typeof ThinkingStartEventSchema>;\nexport type ThinkingEndEvent = z.infer<typeof ThinkingEndEventSchema>;\nexport type StateSnapshotEvent = z.infer<typeof StateSnapshotEventSchema>;\nexport type StateDeltaEvent = z.infer<typeof StateDeltaEventSchema>;\nexport type MessagesSnapshotEvent = z.infer<typeof MessagesSnapshotEventSchema>;\nexport type ActivitySnapshotEvent = z.infer<typeof ActivitySnapshotEventSchema>;\nexport type ActivityDeltaEvent = z.infer<typeof ActivityDeltaEventSchema>;\nexport type RawEvent = z.infer<typeof RawEventSchema>;\nexport type CustomEvent = z.infer<typeof CustomEventSchema>;\nexport type RunStartedEvent = z.infer<typeof RunStartedEventSchema>;\nexport type RunFinishedEvent = z.infer<typeof RunFinishedEventSchema>;\nexport type RunErrorEvent = z.infer<typeof RunErrorEventSchema>;\nexport type StepStartedEvent = z.infer<typeof StepStartedEventSchema>;\nexport type StepFinishedEvent = z.infer<typeof StepFinishedEventSchema>;\n", "/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n", "/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements SubscriptionLike {\n  /** @nocollapse */\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @nocollapse\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as (((value: T) => void) | undefined),\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent\n * @param subscriber The stopped subscriber\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n", "import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new observable\n   * @nocollapse\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param operator the operator defining the operation to take on the observable\n   * @return a new observable with the Operator applied\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   * or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   * Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {Subscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next a handler for each value emitted by the observable\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @method toPromise\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n", "import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n *\n * @class Action<T>\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler.\n   * @return {void}\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   * @return {any}\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @class Scheduler\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return {number} A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param {function(state: ?T): ?Subscription} work A function representing a\n   * task, or some unit of work to be executed by the Scheduler.\n   * @param {number} [delay] Time to wait before executing the work, where the\n   * time unit is implicit and defined by the Scheduler itself.\n   * @param {T} [state] Some contextual data that the `work` function uses when\n   * called by the Scheduler.\n   * @return {Subscription} A subscription in order to be able to unsubscribe\n   * the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @type {boolean}\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @type {any}\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "import { Observable } from '../Observable';\n\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { Subscription } from '../Subscription';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { operate } from '../util/lift';\n\n/* tslint:disable:max-line-length */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n/* tslint:enable:max-line-length */\n\n/**\n * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n *\n * <span class=\"informal\">\n * It only listens to the error channel and ignores notifications.\n * Handles errors from the source observable, and maps them to a new observable.\n * The error may also be rethrown, or a new error can be thrown to emit an error from the result.\n * </span>\n *\n * ![](catch.png)\n *\n * This operator handles errors, but forwards along all other events to the resulting observable.\n * If the source observable terminates with an error, it will map that error to a new observable,\n * subscribe to it, and forward all of its events to the resulting observable.\n *\n * ## Examples\n *\n * Continue with a different Observable when there's an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => of('I', 'II', 'III', 'IV', 'V'))\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, I, II, III, IV, V\n * ```\n *\n * Retry the caught source Observable again in case of error, similar to `retry()` operator\n *\n * ```ts\n * import { of, map, catchError, take } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError((err, caught) => caught),\n *     take(30)\n *   )\n *   .subscribe(x => console.log(x));\n *   // 1, 2, 3, 1, 2, 3, ...\n * ```\n *\n * Throw a new error when the source Observable throws an error\n *\n * ```ts\n * import { of, map, catchError } from 'rxjs';\n *\n * of(1, 2, 3, 4, 5)\n *   .pipe(\n *     map(n => {\n *       if (n === 4) {\n *         throw 'four!';\n *       }\n *       return n;\n *     }),\n *     catchError(err => {\n *       throw 'error in source. Details: ' + err;\n *     })\n *   )\n *   .subscribe({\n *     next: x => console.log(x),\n *     error: err => console.log(err)\n *   });\n *   // 1, 2, 3, error in source. Details: four!\n * ```\n *\n * @see {@link onErrorResumeNext}\n * @see {@link repeat}\n * @see {@link repeatWhen}\n * @see {@link retry }\n * @see {@link retryWhen}\n *\n * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n * is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n * is returned by the `selector` will be used to continue the observable chain.\n * @return A function that returns an Observable that originates from either\n * the source or the Observable returned by the `selector` function.\n */\nexport function catchError<T, O extends ObservableInput<any>>(\n  selector: (err: any, caught: Observable<T>) => O\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  return operate((source, subscriber) => {\n    let innerSub: Subscription | null = null;\n    let syncUnsub = false;\n    let handledResult: Observable<ObservedValueOf<O>>;\n\n    innerSub = source.subscribe(\n      createOperatorSubscriber(subscriber, undefined, undefined, (err) => {\n        handledResult = innerFrom(selector(err, catchError(selector)(source)));\n        if (innerSub) {\n          innerSub.unsubscribe();\n          innerSub = null;\n          handledResult.subscribe(subscriber);\n        } else {\n          // We don't have an innerSub yet, that means the error was synchronous\n          // because the subscribe call hasn't returned yet.\n          syncUnsub = true;\n        }\n      })\n    );\n\n    if (syncUnsub) {\n      // We have a synchronous error, we need to make sure to\n      // finalize right away. This ensures that callbacks in the `finalize` operator are called\n      // at the right time, and that finalization occurs at the expected\n      // time between the source error and the subscription to the\n      // next observable.\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult!.subscribe(subscriber);\n    }\n  });\n}\n", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param {ObservableInput<T>} A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param {SchedulerLike} An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return {Observable<T>}\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @param {number} [concurrent=Infinity] Maximum number of input\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n", "import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param {number} [concurrent=Infinity] Maximum number of inner\n * Observables being subscribed to concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n", "import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param {function(value: T, ?index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n", "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @nocollapse\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return {Observable} Observable that the Subject casts to\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\n/**\n * @class AnonymousSubject<T>\n */\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n", "import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param {...T} values A comma separated list of arguments you want to be emitted\n * @return {Observable} An Observable that emits the arguments\n * described above and then completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param {T} value The `next` value.\n   * @return {Notification<T>} The \"next\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param {any} [err] The `error` error.\n   * @return {Notification<T>} The \"error\" Notification representing the\n   * argument.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return {Notification<any>} The valueless \"complete\" Notification.\n   * @nocollapse\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n *\n * @class ArgumentOutOfRangeError\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n *\n * @class EmptyError\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass((_super) => function EmptyErrorImpl(this: any) {\n  _super(this);\n  this.name = 'EmptyError';\n  this.message = 'no elements in sequence';\n});\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param {function} callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n *\n * @class BehaviorSubject<T>\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n *\n * @class AsyncSubject<T>\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param bufferSize The size of the buffer to replay on subscription\n   * @param windowTime The amount of time the buffered items will stay buffered\n   * @param timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n *\n * @class SequenceError\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n *\n * @class NotFoundError\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n", "import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param {function(value: T, index: number): ObservableInput} project A function\n * that, when applied to an item emitted by the source Observable, returns an\n * Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param {Observable} notifier The Observable whose first emitted value will\n * cause the output Observable of `takeUntil` to stop emitting values from the\n * source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n", "import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n *\n * @class TimeoutError\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\n\nexport interface LastValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function lastValueFrom<T, D>(source: Observable<T>, config: LastValueFromConfig<D>): Promise<T | D>;\nexport function lastValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * waiting for it to complete, and resolving the returned promise with the\n * last value from the observed stream.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will complete. If the source\n * observable does not complete, you will end up with a promise that is hung up, and\n * potentially all of the state of an async function hanging out in memory. To avoid\n * this situation, look into adding something like {@link timeout}, {@link take},\n * {@link takeWhile}, or {@link takeUntil} amongst others.\n *\n * ## Example\n *\n * Wait for the last value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, take, lastValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000).pipe(take(10));\n *   const finalNumber = await lastValueFrom(source$);\n *   console.log(`The final number is ${ finalNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The final number is 9'\n * ```\n *\n * @see {@link firstValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function lastValueFrom<T, D>(source: Observable<T>, config?: LastValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    let _hasValue = false;\n    let _value: T;\n    source.subscribe({\n      next: (value) => {\n        _value = value;\n        _hasValue = true;\n      },\n      error: reject,\n      complete: () => {\n        if (_hasValue) {\n          resolve(_value);\n        } else if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { ObservedValueOf, ObservableInput } from '../types';\nimport { innerFrom } from './innerFrom';\n\n/**\n * Creates an Observable that, on subscribe, calls an Observable factory to\n * make an Observable for each new Observer.\n *\n * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n * is subscribed.\n * </span>\n *\n * ![](defer.png)\n *\n * `defer` allows you to create an Observable only when the Observer\n * subscribes. It waits until an Observer subscribes to it, calls the given\n * factory function to get an Observable -- where a factory function typically\n * generates a new Observable -- and subscribes the Observer to this Observable.\n * In case the factory function returns a falsy value, then EMPTY is used as\n * Observable instead. Last but not least, an exception during the factory\n * function call is transferred to the Observer by calling `error`.\n *\n * ## Example\n *\n * Subscribe to either an Observable of clicks or an Observable of interval, at random\n *\n * ```ts\n * import { defer, fromEvent, interval } from 'rxjs';\n *\n * const clicksOrInterval = defer(() => {\n *   return Math.random() > 0.5\n *     ? fromEvent(document, 'click')\n *     : interval(1000);\n * });\n * clicksOrInterval.subscribe(x => console.log(x));\n *\n * // Results in the following behavior:\n * // If the result of Math.random() is greater than 0.5 it will listen\n * // for clicks anywhere on the \"document\"; when document is clicked it\n * // will log a MouseEvent object to the console. If the result is less\n * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n * ```\n *\n * @see {@link Observable}\n *\n * @param {function(): ObservableInput} observableFactory The Observable\n * factory function to invoke for each Observer that subscribes to the output\n * Observable. May also return a Promise, which will be converted on the fly\n * to an Observable.\n * @return {Observable} An Observable whose Observers' subscriptions trigger\n * an invocation of the given Observable factory function.\n */\nexport function defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>> {\n  return new Observable<ObservedValueOf<R>>((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "import { PatchError, _deepClone, isInteger, unescapePathComponent, hasUndefined } from './helpers.mjs';\nexport var JsonPatchError = PatchError;\nexport var deepClone = _deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nvar objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed: removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        var removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = _deepClone(removed);\n        }\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\n        return { newDocument: document, removed: removed };\n    },\n    copy: function (obj, key, document) {\n        var valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, { op: \"add\", path: this.path, value: _deepClone(valueToCopy) });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals(obj[key], this.value) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    }\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if (isInteger(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else { // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nexport function getValueByPointer(document, pointer) {\n    if (pointer == '') {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nexport function applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {\n    if (validateOperation === void 0) { validateOperation = false; }\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (index === void 0) { index = 0; }\n    if (validateOperation) {\n        if (typeof validateOperation == 'function') {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        var returnValue = { newDocument: document };\n        if (operation.op === 'add') {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === 'replace') {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === 'move') { // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === 'test') {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === 'remove') { // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === '_get') {\n            operation.value = document;\n            return returnValue;\n        }\n        else { /* bad operation */\n            if (validateOperation) {\n                throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = _deepClone(document);\n        }\n        var path = operation.path || \"\";\n        var keys = path.split('/');\n        var obj = document;\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        var len = keys.length;\n        var existingPathFragment = undefined;\n        var key = void 0;\n        var validateFunction = void 0;\n        if (typeof validateOperation == 'function') {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf('~') != -1) {\n                key = unescapePathComponent(key);\n            }\n            if (banPrototypeModifications &&\n                (key == '__proto__' ||\n                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {\n                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join('/');\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === '-') {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !isInteger(key)) {\n                        throw new JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if (isInteger(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            obj = obj[key];\n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nexport function applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n    }\n    if (!mutateDocument) {\n        document = _deepClone(document);\n    }\n    var results = new Array(patch.length);\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nexport function applyReducer(document, operation, index) {\n    var operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) { // failed test\n        throw new JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n    }\n    return operationResult.newDocument;\n}\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nexport function validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\n        throw new JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n    }\n    else if (typeof operation.path !== 'string') {\n        throw new JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\n        throw new JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && hasUndefined(operation.value)) {\n        throw new JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\n            }\n        }\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\n            if (operation.path !== existingPathFragment) {\n                throw new JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') {\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\n            var error = validate([existingValue], document);\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\n                throw new JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nexport function validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch(_deepClone(document), _deepClone(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nexport function _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\n;\n", "/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nexport function _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        var keys_1 = new Array(obj.length);\n        for (var k = 0; k < keys_1.length; k++) {\n            keys_1[k] = \"\" + k;\n        }\n        return keys_1;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\n;\n/**\n* Deeply clone the object.\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n* @param  {any} obj value to clone\n* @return {any} cloned obj\n*/\nexport function _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\n//3x faster than cached /^\\d+$/.test(str)\nexport function isInteger(str) {\n    var i = 0;\n    var len = str.length;\n    var charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\n/**\n* Escapes a json pointer path\n* @param path The raw pointer\n* @return the Escaped path\n*/\nexport function escapePathComponent(path) {\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\n        return path;\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nexport function unescapePathComponent(path) {\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexport function _getPathRecursive(root, obj) {\n    var found;\n    for (var key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + '/';\n            }\n            else if (typeof root[key] === 'object') {\n                found = _getPathRecursive(root[key], obj);\n                if (found != '') {\n                    return escapePathComponent(key) + '/' + found;\n                }\n            }\n        }\n    }\n    return '';\n}\nexport function getPath(root, obj) {\n    if (root === obj) {\n        return '/';\n    }\n    var path = _getPathRecursive(root, obj);\n    if (path === '') {\n        throw new Error(\"Object not found in root\");\n    }\n    return \"/\" + path;\n}\n/**\n* Recursively checks whether an object has any undefined values inside.\n*/\nexport function hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {\n                if (hasUndefined(obj[i_1])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            var objKeys = _objectKeys(obj);\n            var objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction patchErrorMessageFormatter(message, args) {\n    var messageParts = [message];\n    for (var key in args) {\n        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print\n        if (typeof value !== 'undefined') {\n            messageParts.push(key + \": \" + value);\n        }\n    }\n    return messageParts.join('\\n');\n}\nvar PatchError = /** @class */ (function (_super) {\n    __extends(PatchError, _super);\n    function PatchError(message, name, index, operation, tree) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;\n        _this.name = name;\n        _this.index = index;\n        _this.operation = operation;\n        _this.tree = tree;\n        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });\n        return _this;\n    }\n    return PatchError;\n}(Error));\nexport { PatchError };\n", "/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2021 Joachim Wester\n * MIT license\n */\nimport { _deepClone, _objectKeys, escapePathComponent, hasOwnProperty } from './helpers.mjs';\nimport { applyPatch } from './core.mjs';\nvar beforeDict = new WeakMap();\nvar Mirror = /** @class */ (function () {\n    function Mirror(obj) {\n        this.observers = new Map();\n        this.obj = obj;\n    }\n    return Mirror;\n}());\nvar ObserverInfo = /** @class */ (function () {\n    function ObserverInfo(callback, observer) {\n        this.callback = callback;\n        this.observer = observer;\n    }\n    return ObserverInfo;\n}());\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nexport function unobserve(root, observer) {\n    observer.unobserve();\n}\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nexport function observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        var observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = _deepClone(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = function () {\n            generate(observer);\n        };\n        var fastCheck = function () {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== 'undefined') { //not Node\n            window.addEventListener('mouseup', fastCheck);\n            window.addEventListener('keyup', fastCheck);\n            window.addEventListener('mousedown', fastCheck);\n            window.addEventListener('keydown', fastCheck);\n            window.addEventListener('change', fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = function () {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('mouseup', fastCheck);\n            window.removeEventListener('keyup', fastCheck);\n            window.removeEventListener('mousedown', fastCheck);\n            window.removeEventListener('keydown', fastCheck);\n            window.removeEventListener('change', fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\n/**\n * Generate an array of patches from an observer\n */\nexport function generate(observer, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        applyPatch(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = _objectKeys(obj);\n    var oldKeys = _objectKeys(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if (hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + escapePathComponent(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({ op: \"test\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(oldVal) });\n                    }\n                    patches.push({ op: \"replace\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(newVal) });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(oldVal) });\n            }\n            patches.push({ op: \"remove\", path: path + \"/\" + escapePathComponent(key) });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path: path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n            patches.push({ op: \"add\", path: path + \"/\" + escapePathComponent(key), value: _deepClone(obj[key]) });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nexport function compare(tree1, tree2, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var patches = [];\n    _generate(tree1, tree2, patches, '', invertible);\n    return patches;\n}\n", "export * from './module/core.mjs';\nexport * from './module/duplex.mjs';\nexport {\n    PatchError as JsonPatchError,\n    _deepClone as deepClone,\n    escapePathComponent,\n    unescapePathComponent\n} from './module/helpers.mjs';\n\n\n/**\n * Default export for backwards compat\n */\n\nimport * as core from './module/core.mjs';\nimport * as duplex from './module/duplex.mjs';\nimport {\n    PatchError as JsonPatchError,\n    _deepClone as deepClone,\n    escapePathComponent,\n    unescapePathComponent\n} from './module/helpers.mjs';\n\nexport default Object.assign({}, core, duplex, {\n    JsonPatchError,\n    deepClone,\n    escapePathComponent,\n    unescapePathComponent\n});", "const enum ContextType {\n  TOP_LEVEL = \"topLevel\",\n  STRING = \"string\",\n  STRING_ESCAPED = \"stringEscaped\",\n  STRING_UNICODE = \"stringUnicode\",\n  NUMBER = \"number\",\n  NUMBER_NEEDS_DIGIT = \"numberNeedsDigit\",\n  NUMBER_NEEDS_EXPONENT = \"numberNeedsExponent\",\n  TRUE = \"true\",\n  FALSE = \"false\",\n  NULL = \"null\",\n  ARRAY_NEEDS_VALUE = \"arrayNeedsValue\",\n  ARRAY_NEEDS_COMMA = \"arrayNeedsComma\",\n  OBJECT_NEEDS_KEY = \"objectNeedsKey\",\n  OBJECT_NEEDS_COLON = \"objectNeedsColon\",\n  OBJECT_NEEDS_VALUE = \"objectNeedsValue\",\n  OBJECT_NEEDS_COMMA = \"objectNeedsComma\",\n}\n\nconst enum RespawnReason {\n  STRING_ESCAPE = \"stringEscape\",\n  COLLECTION_ITEM = \"collectionItem\",\n}\n\nfunction isWhitespace(char: string): boolean {\n  return \"\\u0020\\u000D\\u000A\\u0009\".indexOf(char) >= 0;\n}\n\nexport default function untruncateJson(json: string): string {\n  const contextStack: ContextType[] = [ContextType.TOP_LEVEL];\n  let position = 0;\n  let respawnPosition: number | undefined;\n  let respawnStackLength: number | undefined;\n  let respawnReason: RespawnReason | undefined;\n\n  const push = (context: ContextType) => contextStack.push(context);\n  const replace = (context: ContextType) =>\n    (contextStack[contextStack.length - 1] = context);\n  const setRespawn = (reason: RespawnReason) => {\n    if (respawnPosition == null) {\n      respawnPosition = position;\n      respawnStackLength = contextStack.length;\n      respawnReason = reason;\n    }\n  };\n  const clearRespawn = (reason: RespawnReason) => {\n    if (reason === respawnReason) {\n      respawnPosition = undefined;\n      respawnStackLength = undefined;\n      respawnReason = undefined;\n    }\n  };\n  const pop = () => contextStack.pop();\n  const dontConsumeCharacter = () => position--;\n\n  const startAny = (char: string) => {\n    if (\"0\" <= char && char <= \"9\") {\n      push(ContextType.NUMBER);\n      return;\n    }\n    switch (char) {\n      case '\"':\n        push(ContextType.STRING);\n        return;\n      case \"-\":\n        push(ContextType.NUMBER_NEEDS_DIGIT);\n        return;\n      case \"t\":\n        push(ContextType.TRUE);\n        return;\n      case \"f\":\n        push(ContextType.FALSE);\n        return;\n      case \"n\":\n        push(ContextType.NULL);\n        return;\n      case \"[\":\n        push(ContextType.ARRAY_NEEDS_VALUE);\n        return;\n      case \"{\":\n        push(ContextType.OBJECT_NEEDS_KEY);\n        return;\n    }\n  };\n\n  for (const { length } = json; position < length; position++) {\n    const char = json[position];\n    switch (contextStack[contextStack.length - 1]) {\n      case ContextType.TOP_LEVEL:\n        startAny(char);\n        break;\n      case ContextType.STRING:\n        switch (char) {\n          case '\"':\n            pop();\n            break;\n          case \"\\\\\":\n            setRespawn(RespawnReason.STRING_ESCAPE);\n            push(ContextType.STRING_ESCAPED);\n            break;\n        }\n        break;\n      case ContextType.STRING_ESCAPED:\n        if (char === \"u\") {\n          push(ContextType.STRING_UNICODE);\n        } else {\n          clearRespawn(RespawnReason.STRING_ESCAPE);\n          pop();\n        }\n        break;\n      case ContextType.STRING_UNICODE:\n        if (position - json.lastIndexOf(\"u\", position) === 4) {\n          clearRespawn(RespawnReason.STRING_ESCAPE);\n          pop();\n        }\n        break;\n      case ContextType.NUMBER:\n        if (char === \".\") {\n          replace(ContextType.NUMBER_NEEDS_DIGIT);\n        } else if (char === \"e\" || char === \"E\") {\n          replace(ContextType.NUMBER_NEEDS_EXPONENT);\n        } else if (char < \"0\" || char > \"9\") {\n          dontConsumeCharacter();\n          pop();\n        }\n        break;\n      case ContextType.NUMBER_NEEDS_DIGIT:\n        replace(ContextType.NUMBER);\n        break;\n      case ContextType.NUMBER_NEEDS_EXPONENT:\n        if (char === \"+\" || char === \"-\") {\n          replace(ContextType.NUMBER_NEEDS_DIGIT);\n        } else {\n          replace(ContextType.NUMBER);\n        }\n        break;\n      case ContextType.TRUE:\n      case ContextType.FALSE:\n      case ContextType.NULL:\n        if (char < \"a\" || char > \"z\") {\n          dontConsumeCharacter();\n          pop();\n        }\n        break;\n      case ContextType.ARRAY_NEEDS_VALUE:\n        if (char === \"]\") {\n          pop();\n        } else if (!isWhitespace(char)) {\n          clearRespawn(RespawnReason.COLLECTION_ITEM);\n          replace(ContextType.ARRAY_NEEDS_COMMA);\n          startAny(char);\n        }\n        break;\n      case ContextType.ARRAY_NEEDS_COMMA:\n        if (char === \"]\") {\n          pop();\n        } else if (char === \",\") {\n          setRespawn(RespawnReason.COLLECTION_ITEM);\n          replace(ContextType.ARRAY_NEEDS_VALUE);\n        }\n        break;\n      case ContextType.OBJECT_NEEDS_KEY:\n        if (char === \"}\") {\n          pop();\n        } else if (char === '\"') {\n          setRespawn(RespawnReason.COLLECTION_ITEM);\n          replace(ContextType.OBJECT_NEEDS_COLON);\n          push(ContextType.STRING);\n        }\n        break;\n      case ContextType.OBJECT_NEEDS_COLON:\n        if (char === \":\") {\n          replace(ContextType.OBJECT_NEEDS_VALUE);\n        }\n        break;\n      case ContextType.OBJECT_NEEDS_VALUE:\n        if (!isWhitespace(char)) {\n          clearRespawn(RespawnReason.COLLECTION_ITEM);\n          replace(ContextType.OBJECT_NEEDS_COMMA);\n          startAny(char);\n        }\n        break;\n      case ContextType.OBJECT_NEEDS_COMMA:\n        if (char === \"}\") {\n          pop();\n        } else if (char === \",\") {\n          setRespawn(RespawnReason.COLLECTION_ITEM);\n          replace(ContextType.OBJECT_NEEDS_KEY);\n        }\n        break;\n    }\n  }\n\n  if (respawnStackLength != null) {\n    contextStack.length = respawnStackLength;\n  }\n  const result = [\n    respawnPosition != null ? json.slice(0, respawnPosition) : json,\n  ];\n  const finishWord = (word: string) =>\n    result.push(word.slice(json.length - json.lastIndexOf(word[0])));\n  for (let i = contextStack.length - 1; i >= 0; i--) {\n    switch (contextStack[i]) {\n      case ContextType.STRING:\n        result.push('\"');\n        break;\n      case ContextType.NUMBER_NEEDS_DIGIT:\n      case ContextType.NUMBER_NEEDS_EXPONENT:\n        result.push(\"0\");\n        break;\n      case ContextType.TRUE:\n        finishWord(\"true\");\n        break;\n      case ContextType.FALSE:\n        finishWord(\"false\");\n        break;\n      case ContextType.NULL:\n        finishWord(\"null\");\n        break;\n      case ContextType.ARRAY_NEEDS_VALUE:\n      case ContextType.ARRAY_NEEDS_COMMA:\n        result.push(\"]\");\n        break;\n      case ContextType.OBJECT_NEEDS_KEY:\n      case ContextType.OBJECT_NEEDS_COLON:\n      case ContextType.OBJECT_NEEDS_VALUE:\n      case ContextType.OBJECT_NEEDS_COMMA:\n        result.push(\"}\");\n        break;\n    }\n  }\n  return result.join(\"\");\n}\n", "// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */\nexport function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for (let shift = 0; shift < 28; shift += 7) {\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [lowBits, highBits];\n    }\n    for (let shift = 3; shift <= 31; shift += 7) {\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [lowBits, highBits];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */\nexport function varint64write(lo, hi, bytes) {\n    for (let i = 0; i < 28; i = i + 7) {\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = ((lo >>> 28) & 0x0f) | ((hi & 0x07) << 4);\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for (let i = 3; i < 31; i = i + 7) {\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push((hi >>> 31) & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + ((lowBits / TWO_PWR_32_DBL) | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */\nexport function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1fffff) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xffffff;\n    const mid = ((lo >>> 24) | (hi << 8)) & 0xffffff;\n    const high = (hi >> 16) & 0xffff;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return (digitC.toString() +\n        decimalFrom1e7WithLeadingZeros(digitB) +\n        decimalFrom1e7WithLeadingZeros(digitA));\n}\nfunction toUnsigned(lo, hi) {\n    return { lo: lo >>> 0, hi: hi >>> 0 };\n}\nfunction newBits(lo, hi) {\n    return { lo: lo | 0, hi: hi | 0 };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */\nfunction negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    }\n    else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */\nconst decimalFrom1e7WithLeadingZeros = (digit1e7) => {\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */\nexport function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while (value > 0x7f) {\n            bytes.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    }\n    else {\n        for (let i = 0; i < 9; i++) {\n            bytes.push((value & 127) | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */\nexport function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for (let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)\n        b = this.buf[this.pos++];\n    if ((b & 0x80) != 0)\n        throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { int64FromString, int64ToString, uInt64ToString, } from \"./wire/varint.js\";\n/**\n * Int64Support for the current environment.\n */\nexport const protoInt64 = /*@__PURE__*/ makeInt64Support();\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" &&\n        typeof dv.getBigInt64 === \"function\" &&\n        typeof dv.getBigUint64 === \"function\" &&\n        typeof dv.setBigInt64 === \"function\" &&\n        typeof dv.setBigUint64 === \"function\" &&\n        (!!globalThis.Deno ||\n            typeof process != \"object\" ||\n            typeof process.env != \"object\" ||\n            process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\");\n        const MAX = BigInt(\"9223372036854775807\");\n        const UMIN = BigInt(\"0\");\n        const UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse(value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(`invalid int64: ${value}`);\n                }\n                return bi;\n            },\n            uParse(value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(`invalid uint64: ${value}`);\n                }\n                return bi;\n            },\n            enc(value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true),\n                };\n            },\n            uEnc(value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true),\n                };\n            },\n            dec(lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec(lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            },\n        };\n    }\n    return {\n        zero: \"0\",\n        supported: false,\n        parse(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc(value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec(lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec(lo, hi) {\n            return uInt64ToString(lo, hi);\n        },\n    };\n}\nfunction assertInt64String(value) {\n    if (!/^-?[0-9]+$/.test(value)) {\n        throw new Error(\"invalid int64: \" + value);\n    }\n}\nfunction assertUInt64String(value) {\n    if (!/^[0-9]+$/.test(value)) {\n        throw new Error(\"invalid uint64: \" + value);\n    }\n}\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst symbol = Symbol.for(\"@bufbuild/protobuf/text-encoding\");\n/**\n * Protobuf-ES requires the Text Encoding API to convert UTF-8 from and to\n * binary. This WHATWG API is widely available, but it is not part of the\n * ECMAScript standard. On runtimes where it is not available, use this\n * function to provide your own implementation.\n *\n * Note that the Text Encoding API does not provide a way to validate UTF-8.\n * Our implementation falls back to use encodeURIComponent().\n */\nexport function configureTextEncoding(textEncoding) {\n    globalThis[symbol] = textEncoding;\n}\nexport function getTextEncoding() {\n    if (globalThis[symbol] == undefined) {\n        const te = new globalThis.TextEncoder();\n        const td = new globalThis.TextDecoder();\n        globalThis[symbol] = {\n            encodeUtf8(text) {\n                return te.encode(text);\n            },\n            decodeUtf8(bytes) {\n                return td.decode(bytes);\n            },\n            checkUtf8(text) {\n                try {\n                    encodeURIComponent(text);\n                    return true;\n                }\n                catch (_) {\n                    return false;\n                }\n            },\n        };\n    }\n    return globalThis[symbol];\n}\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { varint32read, varint32write, varint64read, varint64write, } from \"./varint.js\";\nimport { protoInt64 } from \"../proto-int64.js\";\nimport { getTextEncoding } from \"./text-encoding.js\";\n/**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */\nexport var WireType;\n(function (WireType) {\n    /**\n     * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n     */\n    WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n     * Used for fixed64, sfixed64, double.\n     * Always 8 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n     * Used for string, bytes, embedded messages, packed repeated fields\n     *\n     * Only repeated numeric types (types which use the varint, 32-bit,\n     * or 64-bit wire types) can be packed. In proto3, such fields are\n     * packed by default.\n     */\n    WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n     * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n     * in editions with message_encoding = DELIMITED.\n     */\n    WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n     * End of a tag-delimited aggregate.\n     */\n    WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n     * Used for fixed32, sfixed32, float.\n     * Always 4 bytes with little-endian byte order.\n     */\n    WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\n/**\n * Maximum value for a 32-bit floating point value (Protobuf FLOAT).\n */\nexport const FLOAT32_MAX = 3.4028234663852886e38;\n/**\n * Minimum value for a 32-bit floating point value (Protobuf FLOAT).\n */\nexport const FLOAT32_MIN = -3.4028234663852886e38;\n/**\n * Maximum value for an unsigned 32-bit integer (Protobuf UINT32, FIXED32).\n */\nexport const UINT32_MAX = 0xffffffff;\n/**\n * Maximum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).\n */\nexport const INT32_MAX = 0x7fffffff;\n/**\n * Minimum value for a signed 32-bit integer (Protobuf INT32, SFIXED32, SINT32).\n */\nexport const INT32_MIN = -0x80000000;\nexport class BinaryWriter {\n    constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {\n        this.encodeUtf8 = encodeUtf8;\n        /**\n         * Previous fork states.\n         */\n        this.stack = [];\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n     * Return all bytes written and reset this writer.\n     */\n    finish() {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n            this.buf = [];\n        }\n        let len = 0;\n        for (let i = 0; i < this.chunks.length; i++)\n            len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for (let i = 0; i < this.chunks.length; i++) {\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n     * Start a new fork for length-delimited data like a message\n     * or a packed repeated field.\n     *\n     * Must be joined later with `join()`.\n     */\n    fork() {\n        this.stack.push({ chunks: this.chunks, buf: this.buf });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n     * Join the last fork. Write its length and bytes, then\n     * return to the previous state.\n     */\n    join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev)\n            throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n     * Writes a tag (field number and wire type).\n     *\n     * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n     *\n     * Generated code should compute the tag ahead of time and call `uint32()`.\n     */\n    tag(fieldNo, type) {\n        return this.uint32(((fieldNo << 3) | type) >>> 0);\n    }\n    /**\n     * Write a chunk of raw bytes.\n     */\n    raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n     * Write a `uint32` value, an unsigned 32 bit varint.\n     */\n    uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while (value > 0x7f) {\n            this.buf.push((value & 0x7f) | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n     * Write a `int32` value, a signed 32 bit varint.\n     */\n    int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `bool` value, a variant.\n     */\n    bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n     * Write a `bytes` value, length-delimited arbitrary data.\n     */\n    bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n     * Write a `string` value, length-delimited data converted to UTF-8 text.\n     */\n    string(value) {\n        let chunk = this.encodeUtf8(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `float` value, 32-bit floating point number.\n     */\n    float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `double` value, a 64-bit floating point number.\n     */\n    double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = ((value << 1) ^ (value >> 31)) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n     * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n     * Write a `int64` value, a signed 64-bit varint.\n     */\n    int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64(value) {\n        const tc = protoInt64.enc(value), \n        // zigzag encode\n        sign = tc.hi >> 31, lo = (tc.lo << 1) ^ sign, hi = ((tc.hi << 1) | (tc.lo >>> 31)) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n     * Write a `uint64` value, an unsigned 64-bit varint.\n     */\n    uint64(value) {\n        const tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nexport class BinaryReader {\n    constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {\n        this.decodeUtf8 = decodeUtf8;\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n         * Read a `uint32` field, an unsigned 32 bit varint.\n         */\n        this.uint32 = varint32read;\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n     * Reads a tag - field number and wire type.\n     */\n    tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5)\n            throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [fieldNo, wireType];\n    }\n    /**\n     * Skip one element and return the skipped data.\n     *\n     * When skipping StartGroup, provide the tags field number to check for\n     * matching field number in the EndGroup tag.\n     */\n    skip(wireType, fieldNo) {\n        let start = this.pos;\n        switch (wireType) {\n            case WireType.Varint:\n                while (this.buf[this.pos++] & 0x80) {\n                    // ignore\n                }\n                break;\n            // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true\n            case WireType.Bit64:\n                this.pos += 4;\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                for (;;) {\n                    const [fn, wt] = this.tag();\n                    if (wt === WireType.EndGroup) {\n                        if (fieldNo !== undefined && fn !== fieldNo) {\n                            throw new Error(\"invalid end group tag\");\n                        }\n                        break;\n                    }\n                    this.skip(wt, fn);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n     * Throws error if position in byte array is out of range.\n     */\n    assertBounds() {\n        if (this.pos > this.len)\n            throw new RangeError(\"premature EOF\");\n    }\n    /**\n     * Read a `int32` field, a signed 32 bit varint.\n     */\n    int32() {\n        return this.uint32() | 0;\n    }\n    /**\n     * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n     */\n    sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return (zze >>> 1) ^ -(zze & 1);\n    }\n    /**\n     * Read a `int64` field, a signed 64-bit varint.\n     */\n    int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n     * Read a `uint64` field, an unsigned 64-bit varint.\n     */\n    uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n     * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n     */\n    sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = ((lo >>> 1) | ((hi & 1) << 31)) ^ s;\n        hi = (hi >>> 1) ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n     * Read a `bool` field, a variant.\n     */\n    bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n     * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n     */\n    fixed32() {\n        // biome-ignore lint/suspicious/noAssignInExpressions: no\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n     */\n    sfixed32() {\n        // biome-ignore lint/suspicious/noAssignInExpressions: no\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n     */\n    fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n     */\n    sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n     * Read a `float` field, 32-bit floating point number.\n     */\n    float() {\n        // biome-ignore lint/suspicious/noAssignInExpressions: no\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n     * Read a `double` field, a 64-bit floating point number.\n     */\n    double() {\n        // biome-ignore lint/suspicious/noAssignInExpressions: no\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n     * Read a `bytes` field, length-delimited arbitrary data.\n     */\n    bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n     * Read a `string` field, length-delimited data converted to UTF-8 text.\n     */\n    string() {\n        return this.decodeUtf8(this.bytes());\n    }\n}\n/**\n * Assert a valid signed protobuf 32-bit integer as a number or string.\n */\nfunction assertInt32(arg) {\n    if (typeof arg == \"string\") {\n        arg = Number(arg);\n    }\n    else if (typeof arg != \"number\") {\n        throw new Error(\"invalid int32: \" + typeof arg);\n    }\n    if (!Number.isInteger(arg) ||\n        arg > INT32_MAX ||\n        arg < INT32_MIN)\n        throw new Error(\"invalid int32: \" + arg);\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer as a number or string.\n */\nfunction assertUInt32(arg) {\n    if (typeof arg == \"string\") {\n        arg = Number(arg);\n    }\n    else if (typeof arg != \"number\") {\n        throw new Error(\"invalid uint32: \" + typeof arg);\n    }\n    if (!Number.isInteger(arg) ||\n        arg > UINT32_MAX ||\n        arg < 0)\n        throw new Error(\"invalid uint32: \" + arg);\n}\n/**\n * Assert a valid protobuf float value as a number or string.\n */\nfunction assertFloat32(arg) {\n    if (typeof arg == \"string\") {\n        const o = arg;\n        arg = Number(arg);\n        if (Number.isNaN(arg) && o !== \"NaN\") {\n            throw new Error(\"invalid float32: \" + o);\n        }\n    }\n    else if (typeof arg != \"number\") {\n        throw new Error(\"invalid float32: \" + typeof arg);\n    }\n    if (Number.isFinite(arg) &&\n        (arg > FLOAT32_MAX || arg < FLOAT32_MIN))\n        throw new Error(\"invalid float32: \" + arg);\n}\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */\nexport var ScalarType;\n(function (ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { isScalarZeroValue, scalarZeroValue } from \"./scalar.js\";\n// bootstrap-inject google.protobuf.FeatureSet.FieldPresence.IMPLICIT: const $name: FeatureSet_FieldPresence.$localName = $number;\nconst IMPLICIT = 2;\nexport const unsafeLocal = Symbol.for(\"reflect unsafe local\");\n/**\n * Return the selected field of a oneof group.\n *\n * @private\n */\nexport function unsafeOneofCase(\n// biome-ignore lint/suspicious/noExplicitAny: `any` is the best choice for dynamic access\ntarget, oneof) {\n    const c = target[oneof.localName].case;\n    if (c === undefined) {\n        return c;\n    }\n    return oneof.fields.find((f) => f.localName === c);\n}\n/**\n * Returns true if the field is set.\n *\n * @private\n */\nexport function unsafeIsSet(\n// biome-ignore lint/suspicious/noExplicitAny: `any` is the best choice for dynamic access\ntarget, field) {\n    const name = field.localName;\n    if (field.oneof) {\n        return target[field.oneof.localName].case === name;\n    }\n    if (field.presence != IMPLICIT) {\n        // Fields with explicit presence have properties on the prototype chain\n        // for default / zero values (except for proto3).\n        return (target[name] !== undefined &&\n            Object.prototype.hasOwnProperty.call(target, name));\n    }\n    switch (field.fieldKind) {\n        case \"list\":\n            return target[name].length > 0;\n        case \"map\":\n            return Object.keys(target[name]).length > 0;\n        case \"scalar\":\n            return !isScalarZeroValue(field.scalar, target[name]);\n        case \"enum\":\n            return target[name] !== field.enum.values[0].number;\n    }\n    throw new Error(\"message field with implicit presence\");\n}\n/**\n * Returns true if the field is set, but only for singular fields with explicit\n * presence (proto2).\n *\n * @private\n */\nexport function unsafeIsSetExplicit(target, localName) {\n    return (Object.prototype.hasOwnProperty.call(target, localName) &&\n        target[localName] !== undefined);\n}\n/**\n * Return a field value, respecting oneof groups.\n *\n * @private\n */\nexport function unsafeGet(target, field) {\n    if (field.oneof) {\n        const oneof = target[field.oneof.localName];\n        if (oneof.case === field.localName) {\n            return oneof.value;\n        }\n        return undefined;\n    }\n    return target[field.localName];\n}\n/**\n * Set a field value, respecting oneof groups.\n *\n * @private\n */\nexport function unsafeSet(target, field, value) {\n    if (field.oneof) {\n        target[field.oneof.localName] = {\n            case: field.localName,\n            value: value,\n        };\n    }\n    else {\n        target[field.localName] = value;\n    }\n}\n/**\n * Resets the field, so that unsafeIsSet() will return false.\n *\n * @private\n */\nexport function unsafeClear(\n// biome-ignore lint/suspicious/noExplicitAny: `any` is the best choice for dynamic access\ntarget, field) {\n    const name = field.localName;\n    if (field.oneof) {\n        const oneofLocalName = field.oneof.localName;\n        if (target[oneofLocalName].case === name) {\n            target[oneofLocalName] = { case: undefined };\n        }\n    }\n    else if (field.presence != IMPLICIT) {\n        // Fields with explicit presence have properties on the prototype chain\n        // for default / zero values (except for proto3). By deleting their own\n        // property, the field is reset.\n        delete target[name];\n    }\n    else {\n        switch (field.fieldKind) {\n            case \"map\":\n                target[name] = {};\n                break;\n            case \"list\":\n                target[name] = [];\n                break;\n            case \"enum\":\n                target[name] = field.enum.values[0].number;\n                break;\n            case \"scalar\":\n                target[name] = scalarZeroValue(field.scalar, field.longAsString);\n                break;\n        }\n    }\n}\n", "// Copyright 2021-2026 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { isMessage } from \"./is-message.js\";\nimport { ScalarType, } from \"./descriptors.js\";\nimport { scalarZeroValue } from \"./reflect/scalar.js\";\nimport { isObject } from \"./reflect/guard.js\";\nimport { unsafeGet, unsafeOneofCase, unsafeSet } from \"./reflect/unsafe.js\";\nimport { isWrapperDesc } from \"./wkt/wrappers.js\";\n// bootstrap-inject google.protobuf.Edition.EDITION_PROTO3: const $name: Edition.$localName = $number;\nconst EDITION_PROTO3 = 999;\n// bootstrap-inject google.protobuf.Edition.EDITION_PROTO2: const $name: Edition.$localName = $number;\nconst EDITION_PROTO2 = 998;\n// bootstrap-inject google.protobuf.FeatureSet.FieldPresence.IMPLICIT: const $name: FeatureSet_FieldPresence.$localName = $number;\nconst IMPLICIT = 2;\n/**\n * Create a new message instance.\n *\n * The second argument is an optional initializer object, where all fields are\n * optional.\n */\nexport function create(schema, init) {\n    if (isMessage(init, schema)) {\n        return init;\n    }\n    const message = createZeroMessage(schema);\n    if (init !== undefined) {\n        initMessage(schema, message, init);\n    }\n    return message;\n}\n/**\n * Sets field values from a MessageInitShape on a zero message.\n */\nfunction initMessage(messageDesc, message, init) {\n    for (const member of messageDesc.members) {\n        let value = init[member.localName];\n        if (value == null) {\n            // intentionally ignore undefined and null\n            continue;\n        }\n        let field;\n        if (member.kind == \"oneof\") {\n            const oneofField = unsafeOneofCase(init, member);\n            if (!oneofField) {\n                continue;\n            }\n            field = oneofField;\n            value = unsafeGet(init, oneofField);\n        }\n        else {\n            field = member;\n        }\n        switch (field.fieldKind) {\n            case \"message\":\n                value = toMessage(field, value);\n                break;\n            case \"scalar\":\n                value = initScalar(field, value);\n                break;\n            case \"list\":\n                value = initList(field, value);\n                break;\n            case \"map\":\n                value = initMap(field, value);\n                break;\n        }\n        unsafeSet(message, field, value);\n    }\n    return message;\n}\nfunction initScalar(field, value) {\n    if (field.scalar == ScalarType.BYTES) {\n        return toU8Arr(value);\n    }\n    return value;\n}\nfunction initMap(field, value) {\n    if (isObject(value)) {\n        if (field.scalar == ScalarType.BYTES) {\n            return convertObjectValues(value, toU8Arr);\n        }\n        if (field.mapKind == \"message\") {\n            return convertObjectValues(value, (val) => toMessage(field, val));\n        }\n    }\n    return value;\n}\nfunction initList(field, value) {\n    if (Array.isArray(value)) {\n        if (field.scalar == ScalarType.BYTES) {\n            return value.map(toU8Arr);\n        }\n        if (field.listKind == \"message\") {\n            return value.map((item) => toMessage(field, item));\n        }\n    }\n    return value;\n}\nfunction toMessage(field, value) {\n    if (field.fieldKind == \"message\" &&\n        !field.oneof &&\n        isWrapperDesc(field.message)) {\n        // Types from google/protobuf/wrappers.proto are unwrapped when used in\n        // a singular field that is not part of a oneof group.\n        return initScalar(field.message.fields[0], value);\n    }\n    if (isObject(value)) {\n        if (field.message.typeName == \"google.protobuf.Struct\" &&\n            field.parent.typeName !== \"google.protobuf.Value\") {\n            // google.protobuf.Struct is represented with JsonObject when used in a\n            // field, except when used in google.protobuf.Value.\n            return value;\n        }\n        if (!isMessage(value, field.message)) {\n            return create(field.message, value);\n        }\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(value) {\n    return Array.isArray(value) ? new Uint8Array(value) : value;\n}\nfunction convertObjectValues(obj, fn) {\n    const ret = {};\n    for (const entry of Object.entries(obj)) {\n        ret[entry[0]] = fn(entry[1]);\n    }\n    return ret;\n}\nconst tokenZeroMessageField = Symbol();\nconst messagePrototypes = new WeakMap();\n/**\n * Create a zero message.\n */\nfunction createZeroMessage(desc) {\n    let msg;\n    if (!needsPrototypeChain(desc)) {\n        msg = {\n            $typeName: desc.typeName,\n        };\n        for (const member of desc.members) {\n            if (member.kind == \"oneof\" || member.presence == IMPLICIT) {\n                msg[member.localName] = createZeroField(member);\n            }\n        }\n    }\n    else {\n        // Support default values and track presence via the prototype chain\n        const cached = messagePrototypes.get(desc);\n        let prototype;\n        let members;\n        if (cached) {\n            ({ prototype, members } = cached);\n        }\n        else {\n            prototype = {};\n            members = new Set();\n            for (const member of desc.members) {\n                if (member.kind == \"oneof\") {\n                    // we can only put immutable values on the prototype,\n                    // oneof ADTs are mutable\n                    continue;\n                }\n                if (member.fieldKind != \"scalar\" && member.fieldKind != \"enum\") {\n                    // only scalar and enum values are immutable, map, list, and message\n                    // are not\n                    continue;\n                }\n                if (member.presence == IMPLICIT) {\n                    // implicit presence tracks field presence by zero values - e.g. 0, false, \"\", are unset, 1, true, \"x\" are set.\n                    // message, map, list fields are mutable, and also have IMPLICIT presence.\n                    continue;\n                }\n                members.add(member);\n                prototype[member.localName] = createZeroField(member);\n            }\n            messagePrototypes.set(desc, { prototype, members });\n        }\n        msg = Object.create(prototype);\n        msg.$typeName = desc.typeName;\n        for (const member of desc.members) {\n            if (members.has(member)) {\n                continue;\n            }\n            if (member.kind == \"field\") {\n                if (member.fieldKind == \"message\") {\n                    continue;\n                }\n                if (member.fieldKind == \"scalar\" || member.fieldKind == \"enum\") {\n                    if (member.presence != IMPLICIT) {\n                        continue;\n                    }\n                }\n            }\n            msg[member.localName] = createZeroField(member);\n        }\n    }\n    return msg;\n}\n/**\n * Do we need the prototype chain to track field presence?\n */\nfunction needsPrototypeChain(desc) {\n    switch (desc.file.edition) {\n        case EDITION_PROTO3:\n            // proto3 always uses implicit presence, we never need the prototype chain.\n            return false;\n        case EDITION_PROTO2:\n            // proto2 never uses implicit presence, we always need the prototype chain.\n            return true;\n        default:\n            // If a message uses scalar or enum fields with explicit presence, we need\n            // the prototype chain to track presence. This rule does not apply to fields\n            // in a oneof group - they use a different mechanism to track presence.\n            return desc.fields.some((f) => f.presence != IMPLICIT && f.fieldKind != \"message\" && !f.oneof);\n    }\n}\n/**\n * Returns a zero value for oneof groups, and for every field kind except\n * messages. Scalar and enum fields can have default values.\n */\nfunction createZeroField(field) {\n    if (field.kind == \"oneof\") {\n        return { case: undefined };\n    }\n    if (field.fieldKind == \"list\") {\n        return [];\n    }\n    if (field.fieldKind == \"map\") {\n        return {}; // Object.create(null) would be desirable here, but is unsupported by react https://react.dev/reference/react/use-server#serializable-parameters-and-return-values\n    }\n    if (field.fieldKind == \"message\") {\n        return tokenZeroMessageField;\n    }\n    const defaultValue = field.getDefaultValue();\n    if (defaultValue !== undefined) {\n        return field.fieldKind == \"scalar\" && field.longAsString\n            ? defaultValue.toString()\n            : defaultValue;\n    }\n    return field.fieldKind == \"scalar\"\n        ? scalarZeroValue(field.scalar, field.longAsString)\n        : field.enum.values[0].number;\n}\n", "import { BaseEvent, EventSchemas, EventType, Message } from \"@ag-ui/core\";\nimport * as protoEvents from \"./generated/events\";\nimport * as protoPatch from \"./generated/patch\";\n\nfunction toCamelCase(str: string): string {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n/**\n * Encodes an event message to a protocol buffer binary format.\n */\nexport function encode(event: BaseEvent): Uint8Array {\n  const oneofField = toCamelCase(event.type);\n  const { type, timestamp, rawEvent, ...rest } = event as any;\n\n  // since protobuf does not support optional arrays, we need to ensure that the toolCalls array is always present\n  if (type === EventType.MESSAGES_SNAPSHOT) {\n    rest.messages = rest.messages.map((message: Message) => {\n      const untypedMessage = message as any;\n      if (untypedMessage.toolCalls === undefined) {\n        return { ...message, toolCalls: [] };\n      }\n      return message;\n    });\n  }\n\n  // custom mapping for json patch operations\n  if (type === EventType.STATE_DELTA) {\n    rest.delta = rest.delta.map((operation: any) => ({\n      ...operation,\n      op: protoPatch.JsonPatchOperationType[operation.op.toUpperCase()],\n    }));\n  }\n\n  const eventMessage = {\n    [oneofField]: {\n      baseEvent: {\n        type: protoEvents.EventType[event.type as keyof typeof protoEvents.EventType],\n        timestamp,\n        rawEvent,\n      },\n      ...rest,\n    },\n  };\n  return protoEvents.Event.encode(eventMessage).finish();\n}\n\n/**\n * Decodes a protocol buffer binary format to an event message.\n * The format includes a 4-byte length prefix followed by the message.\n */\nexport function decode(data: Uint8Array): BaseEvent {\n  const event = protoEvents.Event.decode(data);\n  const decoded = Object.values(event).find((value) => value !== undefined);\n  if (!decoded) {\n    throw new Error(\"Invalid event\");\n  }\n  decoded.type = protoEvents.EventType[decoded.baseEvent.type];\n  decoded.timestamp = decoded.baseEvent.timestamp;\n  decoded.rawEvent = decoded.baseEvent.rawEvent;\n\n  // we want tool calls to be optional, so we need to remove them if they are empty\n  if (decoded.type === EventType.MESSAGES_SNAPSHOT) {\n    for (const message of (decoded as any).messages as Message[]) {\n      const untypedMessage = message as any;\n      if (untypedMessage.toolCalls?.length === 0) {\n        untypedMessage.toolCalls = undefined;\n      }\n    }\n  }\n\n  // custom mapping for json patch operations\n  if (decoded.type === EventType.STATE_DELTA) {\n    for (const operation of (decoded as any).delta) {\n      operation.op = protoPatch.JsonPatchOperationType[operation.op].toLowerCase();\n      Object.keys(operation).forEach((key) => {\n        if (operation[key] === undefined) {\n          delete operation[key];\n        }\n      });\n    }\n  }\n\n  Object.keys(decoded).forEach((key) => {\n    if (decoded[key] === undefined) {\n      delete decoded[key];\n    }\n  });\n\n  return EventSchemas.parse(decoded);\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: events.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { Value } from \"./google/protobuf/struct\";\nimport { JsonPatchOperation } from \"./patch\";\nimport { Message } from \"./types\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport enum EventType {\n  TEXT_MESSAGE_START = 0,\n  TEXT_MESSAGE_CONTENT = 1,\n  TEXT_MESSAGE_END = 2,\n  TOOL_CALL_START = 3,\n  TOOL_CALL_ARGS = 4,\n  TOOL_CALL_END = 5,\n  STATE_SNAPSHOT = 6,\n  STATE_DELTA = 7,\n  MESSAGES_SNAPSHOT = 8,\n  RAW = 9,\n  CUSTOM = 10,\n  RUN_STARTED = 11,\n  RUN_FINISHED = 12,\n  RUN_ERROR = 13,\n  STEP_STARTED = 14,\n  STEP_FINISHED = 15,\n  UNRECOGNIZED = -1,\n}\n\nexport interface BaseEvent {\n  type: EventType;\n  timestamp?: number | undefined;\n  rawEvent?: any | undefined;\n}\n\nexport interface TextMessageStartEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n  role?: string | undefined;\n}\n\nexport interface TextMessageContentEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n  delta: string;\n}\n\nexport interface TextMessageEndEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n}\n\nexport interface ToolCallStartEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string | undefined;\n}\n\nexport interface ToolCallArgsEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n  delta: string;\n}\n\nexport interface ToolCallEndEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n}\n\nexport interface StateSnapshotEvent {\n  baseEvent: BaseEvent | undefined;\n  snapshot: any | undefined;\n}\n\nexport interface StateDeltaEvent {\n  baseEvent: BaseEvent | undefined;\n  delta: JsonPatchOperation[];\n}\n\nexport interface MessagesSnapshotEvent {\n  baseEvent: BaseEvent | undefined;\n  messages: Message[];\n}\n\nexport interface RawEvent {\n  baseEvent: BaseEvent | undefined;\n  event: any | undefined;\n  source?: string | undefined;\n}\n\nexport interface CustomEvent {\n  baseEvent: BaseEvent | undefined;\n  name: string;\n  value?: any | undefined;\n}\n\nexport interface RunStartedEvent {\n  baseEvent: BaseEvent | undefined;\n  threadId: string;\n  runId: string;\n}\n\nexport interface RunFinishedEvent {\n  baseEvent: BaseEvent | undefined;\n  threadId: string;\n  runId: string;\n  result?: any | undefined;\n}\n\nexport interface RunErrorEvent {\n  baseEvent: BaseEvent | undefined;\n  code?: string | undefined;\n  message: string;\n}\n\nexport interface StepStartedEvent {\n  baseEvent: BaseEvent | undefined;\n  stepName: string;\n}\n\nexport interface StepFinishedEvent {\n  baseEvent: BaseEvent | undefined;\n  stepName: string;\n}\n\nexport interface TextMessageChunkEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId?: string | undefined;\n  role?: string | undefined;\n  delta?: string | undefined;\n}\n\nexport interface ToolCallChunkEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId?: string | undefined;\n  toolCallName?: string | undefined;\n  parentMessageId?: string | undefined;\n  delta?: string | undefined;\n}\n\nexport interface Event {\n  textMessageStart?: TextMessageStartEvent | undefined;\n  textMessageContent?: TextMessageContentEvent | undefined;\n  textMessageEnd?: TextMessageEndEvent | undefined;\n  toolCallStart?: ToolCallStartEvent | undefined;\n  toolCallArgs?: ToolCallArgsEvent | undefined;\n  toolCallEnd?: ToolCallEndEvent | undefined;\n  stateSnapshot?: StateSnapshotEvent | undefined;\n  stateDelta?: StateDeltaEvent | undefined;\n  messagesSnapshot?: MessagesSnapshotEvent | undefined;\n  raw?: RawEvent | undefined;\n  custom?: CustomEvent | undefined;\n  runStarted?: RunStartedEvent | undefined;\n  runFinished?: RunFinishedEvent | undefined;\n  runError?: RunErrorEvent | undefined;\n  stepStarted?: StepStartedEvent | undefined;\n  stepFinished?: StepFinishedEvent | undefined;\n  textMessageChunk?: TextMessageChunkEvent | undefined;\n  toolCallChunk?: ToolCallChunkEvent | undefined;\n}\n\nfunction createBaseBaseEvent(): BaseEvent {\n  return { type: 0, timestamp: undefined, rawEvent: undefined };\n}\n\nexport const BaseEvent: MessageFns<BaseEvent> = {\n  encode(message: BaseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (message.timestamp !== undefined) {\n      writer.uint32(16).int64(message.timestamp);\n    }\n    if (message.rawEvent !== undefined) {\n      Value.encode(Value.wrap(message.rawEvent), writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): BaseEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBaseEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.type = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 16) {\n            break;\n          }\n\n          message.timestamp = longToNumber(reader.int64());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.rawEvent = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<BaseEvent>, I>>(base?: I): BaseEvent {\n    return BaseEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<BaseEvent>, I>>(object: I): BaseEvent {\n    const message = createBaseBaseEvent();\n    message.type = object.type ?? 0;\n    message.timestamp = object.timestamp ?? undefined;\n    message.rawEvent = object.rawEvent ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTextMessageStartEvent(): TextMessageStartEvent {\n  return { baseEvent: undefined, messageId: \"\", role: undefined };\n}\n\nexport const TextMessageStartEvent: MessageFns<TextMessageStartEvent> = {\n  encode(message: TextMessageStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.role !== undefined) {\n      writer.uint32(26).string(message.role);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageStartEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageStartEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(base?: I): TextMessageStartEvent {\n    return TextMessageStartEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(object: I): TextMessageStartEvent {\n    const message = createBaseTextMessageStartEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    message.role = object.role ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTextMessageContentEvent(): TextMessageContentEvent {\n  return { baseEvent: undefined, messageId: \"\", delta: \"\" };\n}\n\nexport const TextMessageContentEvent: MessageFns<TextMessageContentEvent> = {\n  encode(message: TextMessageContentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.delta !== \"\") {\n      writer.uint32(26).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageContentEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageContentEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(base?: I): TextMessageContentEvent {\n    return TextMessageContentEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(object: I): TextMessageContentEvent {\n    const message = createBaseTextMessageContentEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    message.delta = object.delta ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextMessageEndEvent(): TextMessageEndEvent {\n  return { baseEvent: undefined, messageId: \"\" };\n}\n\nexport const TextMessageEndEvent: MessageFns<TextMessageEndEvent> = {\n  encode(message: TextMessageEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageEndEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageEndEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(base?: I): TextMessageEndEvent {\n    return TextMessageEndEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(object: I): TextMessageEndEvent {\n    const message = createBaseTextMessageEndEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseToolCallStartEvent(): ToolCallStartEvent {\n  return { baseEvent: undefined, toolCallId: \"\", toolCallName: \"\", parentMessageId: undefined };\n}\n\nexport const ToolCallStartEvent: MessageFns<ToolCallStartEvent> = {\n  encode(message: ToolCallStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.toolCallName !== \"\") {\n      writer.uint32(26).string(message.toolCallName);\n    }\n    if (message.parentMessageId !== undefined) {\n      writer.uint32(34).string(message.parentMessageId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallStartEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallStartEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.toolCallName = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.parentMessageId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(base?: I): ToolCallStartEvent {\n    return ToolCallStartEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(object: I): ToolCallStartEvent {\n    const message = createBaseToolCallStartEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    message.toolCallName = object.toolCallName ?? \"\";\n    message.parentMessageId = object.parentMessageId ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCallArgsEvent(): ToolCallArgsEvent {\n  return { baseEvent: undefined, toolCallId: \"\", delta: \"\" };\n}\n\nexport const ToolCallArgsEvent: MessageFns<ToolCallArgsEvent> = {\n  encode(message: ToolCallArgsEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.delta !== \"\") {\n      writer.uint32(26).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallArgsEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallArgsEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(base?: I): ToolCallArgsEvent {\n    return ToolCallArgsEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(object: I): ToolCallArgsEvent {\n    const message = createBaseToolCallArgsEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    message.delta = object.delta ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseToolCallEndEvent(): ToolCallEndEvent {\n  return { baseEvent: undefined, toolCallId: \"\" };\n}\n\nexport const ToolCallEndEvent: MessageFns<ToolCallEndEvent> = {\n  encode(message: ToolCallEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallEndEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallEndEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(base?: I): ToolCallEndEvent {\n    return ToolCallEndEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(object: I): ToolCallEndEvent {\n    const message = createBaseToolCallEndEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStateSnapshotEvent(): StateSnapshotEvent {\n  return { baseEvent: undefined, snapshot: undefined };\n}\n\nexport const StateSnapshotEvent: MessageFns<StateSnapshotEvent> = {\n  encode(message: StateSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.snapshot !== undefined) {\n      Value.encode(Value.wrap(message.snapshot), writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StateSnapshotEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStateSnapshotEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.snapshot = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(base?: I): StateSnapshotEvent {\n    return StateSnapshotEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(object: I): StateSnapshotEvent {\n    const message = createBaseStateSnapshotEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.snapshot = object.snapshot ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseStateDeltaEvent(): StateDeltaEvent {\n  return { baseEvent: undefined, delta: [] };\n}\n\nexport const StateDeltaEvent: MessageFns<StateDeltaEvent> = {\n  encode(message: StateDeltaEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    for (const v of message.delta) {\n      JsonPatchOperation.encode(v!, writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StateDeltaEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStateDeltaEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.delta.push(JsonPatchOperation.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(base?: I): StateDeltaEvent {\n    return StateDeltaEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(object: I): StateDeltaEvent {\n    const message = createBaseStateDeltaEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.delta = object.delta?.map((e) => JsonPatchOperation.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMessagesSnapshotEvent(): MessagesSnapshotEvent {\n  return { baseEvent: undefined, messages: [] };\n}\n\nexport const MessagesSnapshotEvent: MessageFns<MessagesSnapshotEvent> = {\n  encode(message: MessagesSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    for (const v of message.messages) {\n      Message.encode(v!, writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): MessagesSnapshotEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMessagesSnapshotEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messages.push(Message.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(base?: I): MessagesSnapshotEvent {\n    return MessagesSnapshotEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(object: I): MessagesSnapshotEvent {\n    const message = createBaseMessagesSnapshotEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRawEvent(): RawEvent {\n  return { baseEvent: undefined, event: undefined, source: undefined };\n}\n\nexport const RawEvent: MessageFns<RawEvent> = {\n  encode(message: RawEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.event !== undefined) {\n      Value.encode(Value.wrap(message.event), writer.uint32(18).fork()).join();\n    }\n    if (message.source !== undefined) {\n      writer.uint32(26).string(message.source);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RawEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRawEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.event = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.source = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RawEvent>, I>>(base?: I): RawEvent {\n    return RawEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RawEvent>, I>>(object: I): RawEvent {\n    const message = createBaseRawEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.event = object.event ?? undefined;\n    message.source = object.source ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseCustomEvent(): CustomEvent {\n  return { baseEvent: undefined, name: \"\", value: undefined };\n}\n\nexport const CustomEvent: MessageFns<CustomEvent> = {\n  encode(message: CustomEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.name !== \"\") {\n      writer.uint32(18).string(message.name);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): CustomEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCustomEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<CustomEvent>, I>>(base?: I): CustomEvent {\n    return CustomEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<CustomEvent>, I>>(object: I): CustomEvent {\n    const message = createBaseCustomEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.name = object.name ?? \"\";\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseRunStartedEvent(): RunStartedEvent {\n  return { baseEvent: undefined, threadId: \"\", runId: \"\" };\n}\n\nexport const RunStartedEvent: MessageFns<RunStartedEvent> = {\n  encode(message: RunStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.threadId !== \"\") {\n      writer.uint32(18).string(message.threadId);\n    }\n    if (message.runId !== \"\") {\n      writer.uint32(26).string(message.runId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunStartedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.threadId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.runId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunStartedEvent>, I>>(base?: I): RunStartedEvent {\n    return RunStartedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunStartedEvent>, I>>(object: I): RunStartedEvent {\n    const message = createBaseRunStartedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.threadId = object.threadId ?? \"\";\n    message.runId = object.runId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRunFinishedEvent(): RunFinishedEvent {\n  return { baseEvent: undefined, threadId: \"\", runId: \"\", result: undefined };\n}\n\nexport const RunFinishedEvent: MessageFns<RunFinishedEvent> = {\n  encode(message: RunFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.threadId !== \"\") {\n      writer.uint32(18).string(message.threadId);\n    }\n    if (message.runId !== \"\") {\n      writer.uint32(26).string(message.runId);\n    }\n    if (message.result !== undefined) {\n      Value.encode(Value.wrap(message.result), writer.uint32(34).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunFinishedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunFinishedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.threadId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.runId = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.result = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(base?: I): RunFinishedEvent {\n    return RunFinishedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(object: I): RunFinishedEvent {\n    const message = createBaseRunFinishedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.threadId = object.threadId ?? \"\";\n    message.runId = object.runId ?? \"\";\n    message.result = object.result ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseRunErrorEvent(): RunErrorEvent {\n  return { baseEvent: undefined, code: undefined, message: \"\" };\n}\n\nexport const RunErrorEvent: MessageFns<RunErrorEvent> = {\n  encode(message: RunErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.code !== undefined) {\n      writer.uint32(18).string(message.code);\n    }\n    if (message.message !== \"\") {\n      writer.uint32(26).string(message.message);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunErrorEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunErrorEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.code = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.message = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunErrorEvent>, I>>(base?: I): RunErrorEvent {\n    return RunErrorEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunErrorEvent>, I>>(object: I): RunErrorEvent {\n    const message = createBaseRunErrorEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.code = object.code ?? undefined;\n    message.message = object.message ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStepStartedEvent(): StepStartedEvent {\n  return { baseEvent: undefined, stepName: \"\" };\n}\n\nexport const StepStartedEvent: MessageFns<StepStartedEvent> = {\n  encode(message: StepStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.stepName !== \"\") {\n      writer.uint32(18).string(message.stepName);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StepStartedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStepStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.stepName = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StepStartedEvent>, I>>(base?: I): StepStartedEvent {\n    return StepStartedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StepStartedEvent>, I>>(object: I): StepStartedEvent {\n    const message = createBaseStepStartedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.stepName = object.stepName ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStepFinishedEvent(): StepFinishedEvent {\n  return { baseEvent: undefined, stepName: \"\" };\n}\n\nexport const StepFinishedEvent: MessageFns<StepFinishedEvent> = {\n  encode(message: StepFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.stepName !== \"\") {\n      writer.uint32(18).string(message.stepName);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StepFinishedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStepFinishedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.stepName = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(base?: I): StepFinishedEvent {\n    return StepFinishedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(object: I): StepFinishedEvent {\n    const message = createBaseStepFinishedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.stepName = object.stepName ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextMessageChunkEvent(): TextMessageChunkEvent {\n  return { baseEvent: undefined, messageId: undefined, role: undefined, delta: undefined };\n}\n\nexport const TextMessageChunkEvent: MessageFns<TextMessageChunkEvent> = {\n  encode(message: TextMessageChunkEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== undefined) {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.role !== undefined) {\n      writer.uint32(26).string(message.role);\n    }\n    if (message.delta !== undefined) {\n      writer.uint32(34).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageChunkEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageChunkEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageChunkEvent>, I>>(base?: I): TextMessageChunkEvent {\n    return TextMessageChunkEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageChunkEvent>, I>>(object: I): TextMessageChunkEvent {\n    const message = createBaseTextMessageChunkEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? undefined;\n    message.role = object.role ?? undefined;\n    message.delta = object.delta ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCallChunkEvent(): ToolCallChunkEvent {\n  return {\n    baseEvent: undefined,\n    toolCallId: undefined,\n    toolCallName: undefined,\n    parentMessageId: undefined,\n    delta: undefined,\n  };\n}\n\nexport const ToolCallChunkEvent: MessageFns<ToolCallChunkEvent> = {\n  encode(message: ToolCallChunkEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== undefined) {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.toolCallName !== undefined) {\n      writer.uint32(26).string(message.toolCallName);\n    }\n    if (message.parentMessageId !== undefined) {\n      writer.uint32(34).string(message.parentMessageId);\n    }\n    if (message.delta !== undefined) {\n      writer.uint32(42).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallChunkEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallChunkEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.toolCallName = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.parentMessageId = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallChunkEvent>, I>>(base?: I): ToolCallChunkEvent {\n    return ToolCallChunkEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallChunkEvent>, I>>(object: I): ToolCallChunkEvent {\n    const message = createBaseToolCallChunkEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? undefined;\n    message.toolCallName = object.toolCallName ?? undefined;\n    message.parentMessageId = object.parentMessageId ?? undefined;\n    message.delta = object.delta ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseEvent(): Event {\n  return {\n    textMessageStart: undefined,\n    textMessageContent: undefined,\n    textMessageEnd: undefined,\n    toolCallStart: undefined,\n    toolCallArgs: undefined,\n    toolCallEnd: undefined,\n    stateSnapshot: undefined,\n    stateDelta: undefined,\n    messagesSnapshot: undefined,\n    raw: undefined,\n    custom: undefined,\n    runStarted: undefined,\n    runFinished: undefined,\n    runError: undefined,\n    stepStarted: undefined,\n    stepFinished: undefined,\n    textMessageChunk: undefined,\n    toolCallChunk: undefined,\n  };\n}\n\nexport const Event: MessageFns<Event> = {\n  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.textMessageStart !== undefined) {\n      TextMessageStartEvent.encode(message.textMessageStart, writer.uint32(10).fork()).join();\n    }\n    if (message.textMessageContent !== undefined) {\n      TextMessageContentEvent.encode(message.textMessageContent, writer.uint32(18).fork()).join();\n    }\n    if (message.textMessageEnd !== undefined) {\n      TextMessageEndEvent.encode(message.textMessageEnd, writer.uint32(26).fork()).join();\n    }\n    if (message.toolCallStart !== undefined) {\n      ToolCallStartEvent.encode(message.toolCallStart, writer.uint32(34).fork()).join();\n    }\n    if (message.toolCallArgs !== undefined) {\n      ToolCallArgsEvent.encode(message.toolCallArgs, writer.uint32(42).fork()).join();\n    }\n    if (message.toolCallEnd !== undefined) {\n      ToolCallEndEvent.encode(message.toolCallEnd, writer.uint32(50).fork()).join();\n    }\n    if (message.stateSnapshot !== undefined) {\n      StateSnapshotEvent.encode(message.stateSnapshot, writer.uint32(58).fork()).join();\n    }\n    if (message.stateDelta !== undefined) {\n      StateDeltaEvent.encode(message.stateDelta, writer.uint32(66).fork()).join();\n    }\n    if (message.messagesSnapshot !== undefined) {\n      MessagesSnapshotEvent.encode(message.messagesSnapshot, writer.uint32(74).fork()).join();\n    }\n    if (message.raw !== undefined) {\n      RawEvent.encode(message.raw, writer.uint32(82).fork()).join();\n    }\n    if (message.custom !== undefined) {\n      CustomEvent.encode(message.custom, writer.uint32(90).fork()).join();\n    }\n    if (message.runStarted !== undefined) {\n      RunStartedEvent.encode(message.runStarted, writer.uint32(98).fork()).join();\n    }\n    if (message.runFinished !== undefined) {\n      RunFinishedEvent.encode(message.runFinished, writer.uint32(106).fork()).join();\n    }\n    if (message.runError !== undefined) {\n      RunErrorEvent.encode(message.runError, writer.uint32(114).fork()).join();\n    }\n    if (message.stepStarted !== undefined) {\n      StepStartedEvent.encode(message.stepStarted, writer.uint32(122).fork()).join();\n    }\n    if (message.stepFinished !== undefined) {\n      StepFinishedEvent.encode(message.stepFinished, writer.uint32(130).fork()).join();\n    }\n    if (message.textMessageChunk !== undefined) {\n      TextMessageChunkEvent.encode(message.textMessageChunk, writer.uint32(138).fork()).join();\n    }\n    if (message.toolCallChunk !== undefined) {\n      ToolCallChunkEvent.encode(message.toolCallChunk, writer.uint32(146).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Event {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.textMessageStart = TextMessageStartEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.textMessageContent = TextMessageContentEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.textMessageEnd = TextMessageEndEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.toolCallStart = ToolCallStartEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.toolCallArgs = ToolCallArgsEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.toolCallEnd = ToolCallEndEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.stateSnapshot = StateSnapshotEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.stateDelta = StateDeltaEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 9: {\n          if (tag !== 74) {\n            break;\n          }\n\n          message.messagesSnapshot = MessagesSnapshotEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 10: {\n          if (tag !== 82) {\n            break;\n          }\n\n          message.raw = RawEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 11: {\n          if (tag !== 90) {\n            break;\n          }\n\n          message.custom = CustomEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 12: {\n          if (tag !== 98) {\n            break;\n          }\n\n          message.runStarted = RunStartedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 13: {\n          if (tag !== 106) {\n            break;\n          }\n\n          message.runFinished = RunFinishedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 14: {\n          if (tag !== 114) {\n            break;\n          }\n\n          message.runError = RunErrorEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 15: {\n          if (tag !== 122) {\n            break;\n          }\n\n          message.stepStarted = StepStartedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 16: {\n          if (tag !== 130) {\n            break;\n          }\n\n          message.stepFinished = StepFinishedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 17: {\n          if (tag !== 138) {\n            break;\n          }\n\n          message.textMessageChunk = TextMessageChunkEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 18: {\n          if (tag !== 146) {\n            break;\n          }\n\n          message.toolCallChunk = ToolCallChunkEvent.decode(reader, reader.uint32());\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {\n    return Event.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {\n    const message = createBaseEvent();\n    message.textMessageStart = (object.textMessageStart !== undefined && object.textMessageStart !== null)\n      ? TextMessageStartEvent.fromPartial(object.textMessageStart)\n      : undefined;\n    message.textMessageContent = (object.textMessageContent !== undefined && object.textMessageContent !== null)\n      ? TextMessageContentEvent.fromPartial(object.textMessageContent)\n      : undefined;\n    message.textMessageEnd = (object.textMessageEnd !== undefined && object.textMessageEnd !== null)\n      ? TextMessageEndEvent.fromPartial(object.textMessageEnd)\n      : undefined;\n    message.toolCallStart = (object.toolCallStart !== undefined && object.toolCallStart !== null)\n      ? ToolCallStartEvent.fromPartial(object.toolCallStart)\n      : undefined;\n    message.toolCallArgs = (object.toolCallArgs !== undefined && object.toolCallArgs !== null)\n      ? ToolCallArgsEvent.fromPartial(object.toolCallArgs)\n      : undefined;\n    message.toolCallEnd = (object.toolCallEnd !== undefined && object.toolCallEnd !== null)\n      ? ToolCallEndEvent.fromPartial(object.toolCallEnd)\n      : undefined;\n    message.stateSnapshot = (object.stateSnapshot !== undefined && object.stateSnapshot !== null)\n      ? StateSnapshotEvent.fromPartial(object.stateSnapshot)\n      : undefined;\n    message.stateDelta = (object.stateDelta !== undefined && object.stateDelta !== null)\n      ? StateDeltaEvent.fromPartial(object.stateDelta)\n      : undefined;\n    message.messagesSnapshot = (object.messagesSnapshot !== undefined && object.messagesSnapshot !== null)\n      ? MessagesSnapshotEvent.fromPartial(object.messagesSnapshot)\n      : undefined;\n    message.raw = (object.raw !== undefined && object.raw !== null) ? RawEvent.fromPartial(object.raw) : undefined;\n    message.custom = (object.custom !== undefined && object.custom !== null)\n      ? CustomEvent.fromPartial(object.custom)\n      : undefined;\n    message.runStarted = (object.runStarted !== undefined && object.runStarted !== null)\n      ? RunStartedEvent.fromPartial(object.runStarted)\n      : undefined;\n    message.runFinished = (object.runFinished !== undefined && object.runFinished !== null)\n      ? RunFinishedEvent.fromPartial(object.runFinished)\n      : undefined;\n    message.runError = (object.runError !== undefined && object.runError !== null)\n      ? RunErrorEvent.fromPartial(object.runError)\n      : undefined;\n    message.stepStarted = (object.stepStarted !== undefined && object.stepStarted !== null)\n      ? StepStartedEvent.fromPartial(object.stepStarted)\n      : undefined;\n    message.stepFinished = (object.stepFinished !== undefined && object.stepFinished !== null)\n      ? StepFinishedEvent.fromPartial(object.stepFinished)\n      : undefined;\n    message.textMessageChunk = (object.textMessageChunk !== undefined && object.textMessageChunk !== null)\n      ? TextMessageChunkEvent.fromPartial(object.textMessageChunk)\n      : undefined;\n    message.toolCallChunk = (object.toolCallChunk !== undefined && object.toolCallChunk !== null)\n      ? ToolCallChunkEvent.fromPartial(object.toolCallChunk)\n      : undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction longToNumber(int64: { toString(): string }): number {\n  const num = globalThis.Number(int64.toString());\n  if (num > globalThis.Number.MAX_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (num < globalThis.Number.MIN_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return num;\n}\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: google/protobuf/struct.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n * The JSON representation for `NullValue` is JSON `null`.\n */\nexport enum NullValue {\n  /** NULL_VALUE - Null value. */\n  NULL_VALUE = 0,\n  UNRECOGNIZED = -1,\n}\n\n/**\n * `Struct` represents a structured data value, consisting of fields\n * which map to dynamically typed values. In some languages, `Struct`\n * might be supported by a native representation. For example, in\n * scripting languages like JS a struct is represented as an\n * object. The details of that representation are described together\n * with the proto support for the language.\n *\n * The JSON representation for `Struct` is JSON object.\n */\nexport interface Struct {\n  /** Unordered map of dynamically typed values. */\n  fields: { [key: string]: any | undefined };\n}\n\nexport interface Struct_FieldsEntry {\n  key: string;\n  value: any | undefined;\n}\n\n/**\n * `Value` represents a dynamically typed value which can be either\n * null, a number, a string, a boolean, a recursive struct value, or a\n * list of values. A producer of value is expected to set one of these\n * variants. Absence of any variant indicates an error.\n *\n * The JSON representation for `Value` is JSON value.\n */\nexport interface Value {\n  /** Represents a null value. */\n  nullValue?:\n    | NullValue\n    | undefined;\n  /** Represents a double value. */\n  numberValue?:\n    | number\n    | undefined;\n  /** Represents a string value. */\n  stringValue?:\n    | string\n    | undefined;\n  /** Represents a boolean value. */\n  boolValue?:\n    | boolean\n    | undefined;\n  /** Represents a structured value. */\n  structValue?:\n    | { [key: string]: any }\n    | undefined;\n  /** Represents a repeated `Value`. */\n  listValue?: Array<any> | undefined;\n}\n\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n * The JSON representation for `ListValue` is JSON array.\n */\nexport interface ListValue {\n  /** Repeated field of dynamically typed values. */\n  values: any[];\n}\n\nfunction createBaseStruct(): Struct {\n  return { fields: {} };\n}\n\nexport const Struct: MessageFns<Struct> & StructWrapperFns = {\n  encode(message: Struct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    Object.entries(message.fields).forEach(([key, value]) => {\n      if (value !== undefined) {\n        Struct_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();\n      }\n    });\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());\n          if (entry1.value !== undefined) {\n            message.fields[entry1.key] = entry1.value;\n          }\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Struct>, I>>(base?: I): Struct {\n    return Struct.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct>, I>>(object: I): Struct {\n    const message = createBaseStruct();\n    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: any | undefined }>(\n      (acc, [key, value]) => {\n        if (value !== undefined) {\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {},\n    );\n    return message;\n  },\n\n  wrap(object: { [key: string]: any } | undefined): Struct {\n    const struct = createBaseStruct();\n\n    if (object !== undefined) {\n      for (const key of Object.keys(object)) {\n        struct.fields[key] = object[key];\n      }\n    }\n    return struct;\n  },\n\n  unwrap(message: Struct): { [key: string]: any } {\n    const object: { [key: string]: any } = {};\n    if (message.fields) {\n      for (const key of Object.keys(message.fields)) {\n        object[key] = message.fields[key];\n      }\n    }\n    return object;\n  },\n};\n\nfunction createBaseStruct_FieldsEntry(): Struct_FieldsEntry {\n  return { key: \"\", value: undefined };\n}\n\nexport const Struct_FieldsEntry: MessageFns<Struct_FieldsEntry> = {\n  encode(message: Struct_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct_FieldsEntry {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct_FieldsEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.key = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(base?: I): Struct_FieldsEntry {\n    return Struct_FieldsEntry.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(object: I): Struct_FieldsEntry {\n    const message = createBaseStruct_FieldsEntry();\n    message.key = object.key ?? \"\";\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseValue(): Value {\n  return {\n    nullValue: undefined,\n    numberValue: undefined,\n    stringValue: undefined,\n    boolValue: undefined,\n    structValue: undefined,\n    listValue: undefined,\n  };\n}\n\nexport const Value: MessageFns<Value> & AnyValueWrapperFns = {\n  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.nullValue !== undefined) {\n      writer.uint32(8).int32(message.nullValue);\n    }\n    if (message.numberValue !== undefined) {\n      writer.uint32(17).double(message.numberValue);\n    }\n    if (message.stringValue !== undefined) {\n      writer.uint32(26).string(message.stringValue);\n    }\n    if (message.boolValue !== undefined) {\n      writer.uint32(32).bool(message.boolValue);\n    }\n    if (message.structValue !== undefined) {\n      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();\n    }\n    if (message.listValue !== undefined) {\n      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Value {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.nullValue = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 17) {\n            break;\n          }\n\n          message.numberValue = reader.double();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.stringValue = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 32) {\n            break;\n          }\n\n          message.boolValue = reader.bool();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {\n    return Value.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {\n    const message = createBaseValue();\n    message.nullValue = object.nullValue ?? undefined;\n    message.numberValue = object.numberValue ?? undefined;\n    message.stringValue = object.stringValue ?? undefined;\n    message.boolValue = object.boolValue ?? undefined;\n    message.structValue = object.structValue ?? undefined;\n    message.listValue = object.listValue ?? undefined;\n    return message;\n  },\n\n  wrap(value: any): Value {\n    const result = createBaseValue();\n    if (value === null) {\n      result.nullValue = NullValue.NULL_VALUE;\n    } else if (typeof value === \"boolean\") {\n      result.boolValue = value;\n    } else if (typeof value === \"number\") {\n      result.numberValue = value;\n    } else if (typeof value === \"string\") {\n      result.stringValue = value;\n    } else if (globalThis.Array.isArray(value)) {\n      result.listValue = value;\n    } else if (typeof value === \"object\") {\n      result.structValue = value;\n    } else if (typeof value !== \"undefined\") {\n      throw new globalThis.Error(\"Unsupported any value type: \" + typeof value);\n    }\n    return result;\n  },\n\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined {\n    if (message.stringValue !== undefined) {\n      return message.stringValue;\n    } else if (message?.numberValue !== undefined) {\n      return message.numberValue;\n    } else if (message?.boolValue !== undefined) {\n      return message.boolValue;\n    } else if (message?.structValue !== undefined) {\n      return message.structValue as any;\n    } else if (message?.listValue !== undefined) {\n      return message.listValue;\n    } else if (message?.nullValue !== undefined) {\n      return null;\n    }\n    return undefined;\n  },\n};\n\nfunction createBaseListValue(): ListValue {\n  return { values: [] };\n}\n\nexport const ListValue: MessageFns<ListValue> & ListValueWrapperFns = {\n  encode(message: ListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    for (const v of message.values) {\n      Value.encode(Value.wrap(v!), writer.uint32(10).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ListValue {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseListValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ListValue>, I>>(base?: I): ListValue {\n    return ListValue.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ListValue>, I>>(object: I): ListValue {\n    const message = createBaseListValue();\n    message.values = object.values?.map((e) => e) || [];\n    return message;\n  },\n\n  wrap(array: Array<any> | undefined): ListValue {\n    const result = createBaseListValue();\n    result.values = array ?? [];\n    return result;\n  },\n\n  unwrap(message: ListValue): Array<any> {\n    if (message?.hasOwnProperty(\"values\") && globalThis.Array.isArray(message.values)) {\n      return message.values;\n    } else {\n      return message as any;\n    }\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n\nexport interface StructWrapperFns {\n  wrap(object: { [key: string]: any } | undefined): Struct;\n  unwrap(message: Struct): { [key: string]: any };\n}\n\nexport interface AnyValueWrapperFns {\n  wrap(value: any): Value;\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined;\n}\n\nexport interface ListValueWrapperFns {\n  wrap(array: Array<any> | undefined): ListValue;\n  unwrap(message: ListValue): Array<any>;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: patch.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { Value } from \"./google/protobuf/struct\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport enum JsonPatchOperationType {\n  ADD = 0,\n  REMOVE = 1,\n  REPLACE = 2,\n  MOVE = 3,\n  COPY = 4,\n  TEST = 5,\n  UNRECOGNIZED = -1,\n}\n\nexport interface JsonPatchOperation {\n  op: JsonPatchOperationType;\n  path: string;\n  from?: string | undefined;\n  value?: any | undefined;\n}\n\nfunction createBaseJsonPatchOperation(): JsonPatchOperation {\n  return { op: 0, path: \"\", from: undefined, value: undefined };\n}\n\nexport const JsonPatchOperation: MessageFns<JsonPatchOperation> = {\n  encode(message: JsonPatchOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.op !== 0) {\n      writer.uint32(8).int32(message.op);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    if (message.from !== undefined) {\n      writer.uint32(26).string(message.from);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(34).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): JsonPatchOperation {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseJsonPatchOperation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.op = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.path = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.from = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<JsonPatchOperation>, I>>(base?: I): JsonPatchOperation {\n    return JsonPatchOperation.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<JsonPatchOperation>, I>>(object: I): JsonPatchOperation {\n    const message = createBaseJsonPatchOperation();\n    message.op = object.op ?? 0;\n    message.path = object.path ?? \"\";\n    message.from = object.from ?? undefined;\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: types.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport interface ToolCall {\n  id: string;\n  type: string;\n  function: ToolCall_Function | undefined;\n}\n\nexport interface ToolCall_Function {\n  name: string;\n  arguments: string;\n}\n\nexport interface Message {\n  id: string;\n  role: string;\n  content?: string | undefined;\n  name?: string | undefined;\n  toolCalls: ToolCall[];\n  toolCallId?: string | undefined;\n  error?: string | undefined;\n}\n\nfunction createBaseToolCall(): ToolCall {\n  return { id: \"\", type: \"\", function: undefined };\n}\n\nexport const ToolCall: MessageFns<ToolCall> = {\n  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.type !== \"\") {\n      writer.uint32(18).string(message.type);\n    }\n    if (message.function !== undefined) {\n      ToolCall_Function.encode(message.function, writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCall();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.id = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.type = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.function = ToolCall_Function.decode(reader, reader.uint32());\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {\n    return ToolCall.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {\n    const message = createBaseToolCall();\n    message.id = object.id ?? \"\";\n    message.type = object.type ?? \"\";\n    message.function = (object.function !== undefined && object.function !== null)\n      ? ToolCall_Function.fromPartial(object.function)\n      : undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCall_Function(): ToolCall_Function {\n  return { name: \"\", arguments: \"\" };\n}\n\nexport const ToolCall_Function: MessageFns<ToolCall_Function> = {\n  encode(message: ToolCall_Function, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.arguments !== \"\") {\n      writer.uint32(18).string(message.arguments);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall_Function {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCall_Function();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.arguments = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCall_Function>, I>>(base?: I): ToolCall_Function {\n    return ToolCall_Function.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCall_Function>, I>>(object: I): ToolCall_Function {\n    const message = createBaseToolCall_Function();\n    message.name = object.name ?? \"\";\n    message.arguments = object.arguments ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMessage(): Message {\n  return {\n    id: \"\",\n    role: \"\",\n    content: undefined,\n    name: undefined,\n    toolCalls: [],\n    toolCallId: undefined,\n    error: undefined,\n  };\n}\n\nexport const Message: MessageFns<Message> = {\n  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.role !== \"\") {\n      writer.uint32(18).string(message.role);\n    }\n    if (message.content !== undefined) {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.name !== undefined) {\n      writer.uint32(34).string(message.name);\n    }\n    for (const v of message.toolCalls) {\n      ToolCall.encode(v!, writer.uint32(42).fork()).join();\n    }\n    if (message.toolCallId !== undefined) {\n      writer.uint32(50).string(message.toolCallId);\n    }\n    if (message.error !== undefined) {\n      writer.uint32(58).string(message.error);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Message {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.id = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.content = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.error = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {\n    return Message.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {\n    const message = createBaseMessage();\n    message.id = object.id ?? \"\";\n    message.role = object.role ?? \"\";\n    message.content = object.content ?? undefined;\n    message.name = object.name ?? undefined;\n    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];\n    message.toolCallId = object.toolCallId ?? undefined;\n    message.error = object.error ?? undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "export { encode, decode } from \"./proto\";\n\nexport const AGUI_MEDIA_TYPE = \"application/vnd.ag-ui.event+proto\";\n", "/**\n * Allowed arithmetic operators\n */\nexport type CompareOperator = '>' | '>=' | '=' | '<' | '<=' | '!=';\n\nexport const semver =\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nexport const validateAndParse = (version: string) => {\n  if (typeof version !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = version.match(semver);\n  if (!match) {\n    throw new Error(\n      `Invalid argument not valid semver ('${version}' received)`\n    );\n  }\n  match.shift();\n  return match;\n};\n\nconst isWildcard = (s: string) => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = (v: string) => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a: string | number, b: string | number) =>\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a: string, b: string) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nexport const compareSegments = (\n  a: string | string[] | RegExpMatchArray,\n  b: string | string[] | RegExpMatchArray\n) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || '0', b[i] || '0');\n    if (r !== 0) return r;\n  }\n  return 0;\n};\n", "import { compareSegments, validateAndParse } from './utils.js';\n\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1: string, v2: string) => {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n};\n", "import { compareVersions } from './compareVersions.js';\nimport { CompareOperator } from './utils.js';\n\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1: string, v2: string, operator: CompareOperator) => {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n\n  return operatorResMap[operator].includes(res);\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1],\n  '!=': [-1, 1],\n};\n\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = (op: string) => {\n  if (typeof op !== 'string') {\n    throw new TypeError(\n      `Invalid operator type, expected string but got ${typeof op}`\n    );\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\n    );\n  }\n};\n", "import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  DeveloperMessage,\n  SystemMessage,\n  AssistantMessage,\n  UserMessage,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(agent.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role = \"assistant\" } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            // Text messages can be developer, system, assistant, or user (not tool)\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const { messageId, delta } = event as TextMessageContentEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append content to the correct message by ID\n            const existingContent =\n              typeof targetMessage.content === \"string\" ? targetMessage.content : \"\";\n            targetMessage.content = `${existingContent}${delta}`;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const { messageId } = event as TextMessageEndEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_END: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: targetMessage,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const { toolCallId, delta } = event as ToolCallArgsEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_ARGS: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallBuffer = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append the arguments to the correct tool call by ID\n            targetToolCall.function.arguments += delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const { toolCallId } = event as ToolCallEndEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_END: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_END: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallArgsString = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: targetToolCall,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_SNAPSHOT: {\n          const activityEvent = event as ActivitySnapshotEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          const existingMessage = existingIndex >= 0 ? messages[existingIndex] : undefined;\n          const existingActivityMessage =\n            existingMessage?.role === \"activity\" ? (existingMessage as ActivityMessage) : undefined;\n          const replace = activityEvent.replace ?? true;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivitySnapshotEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n                existingMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const activityMessage: ActivityMessage = {\n              id: activityEvent.messageId,\n              role: \"activity\",\n              activityType: activityEvent.activityType,\n              content: structuredClone_(activityEvent.content),\n            };\n\n            let createdMessage: ActivityMessage | undefined;\n\n            if (existingIndex === -1) {\n              messages.push(activityMessage);\n              createdMessage = activityMessage;\n            } else if (existingActivityMessage) {\n              if (replace) {\n                messages[existingIndex] = {\n                  ...existingActivityMessage,\n                  activityType: activityEvent.activityType,\n                  content: structuredClone_(activityEvent.content),\n                };\n              }\n            } else if (replace) {\n              messages[existingIndex] = activityMessage;\n              createdMessage = activityMessage;\n            }\n\n            applyMutation({ messages });\n\n            if (createdMessage) {\n              await Promise.all(\n                subscribers.map((subscriber) =>\n                  subscriber.onNewMessage?.({\n                    message: createdMessage,\n                    messages,\n                    state,\n                    agent,\n                    input,\n                  }),\n                ),\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_DELTA: {\n          const activityEvent = event as ActivityDeltaEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          if (existingIndex === -1) {\n            console.warn(\n              `ACTIVITY_DELTA: No message found with ID '${activityEvent.messageId}' to apply patch`,\n            );\n            return emitUpdates();\n          }\n\n          const existingMessage = messages[existingIndex];\n          if (existingMessage.role !== \"activity\") {\n            console.warn(\n              `ACTIVITY_DELTA: Message '${activityEvent.messageId}' is not an activity message`,\n            );\n            return emitUpdates();\n          }\n\n          const existingActivityMessage = existingMessage as ActivityMessage;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivityDeltaEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            try {\n              const baseContent = structuredClone_(existingActivityMessage.content ?? {});\n\n              const result = applyPatch(\n                baseContent,\n                activityEvent.patch ?? [],\n                true,\n                false,\n              );\n              const updatedContent = result.newDocument as ActivityMessage[\"content\"];\n\n              messages[existingIndex] = {\n                ...existingActivityMessage,\n                content: structuredClone_(updatedContent),\n                activityType: activityEvent.activityType,\n              };\n\n              applyMutation({ messages });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply activity patch for '${activityEvent.messageId}': ${errorMessage}`,\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          // Handle input.messages if present and stopPropagation is not set\n          if (mutation.stopPropagation !== true) {\n            const runStartedEvent = event as RunStartedEvent;\n\n            // Check if the event contains input with messages\n            if (runStartedEvent.input?.messages) {\n              // Add messages that aren't already present (checked by ID)\n              for (const message of runStartedEvent.input.messages) {\n                const existingMessage = messages.find((m) => m.id === message.id);\n                if (!existingMessage) {\n                  messages.push(message);\n                }\n              }\n\n              // Apply mutation to emit the updated messages\n              applyMutation({ messages });\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n", "import { v4 as uuidv4 } from \"uuid\";\n\nexport const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n\n/**\n * Generate a random UUID v4\n * Cross-platform compatible (Node.js, browsers, React Native)\n */\nexport function randomUUID(): string {\n  return uuidv4();\n}\n\n// Note: semver helpers were removed in favor of using\n// the external `compare-versions` library directly at call sites.\n\n\n/**\n * Parses a semantic version string into its numeric components.\n * Supports incomplete versions (e.g. \"1\", \"1.2\") by defaulting missing segments to zero.\n *\n * @throws If the version string is not a valid semantic version.\n */\n// (Intentionally left minimal.)\n", "import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivitySnapshotEvent?(\n    params: {\n      event: ActivitySnapshotEvent;\n      activityMessage?: ActivityMessage;\n      existingMessage?: Message;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivityDeltaEvent?(\n    params: {\n      event: ActivityDeltaEvent;\n      activityMessage?: ActivityMessage;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned  keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n", "import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessages = new Map<string, boolean>(); // Map of message ID -> active status\n    let activeToolCalls = new Map<string, boolean>(); // Map of tool call ID -> active status\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n    let runStarted = false; // Track if a run has started\n\n    // Function to reset state for a new run\n    const resetRunState = () => {\n      activeMessages.clear();\n      activeToolCalls.clear();\n      activeSteps.clear();\n      activeThinkingStep = false;\n      activeThinkingStepMessage = false;\n      runFinished = false;\n      runError = false;\n      runStarted = true;\n    };\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished (but allow new RUN_STARTED to start a new run)\n        if (runFinished && eventType !== EventType.RUN_ERROR && eventType !== EventType.RUN_STARTED) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Handle first event requirement and sequential RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Allow RUN_STARTED after RUN_FINISHED (new run), but not during an active run\n          if (runStarted && !runFinished) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run.`,\n                ),\n            );\n          }\n          // If we're here, it's either the first RUN_STARTED or a new run after RUN_FINISHED\n          if (runFinished) {\n            // This is a new run after the previous one finished, reset state\n            resetRunState();\n          }\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            const messageId = (event as any).messageId;\n\n            // Check if this message is already in progress\n            if (activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${messageId}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessages.set(messageId, true);\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${messageId}'. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${messageId}'. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove message from active set\n            activeMessages.delete(messageId);\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Check if this tool call is already in progress\n            if (activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call with ID '${toolCallId}' is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCalls.set(toolCallId, true);\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${toolCallId}'. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${toolCallId}'. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove tool call from active set\n            activeToolCalls.delete(toolCallId);\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            runStarted = true;\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            // Check that all messages are finished before run ends\n            if (activeMessages.size > 0) {\n              const unfinishedMessages = Array.from(activeMessages.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while text messages are still active: ${unfinishedMessages}`,\n                  ),\n              );\n            }\n\n            // Check that all tool calls are finished before run ends\n            if (activeToolCalls.size > 0) {\n              const unfinishedToolCalls = Array.from(activeToolCalls.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while tool calls are still active: ${unfinishedToolCalls}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n", "import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\nimport { EventType } from \"@ag-ui/core\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => {\n              if ((err as DOMException)?.name === \"AbortError\") {\n                eventSubject.next({\n                  type: EventType.RUN_ERROR,\n                  rawEvent: err,\n                });\n                eventSubject.complete();\n                return;\n              }\n              return eventSubject.error(err)\n            },\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n", "import { Observable, from, defer, throwError } from \"rxjs\";\nimport { mergeMap, switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        // Read the (small) error body once, then error the stream\n        return from(response.text()).pipe(\n          mergeMap((text) => {\n            let payload: unknown = text;\n            if (contentType.includes(\"application/json\")) {\n              try { payload = JSON.parse(text); } catch {/* keep raw text */}\n            }\n            const err: any = new Error(\n              `HTTP ${response.status}: ${typeof payload === \"string\" ? payload : JSON.stringify(payload)}`\n            );\n            err.status = response.status;\n            err.payload = payload;\n            return throwError(() => err);\n          })\n        );\n      }\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel().catch((error) => {\n            if ((error as DOMException)?.name === \"AbortError\") {\n              return;\n            }\n\n            throw error;\n          });\n        };\n      });\n    }),\n  );\n};\n", "import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * Follows the SSE spec by only processing 'data:' prefixed lines.\n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        // Extract data content (remove 'data: ' prefix)\n        dataLines.push(line.slice(6));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n", "import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n", "import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n  RunErrorEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n  LegacyRunError\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\nconst flattenMessageContentToText = (content: Message[\"content\"]) => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return undefined;\n  }\n\n  const textParts = content\n    .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\n    .map((part) => part.text)\n    .filter((text) => text.length > 0);\n\n  if (textParts.length === 0) {\n    return undefined;\n  }\n\n  return textParts.join(\"\\n\");\n};\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n                role: startEvent.role,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            // Find the tool call by ID instead of using the last one\n            const currentToolCall = currentToolCalls.find((tc) => tc.id === argsEvent.toolCallId);\n            if (!currentToolCall) {\n              console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${argsEvent.toolCallId}'`);\n              return [];\n            }\n\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            // Only do an update if state is not empty\n            if (Object.keys(currentState).length === 0) {\n              return [];\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            const errorEvent = event as RunErrorEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.RunError,\n                message: errorEvent.message,\n                code: errorEvent.code,\n              } as LegacyRunError,\n            ];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      const textContent = flattenMessageContentToText(message.content);\n      if (textContent) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: textContent,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n", "import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n  role: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\n\nexport const LegacyRunError = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.RunError),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n  LegacyRunError,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\nexport type LegacyRunError = z.infer<typeof LegacyRunError>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n", "import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { compareVersions } from \"compare-versions\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { takeUntil } from \"rxjs/operators\";\nimport { pipe, Observable, from, of, EMPTY, Subject } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\nimport { AGUIConnectNotImplementedError } from \"@ag-ui/core\";\nimport {\n  Middleware,\n  MiddlewareFunction,\n  FunctionMiddleware,\n  BackwardCompatibility_0_0_39,\n} from \"@/middleware\";\nimport packageJson from \"../../package.json\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n  public isRunning: boolean = false;\n  private middlewares: Middleware[] = [];\n  // Emits to immediately detach from the active run (stop processing its stream)\n  private activeRunDetach$?: Subject<void>;\n  private activeRunCompletionPromise?: Promise<void>;\n\n  get maxVersion() {\n    return packageJson.version;\n  }\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n\n    if (compareVersions(this.maxVersion, \"0.0.39\") <= 0) {\n      this.middlewares.unshift(new BackwardCompatibility_0_0_39());\n    }\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public use(...middlewares: (Middleware | MiddlewareFunction)[]): this {\n    const normalizedMiddlewares = middlewares.map((middleware) =>\n      typeof middleware === \"function\" ? new FunctionMiddleware(middleware) : middleware,\n    );\n    this.middlewares.push(...normalizedMiddlewares);\n    return this;\n  }\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => {\n          // Build middleware chain using reduceRight so middlewares can intercept runs.\n          if (this.middlewares.length === 0) {\n            return this.run(input);\n          }\n\n          const chainedAgent = this.middlewares.reduceRight(\n            (nextAgent: AbstractAgent, middleware) =>\n              ({\n                run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n              }) as AbstractAgent,\n            this, // Original agent is the final 'next'\n          );\n\n          return chainedAgent.run(input);\n        },\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          return this.onError(input, error, subscribers);\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null)));\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  protected connect(input: RunAgentInput): Observable<BaseEvent> {\n    throw new AGUIConnectNotImplementedError();\n  }\n  public async connectAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => this.connect(input),\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          if (!(error instanceof AGUIConnectNotImplementedError)) {\n            return this.onError(input, error, subscribers);\n          }\n          return EMPTY;\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null))); // wait for stream completion before toggling isRunning\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  public abortRun() {}\n\n  public async detachActiveRun(): Promise<void> {\n    if (!this.activeRunDetach$) {\n      return;\n    }\n    const completion = this.activeRunCompletionPromise ?? Promise.resolve();\n    this.activeRunDetach$.next();\n    this.activeRunDetach$?.complete();\n    await completion;\n  }\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    const clonedMessages = structuredClone_(this.messages) as Message[];\n    const messagesWithoutActivity = clonedMessages.filter((message) => message.role !== \"activity\");\n\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: messagesWithoutActivity,\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    cloned.agentId = this.agentId;\n    cloned.description = this.description;\n    cloned.threadId = this.threadId;\n    cloned.messages = structuredClone_(this.messages);\n    cloned.state = structuredClone_(this.state);\n    cloned.debug = this.debug;\n    cloned.isRunning = this.isRunning;\n    cloned.subscribers = [...this.subscribers];\n    cloned.middlewares = [...this.middlewares];\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    // Build middleware chain for legacy bridge\n    const runObservable = (() => {\n      if (this.middlewares.length === 0) {\n        return this.run(input);\n      }\n\n      const chainedAgent = this.middlewares.reduceRight(\n        (nextAgent: AbstractAgent, middleware) =>\n          ({\n            run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n          }) as AbstractAgent,\n        this,\n      );\n\n      return chainedAgent.run(input);\n    })();\n\n    return runObservable.pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n", "import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n          case EventType.ACTIVITY_SNAPSHOT:\n          case EventType.ACTIVITY_DELTA:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: messageChunkEvent.role || \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n        return [];\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        closePendingEvent();\n      }),\n    );\n  };\n", "import { AbstractAgent } from \"@/agent\";\nimport { RunAgentInput, BaseEvent, Message } from \"@ag-ui/core\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport { concatMap } from \"rxjs/operators\";\nimport { transformChunks } from \"@/chunks\";\nimport { defaultApplyEvents } from \"@/apply\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport type MiddlewareFunction = (\n  input: RunAgentInput,\n  next: AbstractAgent,\n) => Observable<BaseEvent>;\n\nexport interface EventWithState {\n  event: BaseEvent;\n  messages: Message[];\n  state: any;\n}\n\nexport abstract class Middleware {\n  abstract run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent>;\n\n  /**\n   * Runs the next agent in the chain with automatic chunk transformation.\n   */\n  protected runNext(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return next.run(input).pipe(\n      transformChunks(false), // Always transform chunks to full events\n    );\n  }\n\n  /**\n   * Runs the next agent and tracks state, providing current messages and state with each event.\n   * The messages and state represent the state AFTER the event has been applied.\n   */\n  protected runNextWithState(\n    input: RunAgentInput,\n    next: AbstractAgent,\n  ): Observable<EventWithState> {\n    let currentMessages = structuredClone_(input.messages || []);\n    let currentState = structuredClone_(input.state || {});\n\n    // Use a ReplaySubject to feed events one by one\n    const eventSubject = new ReplaySubject<BaseEvent>();\n\n    // Set up defaultApplyEvents to process events\n    const mutations$ = defaultApplyEvents(input, eventSubject, next, []);\n\n    // Subscribe to track state changes\n    mutations$.subscribe((mutation) => {\n      if (mutation.messages !== undefined) {\n        currentMessages = mutation.messages;\n      }\n      if (mutation.state !== undefined) {\n        currentState = mutation.state;\n      }\n    });\n\n    return this.runNext(input, next).pipe(\n      concatMap(async (event) => {\n        // Feed the event to defaultApplyEvents and wait for it to process\n        eventSubject.next(event);\n\n        // Give defaultApplyEvents a chance to process\n        await new Promise((resolve) => setTimeout(resolve, 0));\n\n        // Return event with current state\n        return {\n          event,\n          messages: structuredClone_(currentMessages),\n          state: structuredClone_(currentState),\n        };\n      }),\n    );\n  }\n}\n\n// Wrapper class to convert a function into a Middleware instance\nexport class FunctionMiddleware extends Middleware {\n  constructor(private fn: MiddlewareFunction) {\n    super();\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return this.fn(input, next);\n  }\n}\n", "import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport {\n  RunAgentInput,\n  BaseEvent,\n  EventType,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport { filter } from \"rxjs/operators\";\n\ntype FilterToolCallsConfig =\n  | { allowedToolCalls: string[]; disallowedToolCalls?: never }\n  | { disallowedToolCalls: string[]; allowedToolCalls?: never };\n\nexport class FilterToolCallsMiddleware extends Middleware {\n  private blockedToolCallIds = new Set<string>();\n  private readonly allowedTools?: Set<string>;\n  private readonly disallowedTools?: Set<string>;\n\n  constructor(config: FilterToolCallsConfig) {\n    super();\n\n    // Runtime validation (belt and suspenders approach)\n    if (config.allowedToolCalls && config.disallowedToolCalls) {\n      throw new Error(\"Cannot specify both allowedToolCalls and disallowedToolCalls\");\n    }\n\n    if (!config.allowedToolCalls && !config.disallowedToolCalls) {\n      throw new Error(\"Must specify either allowedToolCalls or disallowedToolCalls\");\n    }\n\n    if (config.allowedToolCalls) {\n      this.allowedTools = new Set(config.allowedToolCalls);\n    } else if (config.disallowedToolCalls) {\n      this.disallowedTools = new Set(config.disallowedToolCalls);\n    }\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    // Use runNext which already includes transformChunks\n    return this.runNext(input, next).pipe(\n      filter((event) => {\n        // Handle TOOL_CALL_START events\n        if (event.type === EventType.TOOL_CALL_START) {\n          const toolCallStartEvent = event as ToolCallStartEvent;\n          const shouldFilter = this.shouldFilterTool(toolCallStartEvent.toolCallName);\n\n          if (shouldFilter) {\n            // Track this tool call ID as blocked\n            this.blockedToolCallIds.add(toolCallStartEvent.toolCallId);\n            return false; // Filter out this event\n          }\n\n          return true; // Allow this event\n        }\n\n        // Handle TOOL_CALL_ARGS events\n        if (event.type === EventType.TOOL_CALL_ARGS) {\n          const toolCallArgsEvent = event as ToolCallArgsEvent;\n          return !this.blockedToolCallIds.has(toolCallArgsEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_END events\n        if (event.type === EventType.TOOL_CALL_END) {\n          const toolCallEndEvent = event as ToolCallEndEvent;\n          return !this.blockedToolCallIds.has(toolCallEndEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_RESULT events\n        if (event.type === EventType.TOOL_CALL_RESULT) {\n          const toolCallResultEvent = event as ToolCallResultEvent;\n          const isBlocked = this.blockedToolCallIds.has(toolCallResultEvent.toolCallId);\n\n          if (isBlocked) {\n            // Clean up the blocked ID after the last event\n            this.blockedToolCallIds.delete(toolCallResultEvent.toolCallId);\n            return false;\n          }\n\n          return true;\n        }\n\n        // Allow all other events through\n        return true;\n      }),\n    );\n  }\n\n  private shouldFilterTool(toolName: string): boolean {\n    if (this.allowedTools) {\n      // If using allowed list, filter out tools NOT in the list\n      return !this.allowedTools.has(toolName);\n    } else if (this.disallowedTools) {\n      // If using disallowed list, filter out tools IN the list\n      return this.disallowedTools.has(toolName);\n    }\n\n    return false;\n  }\n}\n", "import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport type { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport type { Observable } from \"rxjs\";\n\ntype InputMessage = RunAgentInput[\"messages\"][number];\n\nfunction sanitizeMessageContent(message: InputMessage): InputMessage {\n  const rawContent = (message as { content?: unknown }).content;\n\n  if (Array.isArray(rawContent)) {\n    const concatenatedContent = rawContent\n      .filter(\n        (part): part is { type: \"text\"; text: string } =>\n          typeof part === \"object\" &&\n          part !== null &&\n          \"type\" in part &&\n          (part as { type: unknown }).type === \"text\" &&\n          typeof (part as { text?: unknown }).text === \"string\",\n      )\n      .map((part) => part.text)\n      .join(\"\");\n\n    return {\n      ...message,\n      content: concatenatedContent,\n    } as InputMessage;\n  }\n\n  if (typeof rawContent === \"string\") {\n    return message;\n  }\n\n  return {\n    ...message,\n    content: \"\",\n  } as InputMessage;\n}\n\n/**\n * Middleware placeholder that maintains compatibility with AG-UI 0.0.39 flows.\n * Currently it simply forwards all events to the next middleware/agent.\n */\nexport class BackwardCompatibility_0_0_39 extends Middleware {\n  override run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    const { parentRunId: _parentRunId, ...rest } = input;\n    const sanitizedInput: RunAgentInput = {\n      ...rest,\n      messages: rest.messages.map(sanitizeMessageContent),\n    } as RunAgentInput;\n\n    return this.runNext(sanitizedInput, next);\n  }\n}\n", "{\n  \"name\": \"@ag-ui/client\",\n  \"author\": \"Markus Ecker <markus.ecker@gmail.com>\",\n  \"version\": \"0.0.42\",\n  \"private\": false,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"files\": [\n    \"dist/**\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"clean\": \"rm -rf dist .turbo node_modules\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\",\n    \"link:global\": \"pnpm link --global\",\n    \"unlink:global\": \"pnpm unlink --global\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/core\": \"workspace:*\",\n    \"@ag-ui/encoder\": \"workspace:*\",\n    \"@ag-ui/proto\": \"workspace:*\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"compare-versions\": \"^6.1.1\",\n    \"fast-json-patch\": \"^3.1.1\",\n    \"rxjs\": \"7.8.1\",\n    \"untruncate-json\": \"^0.0.1\",\n    \"uuid\": \"^11.1.0\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^20.11.19\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.2\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n", "import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public clone(): HttpAgent {\n    const cloned = super.clone() as HttpAgent;\n    cloned.url = this.url;\n    cloned.headers = structuredClone_(this.headers ?? {});\n\n    const newController = new AbortController();\n    const originalSignal = this.abortController.signal as AbortSignal & { reason?: unknown };\n    if (originalSignal.aborted) {\n      newController.abort(originalSignal.reason);\n    }\n    cloned.abortController = newController;\n\n    return cloned;\n  }\n}\n", "import {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n} from \"@ag-ui/core\";\n\n/**\n * Compacts streaming events by consolidating multiple deltas into single events.\n * For text messages: multiple content deltas become one concatenated delta.\n * For tool calls: multiple args deltas become one concatenated delta.\n * Events between related streaming events are reordered to keep streaming events together.\n *\n * @param events - Array of events to compact\n * @returns Compacted array of events\n */\nexport function compactEvents(events: BaseEvent[]): BaseEvent[] {\n  const compacted: BaseEvent[] = [];\n  const pendingTextMessages = new Map<\n    string,\n    {\n      start?: TextMessageStartEvent;\n      contents: TextMessageContentEvent[];\n      end?: TextMessageEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n  const pendingToolCalls = new Map<\n    string,\n    {\n      start?: ToolCallStartEvent;\n      args: ToolCallArgsEvent[];\n      end?: ToolCallEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n\n  for (const event of events) {\n    // Handle text message streaming events\n    if (event.type === EventType.TEXT_MESSAGE_START) {\n      const startEvent = event as TextMessageStartEvent;\n      const messageId = startEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TEXT_MESSAGE_CONTENT) {\n      const contentEvent = event as TextMessageContentEvent;\n      const messageId = contentEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.contents.push(contentEvent);\n    } else if (event.type === EventType.TEXT_MESSAGE_END) {\n      const endEvent = event as TextMessageEndEvent;\n      const messageId = endEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.end = endEvent;\n\n      // Flush this message's events\n      flushTextMessage(messageId, pending, compacted);\n      pendingTextMessages.delete(messageId);\n    } else if (event.type === EventType.TOOL_CALL_START) {\n      const startEvent = event as ToolCallStartEvent;\n      const toolCallId = startEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TOOL_CALL_ARGS) {\n      const argsEvent = event as ToolCallArgsEvent;\n      const toolCallId = argsEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.args.push(argsEvent);\n    } else if (event.type === EventType.TOOL_CALL_END) {\n      const endEvent = event as ToolCallEndEvent;\n      const toolCallId = endEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.end = endEvent;\n\n      // Flush this tool call's events\n      flushToolCall(toolCallId, pending, compacted);\n      pendingToolCalls.delete(toolCallId);\n    } else {\n      // For non-streaming events, check if we're in the middle of any streaming sequences\n      let addedToBuffer = false;\n\n      // Check text messages\n      for (const [messageId, pending] of pendingTextMessages) {\n        // If we have a start but no end yet, this event is \"in between\"\n        if (pending.start && !pending.end) {\n          pending.otherEvents.push(event);\n          addedToBuffer = true;\n          break;\n        }\n      }\n\n      // Check tool calls if not already buffered\n      if (!addedToBuffer) {\n        for (const [toolCallId, pending] of pendingToolCalls) {\n          // If we have a start but no end yet, this event is \"in between\"\n          if (pending.start && !pending.end) {\n            pending.otherEvents.push(event);\n            addedToBuffer = true;\n            break;\n          }\n        }\n      }\n\n      // If not in the middle of any streaming sequence, add directly to compacted\n      if (!addedToBuffer) {\n        compacted.push(event);\n      }\n    }\n  }\n\n  // Flush any remaining incomplete messages\n  for (const [messageId, pending] of pendingTextMessages) {\n    flushTextMessage(messageId, pending, compacted);\n  }\n\n  // Flush any remaining incomplete tool calls\n  for (const [toolCallId, pending] of pendingToolCalls) {\n    flushToolCall(toolCallId, pending, compacted);\n  }\n\n  return compacted;\n}\n\nfunction flushTextMessage(\n  messageId: string,\n  pending: {\n    start?: TextMessageStartEvent;\n    contents: TextMessageContentEvent[];\n    end?: TextMessageEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all content events into one\n  if (pending.contents.length > 0) {\n    const concatenatedDelta = pending.contents.map((c) => c.delta).join(\"\");\n\n    const compactedContent: TextMessageContentEvent = {\n      type: EventType.TEXT_MESSAGE_CONTENT,\n      messageId: messageId,\n      delta: concatenatedDelta,\n    };\n\n    compacted.push(compactedContent);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n\nfunction flushToolCall(\n  toolCallId: string,\n  pending: {\n    start?: ToolCallStartEvent;\n    args: ToolCallArgsEvent[];\n    end?: ToolCallEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all args events into one\n  if (pending.args.length > 0) {\n    const concatenatedArgs = pending.args.map((a) => a.delta).join(\"\");\n\n    const compactedArgs: ToolCallArgsEvent = {\n      type: EventType.TOOL_CALL_ARGS,\n      toolCallId: toolCallId,\n      delta: concatenatedArgs,\n    };\n\n    compacted.push(compactedArgs);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n", "export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"./utils\";\nexport * from \"./compact\";\nexport * from \"@ag-ui/core\";\nexport * from \"./chunks\";\nexport * from \"./middleware\";\n\nexport { Middleware, FilterToolCallsMiddleware } from \"./middleware\";\nexport type { MiddlewareFunction } from \"./middleware\";\n", "import { v4 as uuidv4 } from \"uuid\";\nimport * as PartialJSON from \"partial-json\";\n\nexport function randomUUID() {\n  return uuidv4();\n}\n\nexport function partialJSONParse(json: string) {\n  try {\n    return PartialJSON.parse(json);\n  } catch (error) {\n    return {};\n  }\n}\n", "export const logger = console;\n", "export const DEFAULT_AGENT_ID = \"default\";\n", "import {\n  BaseEvent,\n  EventType,\n  RunErrorEvent,\n} from \"@ag-ui/client\";\nimport { randomUUID } from \"./utils\";\n\ninterface FinalizeRunOptions {\n  stopRequested?: boolean;\n  interruptionMessage?: string;\n}\n\nconst defaultStopMessage = \"Run stopped by user\";\nconst defaultAbruptEndMessage = \"Run ended without emitting a terminal event\";\n\nexport function finalizeRunEvents(\n  events: BaseEvent[],\n  options: FinalizeRunOptions = {},\n): BaseEvent[] {\n  const { stopRequested = false, interruptionMessage } = options;\n\n  const resolvedStopMessage = interruptionMessage ?? defaultStopMessage;\n  const resolvedAbruptMessage =\n    interruptionMessage && interruptionMessage !== defaultStopMessage\n      ? interruptionMessage\n      : defaultAbruptEndMessage;\n\n  const appended: BaseEvent[] = [];\n\n  const openMessageIds = new Set<string>();\n  const openToolCalls = new Map<\n    string,\n    {\n      hasEnd: boolean;\n      hasResult: boolean;\n    }\n  >();\n\n  for (const event of events) {\n    switch (event.type) {\n      case EventType.TEXT_MESSAGE_START: {\n        const messageId = (event as { messageId?: string }).messageId;\n        if (typeof messageId === \"string\") {\n          openMessageIds.add(messageId);\n        }\n        break;\n      }\n      case EventType.TEXT_MESSAGE_END: {\n        const messageId = (event as { messageId?: string }).messageId;\n        if (typeof messageId === \"string\") {\n          openMessageIds.delete(messageId);\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_START: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        if (typeof toolCallId === \"string\") {\n          openToolCalls.set(toolCallId, {\n            hasEnd: false,\n            hasResult: false,\n          });\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_END: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        const info = toolCallId ? openToolCalls.get(toolCallId) : undefined;\n        if (info) {\n          info.hasEnd = true;\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_RESULT: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        const info = toolCallId ? openToolCalls.get(toolCallId) : undefined;\n        if (info) {\n          info.hasResult = true;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  const hasRunFinished = events.some((event) => event.type === EventType.RUN_FINISHED);\n  const hasRunError = events.some((event) => event.type === EventType.RUN_ERROR);\n  const hasTerminalEvent = hasRunFinished || hasRunError;\n  const terminalEventMissing = !hasTerminalEvent;\n\n  for (const messageId of openMessageIds) {\n    const endEvent = {\n      type: EventType.TEXT_MESSAGE_END,\n      messageId,\n    } as BaseEvent;\n    events.push(endEvent);\n    appended.push(endEvent);\n  }\n\n  for (const [toolCallId, info] of openToolCalls) {\n    if (!info.hasEnd) {\n      const endEvent = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId,\n      } as BaseEvent;\n      events.push(endEvent);\n      appended.push(endEvent);\n    }\n\n    if (terminalEventMissing && !info.hasResult) {\n      const resultEvent = {\n        type: EventType.TOOL_CALL_RESULT,\n        toolCallId,\n        messageId: `${toolCallId ?? randomUUID()}-result`,\n        role: \"tool\",\n        content: JSON.stringify(\n          stopRequested\n            ? {\n                status: \"stopped\",\n                reason: \"stop_requested\",\n                message: resolvedStopMessage,\n              }\n            : {\n                status: \"error\",\n                reason: \"missing_terminal_event\",\n                message: resolvedAbruptMessage,\n              },\n        ),\n      } as BaseEvent;\n      events.push(resultEvent);\n      appended.push(resultEvent);\n    }\n  }\n\n  if (terminalEventMissing) {\n    if (stopRequested) {\n      const finishedEvent = {\n        type: EventType.RUN_FINISHED,\n      } as BaseEvent;\n      events.push(finishedEvent);\n      appended.push(finishedEvent);\n    } else {\n      const errorEvent: RunErrorEvent = {\n        type: EventType.RUN_ERROR,\n        message: resolvedAbruptMessage,\n        code: \"INCOMPLETE_STREAM\",\n      };\n      events.push(errorEvent);\n      appended.push(errorEvent);\n    }\n  }\n\n  return appended;\n}\n", "/**\n * Error codes for transcription HTTP responses.\n * Uses snake_case to align with existing CopilotKitCoreErrorCode pattern.\n * These codes are returned by the runtime and parsed by the client.\n */\nexport enum TranscriptionErrorCode {\n  /** Transcription service not configured in runtime */\n  SERVICE_NOT_CONFIGURED = \"service_not_configured\",\n  /** Audio format not supported */\n  INVALID_AUDIO_FORMAT = \"invalid_audio_format\",\n  /** Audio file is too long */\n  AUDIO_TOO_LONG = \"audio_too_long\",\n  /** Audio file is empty or too short */\n  AUDIO_TOO_SHORT = \"audio_too_short\",\n  /** Rate limited by transcription provider */\n  RATE_LIMITED = \"rate_limited\",\n  /** Authentication failed with transcription provider */\n  AUTH_FAILED = \"auth_failed\",\n  /** Transcription provider returned an error */\n  PROVIDER_ERROR = \"provider_error\",\n  /** Network error during transcription */\n  NETWORK_ERROR = \"network_error\",\n  /** Invalid request format */\n  INVALID_REQUEST = \"invalid_request\",\n}\n\n/**\n * Error response format returned by the transcription endpoint.\n */\nexport interface TranscriptionErrorResponse {\n  error: TranscriptionErrorCode;\n  message: string;\n  retryable?: boolean;\n}\n\n/**\n * Helper functions to create transcription error responses.\n * Used by the runtime to return consistent error responses.\n */\nexport const TranscriptionErrors = {\n  serviceNotConfigured: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.SERVICE_NOT_CONFIGURED,\n    message: \"Transcription service is not configured\",\n    retryable: false,\n  }),\n\n  invalidAudioFormat: (format: string, supported: string[]): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.INVALID_AUDIO_FORMAT,\n    message: `Unsupported audio format: ${format}. Supported: ${supported.join(\", \")}`,\n    retryable: false,\n  }),\n\n  invalidRequest: (details: string): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.INVALID_REQUEST,\n    message: details,\n    retryable: false,\n  }),\n\n  rateLimited: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.RATE_LIMITED,\n    message: \"Rate limited. Please try again later.\",\n    retryable: true,\n  }),\n\n  authFailed: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUTH_FAILED,\n    message: \"Authentication failed with transcription provider\",\n    retryable: false,\n  }),\n\n  providerError: (message: string): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.PROVIDER_ERROR,\n    message,\n    retryable: true,\n  }),\n\n  networkError: (message: string = \"Network error during transcription\"): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.NETWORK_ERROR,\n    message,\n    retryable: true,\n  }),\n\n  audioTooLong: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUDIO_TOO_LONG,\n    message: \"Audio file is too long\",\n    retryable: false,\n  }),\n\n  audioTooShort: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUDIO_TOO_SHORT,\n    message: \"Audio is too short to transcribe\",\n    retryable: false,\n  }),\n};\n", "import { z } from \"zod\";\n\nexport const FunctionCallSchema = z.object({\n  name: z.string(),\n  arguments: z.string(),\n});\n\nexport const ToolCallSchema = z.object({\n  id: z.string(),\n  type: z.literal(\"function\"),\n  function: FunctionCallSchema,\n});\n\nexport const BaseMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string().optional(),\n  name: z.string().optional(),\n});\n\nexport const TextInputContentSchema = z.object({\n  type: z.literal(\"text\"),\n  text: z.string(),\n});\n\nconst BinaryInputContentObjectSchema = z.object({\n  type: z.literal(\"binary\"),\n  mimeType: z.string(),\n  id: z.string().optional(),\n  url: z.string().optional(),\n  data: z.string().optional(),\n  filename: z.string().optional(),\n});\n\nconst ensureBinaryPayload = (\n  value: { id?: string; url?: string; data?: string },\n  ctx: z.RefinementCtx,\n) => {\n  if (!value.id && !value.url && !value.data) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"BinaryInputContent requires at least one of id, url, or data.\",\n      path: [\"id\"],\n    });\n  }\n};\n\nexport const BinaryInputContentSchema = BinaryInputContentObjectSchema.superRefine((value, ctx) => {\n  ensureBinaryPayload(value, ctx);\n});\n\nconst InputContentBaseSchema = z.discriminatedUnion(\"type\", [\n  TextInputContentSchema,\n  BinaryInputContentObjectSchema,\n]);\n\nexport const InputContentSchema = InputContentBaseSchema.superRefine((value, ctx) => {\n  if (value.type === \"binary\") {\n    ensureBinaryPayload(value, ctx);\n  }\n});\n\nexport const DeveloperMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"developer\"),\n  content: z.string(),\n});\n\nexport const SystemMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"system\"),\n  content: z.string(),\n});\n\nexport const AssistantMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"assistant\"),\n  content: z.string().optional(),\n  toolCalls: z.array(ToolCallSchema).optional(),\n});\n\nexport const UserMessageSchema = BaseMessageSchema.extend({\n  role: z.literal(\"user\"),\n  content: z.union([z.string(), z.array(InputContentSchema)]),\n});\n\nexport const ToolMessageSchema = z.object({\n  id: z.string(),\n  content: z.string(),\n  role: z.literal(\"tool\"),\n  toolCallId: z.string(),\n  error: z.string().optional(),\n});\n\nexport const ActivityMessageSchema = z.object({\n  id: z.string(),\n  role: z.literal(\"activity\"),\n  activityType: z.string(),\n  content: z.record(z.any()),\n});\n\nexport const MessageSchema = z.discriminatedUnion(\"role\", [\n  DeveloperMessageSchema,\n  SystemMessageSchema,\n  AssistantMessageSchema,\n  UserMessageSchema,\n  ToolMessageSchema,\n  ActivityMessageSchema,\n]);\n\nexport const RoleSchema = z.union([\n  z.literal(\"developer\"),\n  z.literal(\"system\"),\n  z.literal(\"assistant\"),\n  z.literal(\"user\"),\n  z.literal(\"tool\"),\n  z.literal(\"activity\"),\n]);\n\nexport const ContextSchema = z.object({\n  description: z.string(),\n  value: z.string(),\n});\n\nexport const ToolSchema = z.object({\n  name: z.string(),\n  description: z.string(),\n  parameters: z.any(), // JSON Schema for the tool parameters\n});\n\nexport const RunAgentInputSchema = z.object({\n  threadId: z.string(),\n  runId: z.string(),\n  parentRunId: z.string().optional(),\n  state: z.any(),\n  messages: z.array(MessageSchema),\n  tools: z.array(ToolSchema),\n  context: z.array(ContextSchema),\n  forwardedProps: z.any(),\n});\n\nexport const StateSchema = z.any();\n\nexport type ToolCall = z.infer<typeof ToolCallSchema>;\nexport type FunctionCall = z.infer<typeof FunctionCallSchema>;\nexport type TextInputContent = z.infer<typeof TextInputContentSchema>;\nexport type BinaryInputContent = z.infer<typeof BinaryInputContentSchema>;\nexport type InputContent = z.infer<typeof InputContentSchema>;\nexport type DeveloperMessage = z.infer<typeof DeveloperMessageSchema>;\nexport type SystemMessage = z.infer<typeof SystemMessageSchema>;\nexport type AssistantMessage = z.infer<typeof AssistantMessageSchema>;\nexport type UserMessage = z.infer<typeof UserMessageSchema>;\nexport type ToolMessage = z.infer<typeof ToolMessageSchema>;\nexport type ActivityMessage = z.infer<typeof ActivityMessageSchema>;\nexport type Message = z.infer<typeof MessageSchema>;\nexport type Context = z.infer<typeof ContextSchema>;\nexport type Tool = z.infer<typeof ToolSchema>;\nexport type RunAgentInput = z.infer<typeof RunAgentInputSchema>;\nexport type State = z.infer<typeof StateSchema>;\nexport type Role = z.infer<typeof RoleSchema>;\n\nexport class AGUIError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class AGUIConnectNotImplementedError extends AGUIError {\n  constructor() {\n    super(\"Connect not implemented. This method is not supported by the current agent.\");\n  }\n}\n", "import { z } from \"zod\";\nimport { MessageSchema, StateSchema, RunAgentInputSchema } from \"./types\";\n\n// Text messages can have any role except \"tool\"\nconst TextMessageRoleSchema = z.union([\n  z.literal(\"developer\"),\n  z.literal(\"system\"),\n  z.literal(\"assistant\"),\n  z.literal(\"user\"),\n]);\n\nexport enum EventType {\n  TEXT_MESSAGE_START = \"TEXT_MESSAGE_START\",\n  TEXT_MESSAGE_CONTENT = \"TEXT_MESSAGE_CONTENT\",\n  TEXT_MESSAGE_END = \"TEXT_MESSAGE_END\",\n  TEXT_MESSAGE_CHUNK = \"TEXT_MESSAGE_CHUNK\",\n  THINKING_TEXT_MESSAGE_START = \"THINKING_TEXT_MESSAGE_START\",\n  THINKING_TEXT_MESSAGE_CONTENT = \"THINKING_TEXT_MESSAGE_CONTENT\",\n  THINKING_TEXT_MESSAGE_END = \"THINKING_TEXT_MESSAGE_END\",\n  TOOL_CALL_START = \"TOOL_CALL_START\",\n  TOOL_CALL_ARGS = \"TOOL_CALL_ARGS\",\n  TOOL_CALL_END = \"TOOL_CALL_END\",\n  TOOL_CALL_CHUNK = \"TOOL_CALL_CHUNK\",\n  TOOL_CALL_RESULT = \"TOOL_CALL_RESULT\",\n  THINKING_START = \"THINKING_START\",\n  THINKING_END = \"THINKING_END\",\n  STATE_SNAPSHOT = \"STATE_SNAPSHOT\",\n  STATE_DELTA = \"STATE_DELTA\",\n  MESSAGES_SNAPSHOT = \"MESSAGES_SNAPSHOT\",\n  ACTIVITY_SNAPSHOT = \"ACTIVITY_SNAPSHOT\",\n  ACTIVITY_DELTA = \"ACTIVITY_DELTA\",\n  RAW = \"RAW\",\n  CUSTOM = \"CUSTOM\",\n  RUN_STARTED = \"RUN_STARTED\",\n  RUN_FINISHED = \"RUN_FINISHED\",\n  RUN_ERROR = \"RUN_ERROR\",\n  STEP_STARTED = \"STEP_STARTED\",\n  STEP_FINISHED = \"STEP_FINISHED\",\n}\n\nexport const BaseEventSchema = z.object({\n  type: z.nativeEnum(EventType),\n  timestamp: z.number().optional(),\n  rawEvent: z.any().optional(),\n});\n\nexport const TextMessageStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_START),\n  messageId: z.string(),\n  role: TextMessageRoleSchema.default(\"assistant\"),\n});\n\nexport const TextMessageContentEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_CONTENT),\n  messageId: z.string(),\n  delta: z.string().refine((s) => s.length > 0, \"Delta must not be an empty string\"),\n});\n\nexport const TextMessageEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_END),\n  messageId: z.string(),\n});\n\nexport const TextMessageChunkEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TEXT_MESSAGE_CHUNK),\n  messageId: z.string().optional(),\n  role: TextMessageRoleSchema.optional(),\n  delta: z.string().optional(),\n});\n\nexport const ThinkingTextMessageStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_START),\n});\n\nexport const ThinkingTextMessageContentEventSchema = TextMessageContentEventSchema.omit({\n  messageId: true,\n  type: true,\n}).extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_CONTENT),\n});\n\nexport const ThinkingTextMessageEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_TEXT_MESSAGE_END),\n});\n\nexport const ToolCallStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_START),\n  toolCallId: z.string(),\n  toolCallName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const ToolCallArgsEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_ARGS),\n  toolCallId: z.string(),\n  delta: z.string(),\n});\n\nexport const ToolCallEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_END),\n  toolCallId: z.string(),\n});\n\nexport const ToolCallResultEventSchema = BaseEventSchema.extend({\n  messageId: z.string(),\n  type: z.literal(EventType.TOOL_CALL_RESULT),\n  toolCallId: z.string(),\n  content: z.string(),\n  role: z.literal(\"tool\").optional(),\n});\n\nexport const ToolCallChunkEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.TOOL_CALL_CHUNK),\n  toolCallId: z.string().optional(),\n  toolCallName: z.string().optional(),\n  parentMessageId: z.string().optional(),\n  delta: z.string().optional(),\n});\n\nexport const ThinkingStartEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_START),\n  title: z.string().optional(),\n});\n\nexport const ThinkingEndEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.THINKING_END),\n});\n\nexport const StateSnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STATE_SNAPSHOT),\n  snapshot: StateSchema,\n});\n\nexport const StateDeltaEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STATE_DELTA),\n  delta: z.array(z.any()), // JSON Patch (RFC 6902)\n});\n\nexport const MessagesSnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.MESSAGES_SNAPSHOT),\n  messages: z.array(MessageSchema),\n});\n\nexport const ActivitySnapshotEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.ACTIVITY_SNAPSHOT),\n  messageId: z.string(),\n  activityType: z.string(),\n  content: z.record(z.any()),\n  replace: z.boolean().optional().default(true),\n});\n\nexport const ActivityDeltaEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.ACTIVITY_DELTA),\n  messageId: z.string(),\n  activityType: z.string(),\n  patch: z.array(z.any()),\n});\n\nexport const RawEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RAW),\n  event: z.any(),\n  source: z.string().optional(),\n});\n\nexport const CustomEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.CUSTOM),\n  name: z.string(),\n  value: z.any(),\n});\n\nexport const RunStartedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_STARTED),\n  threadId: z.string(),\n  runId: z.string(),\n  parentRunId: z.string().optional(),\n  input: RunAgentInputSchema.optional(),\n});\n\nexport const RunFinishedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_FINISHED),\n  threadId: z.string(),\n  runId: z.string(),\n  result: z.any().optional(),\n});\n\nexport const RunErrorEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.RUN_ERROR),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const StepStartedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STEP_STARTED),\n  stepName: z.string(),\n});\n\nexport const StepFinishedEventSchema = BaseEventSchema.extend({\n  type: z.literal(EventType.STEP_FINISHED),\n  stepName: z.string(),\n});\n\nexport const EventSchemas = z.discriminatedUnion(\"type\", [\n  TextMessageStartEventSchema,\n  TextMessageContentEventSchema,\n  TextMessageEndEventSchema,\n  TextMessageChunkEventSchema,\n  ThinkingStartEventSchema,\n  ThinkingEndEventSchema,\n  ThinkingTextMessageStartEventSchema,\n  ThinkingTextMessageContentEventSchema,\n  ThinkingTextMessageEndEventSchema,\n  ToolCallStartEventSchema,\n  ToolCallArgsEventSchema,\n  ToolCallEndEventSchema,\n  ToolCallChunkEventSchema,\n  ToolCallResultEventSchema,\n  StateSnapshotEventSchema,\n  StateDeltaEventSchema,\n  MessagesSnapshotEventSchema,\n  ActivitySnapshotEventSchema,\n  ActivityDeltaEventSchema,\n  RawEventSchema,\n  CustomEventSchema,\n  RunStartedEventSchema,\n  RunFinishedEventSchema,\n  RunErrorEventSchema,\n  StepStartedEventSchema,\n  StepFinishedEventSchema,\n]);\n\nexport type BaseEvent = z.infer<typeof BaseEventSchema>;\nexport type TextMessageStartEvent = z.infer<typeof TextMessageStartEventSchema>;\nexport type TextMessageContentEvent = z.infer<typeof TextMessageContentEventSchema>;\nexport type TextMessageEndEvent = z.infer<typeof TextMessageEndEventSchema>;\nexport type TextMessageChunkEvent = z.infer<typeof TextMessageChunkEventSchema>;\nexport type ThinkingTextMessageStartEvent = z.infer<typeof ThinkingTextMessageStartEventSchema>;\nexport type ThinkingTextMessageContentEvent = z.infer<typeof ThinkingTextMessageContentEventSchema>;\nexport type ThinkingTextMessageEndEvent = z.infer<typeof ThinkingTextMessageEndEventSchema>;\nexport type ToolCallStartEvent = z.infer<typeof ToolCallStartEventSchema>;\nexport type ToolCallArgsEvent = z.infer<typeof ToolCallArgsEventSchema>;\nexport type ToolCallEndEvent = z.infer<typeof ToolCallEndEventSchema>;\nexport type ToolCallChunkEvent = z.infer<typeof ToolCallChunkEventSchema>;\nexport type ToolCallResultEvent = z.infer<typeof ToolCallResultEventSchema>;\nexport type ThinkingStartEvent = z.infer<typeof ThinkingStartEventSchema>;\nexport type ThinkingEndEvent = z.infer<typeof ThinkingEndEventSchema>;\nexport type StateSnapshotEvent = z.infer<typeof StateSnapshotEventSchema>;\nexport type StateDeltaEvent = z.infer<typeof StateDeltaEventSchema>;\nexport type MessagesSnapshotEvent = z.infer<typeof MessagesSnapshotEventSchema>;\nexport type ActivitySnapshotEvent = z.infer<typeof ActivitySnapshotEventSchema>;\nexport type ActivityDeltaEvent = z.infer<typeof ActivityDeltaEventSchema>;\nexport type RawEvent = z.infer<typeof RawEventSchema>;\nexport type CustomEvent = z.infer<typeof CustomEventSchema>;\nexport type RunStartedEvent = z.infer<typeof RunStartedEventSchema>;\nexport type RunFinishedEvent = z.infer<typeof RunFinishedEventSchema>;\nexport type RunErrorEvent = z.infer<typeof RunErrorEventSchema>;\nexport type StepStartedEvent = z.infer<typeof StepStartedEventSchema>;\nexport type StepFinishedEvent = z.infer<typeof StepFinishedEventSchema>;\n", "import { BaseEvent, EventSchemas, EventType, Message } from \"@ag-ui/core\";\nimport * as protoEvents from \"./generated/events\";\nimport * as protoPatch from \"./generated/patch\";\n\nfunction toCamelCase(str: string): string {\n  return str.toLowerCase().replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n\n/**\n * Encodes an event message to a protocol buffer binary format.\n */\nexport function encode(event: BaseEvent): Uint8Array {\n  const oneofField = toCamelCase(event.type);\n  const { type, timestamp, rawEvent, ...rest } = event as any;\n\n  // since protobuf does not support optional arrays, we need to ensure that the toolCalls array is always present\n  if (type === EventType.MESSAGES_SNAPSHOT) {\n    rest.messages = rest.messages.map((message: Message) => {\n      const untypedMessage = message as any;\n      if (untypedMessage.toolCalls === undefined) {\n        return { ...message, toolCalls: [] };\n      }\n      return message;\n    });\n  }\n\n  // custom mapping for json patch operations\n  if (type === EventType.STATE_DELTA) {\n    rest.delta = rest.delta.map((operation: any) => ({\n      ...operation,\n      op: protoPatch.JsonPatchOperationType[operation.op.toUpperCase()],\n    }));\n  }\n\n  const eventMessage = {\n    [oneofField]: {\n      baseEvent: {\n        type: protoEvents.EventType[event.type as keyof typeof protoEvents.EventType],\n        timestamp,\n        rawEvent,\n      },\n      ...rest,\n    },\n  };\n  return protoEvents.Event.encode(eventMessage).finish();\n}\n\n/**\n * Decodes a protocol buffer binary format to an event message.\n * The format includes a 4-byte length prefix followed by the message.\n */\nexport function decode(data: Uint8Array): BaseEvent {\n  const event = protoEvents.Event.decode(data);\n  const decoded = Object.values(event).find((value) => value !== undefined);\n  if (!decoded) {\n    throw new Error(\"Invalid event\");\n  }\n  decoded.type = protoEvents.EventType[decoded.baseEvent.type];\n  decoded.timestamp = decoded.baseEvent.timestamp;\n  decoded.rawEvent = decoded.baseEvent.rawEvent;\n\n  // we want tool calls to be optional, so we need to remove them if they are empty\n  if (decoded.type === EventType.MESSAGES_SNAPSHOT) {\n    for (const message of (decoded as any).messages as Message[]) {\n      const untypedMessage = message as any;\n      if (untypedMessage.toolCalls?.length === 0) {\n        untypedMessage.toolCalls = undefined;\n      }\n    }\n  }\n\n  // custom mapping for json patch operations\n  if (decoded.type === EventType.STATE_DELTA) {\n    for (const operation of (decoded as any).delta) {\n      operation.op = protoPatch.JsonPatchOperationType[operation.op].toLowerCase();\n      Object.keys(operation).forEach((key) => {\n        if (operation[key] === undefined) {\n          delete operation[key];\n        }\n      });\n    }\n  }\n\n  Object.keys(decoded).forEach((key) => {\n    if (decoded[key] === undefined) {\n      delete decoded[key];\n    }\n  });\n\n  return EventSchemas.parse(decoded);\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: events.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { Value } from \"./google/protobuf/struct\";\nimport { JsonPatchOperation } from \"./patch\";\nimport { Message } from \"./types\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport enum EventType {\n  TEXT_MESSAGE_START = 0,\n  TEXT_MESSAGE_CONTENT = 1,\n  TEXT_MESSAGE_END = 2,\n  TOOL_CALL_START = 3,\n  TOOL_CALL_ARGS = 4,\n  TOOL_CALL_END = 5,\n  STATE_SNAPSHOT = 6,\n  STATE_DELTA = 7,\n  MESSAGES_SNAPSHOT = 8,\n  RAW = 9,\n  CUSTOM = 10,\n  RUN_STARTED = 11,\n  RUN_FINISHED = 12,\n  RUN_ERROR = 13,\n  STEP_STARTED = 14,\n  STEP_FINISHED = 15,\n  UNRECOGNIZED = -1,\n}\n\nexport interface BaseEvent {\n  type: EventType;\n  timestamp?: number | undefined;\n  rawEvent?: any | undefined;\n}\n\nexport interface TextMessageStartEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n  role?: string | undefined;\n}\n\nexport interface TextMessageContentEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n  delta: string;\n}\n\nexport interface TextMessageEndEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId: string;\n}\n\nexport interface ToolCallStartEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string | undefined;\n}\n\nexport interface ToolCallArgsEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n  delta: string;\n}\n\nexport interface ToolCallEndEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId: string;\n}\n\nexport interface StateSnapshotEvent {\n  baseEvent: BaseEvent | undefined;\n  snapshot: any | undefined;\n}\n\nexport interface StateDeltaEvent {\n  baseEvent: BaseEvent | undefined;\n  delta: JsonPatchOperation[];\n}\n\nexport interface MessagesSnapshotEvent {\n  baseEvent: BaseEvent | undefined;\n  messages: Message[];\n}\n\nexport interface RawEvent {\n  baseEvent: BaseEvent | undefined;\n  event: any | undefined;\n  source?: string | undefined;\n}\n\nexport interface CustomEvent {\n  baseEvent: BaseEvent | undefined;\n  name: string;\n  value?: any | undefined;\n}\n\nexport interface RunStartedEvent {\n  baseEvent: BaseEvent | undefined;\n  threadId: string;\n  runId: string;\n}\n\nexport interface RunFinishedEvent {\n  baseEvent: BaseEvent | undefined;\n  threadId: string;\n  runId: string;\n  result?: any | undefined;\n}\n\nexport interface RunErrorEvent {\n  baseEvent: BaseEvent | undefined;\n  code?: string | undefined;\n  message: string;\n}\n\nexport interface StepStartedEvent {\n  baseEvent: BaseEvent | undefined;\n  stepName: string;\n}\n\nexport interface StepFinishedEvent {\n  baseEvent: BaseEvent | undefined;\n  stepName: string;\n}\n\nexport interface TextMessageChunkEvent {\n  baseEvent: BaseEvent | undefined;\n  messageId?: string | undefined;\n  role?: string | undefined;\n  delta?: string | undefined;\n}\n\nexport interface ToolCallChunkEvent {\n  baseEvent: BaseEvent | undefined;\n  toolCallId?: string | undefined;\n  toolCallName?: string | undefined;\n  parentMessageId?: string | undefined;\n  delta?: string | undefined;\n}\n\nexport interface Event {\n  textMessageStart?: TextMessageStartEvent | undefined;\n  textMessageContent?: TextMessageContentEvent | undefined;\n  textMessageEnd?: TextMessageEndEvent | undefined;\n  toolCallStart?: ToolCallStartEvent | undefined;\n  toolCallArgs?: ToolCallArgsEvent | undefined;\n  toolCallEnd?: ToolCallEndEvent | undefined;\n  stateSnapshot?: StateSnapshotEvent | undefined;\n  stateDelta?: StateDeltaEvent | undefined;\n  messagesSnapshot?: MessagesSnapshotEvent | undefined;\n  raw?: RawEvent | undefined;\n  custom?: CustomEvent | undefined;\n  runStarted?: RunStartedEvent | undefined;\n  runFinished?: RunFinishedEvent | undefined;\n  runError?: RunErrorEvent | undefined;\n  stepStarted?: StepStartedEvent | undefined;\n  stepFinished?: StepFinishedEvent | undefined;\n  textMessageChunk?: TextMessageChunkEvent | undefined;\n  toolCallChunk?: ToolCallChunkEvent | undefined;\n}\n\nfunction createBaseBaseEvent(): BaseEvent {\n  return { type: 0, timestamp: undefined, rawEvent: undefined };\n}\n\nexport const BaseEvent: MessageFns<BaseEvent> = {\n  encode(message: BaseEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (message.timestamp !== undefined) {\n      writer.uint32(16).int64(message.timestamp);\n    }\n    if (message.rawEvent !== undefined) {\n      Value.encode(Value.wrap(message.rawEvent), writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): BaseEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseBaseEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.type = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 16) {\n            break;\n          }\n\n          message.timestamp = longToNumber(reader.int64());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.rawEvent = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<BaseEvent>, I>>(base?: I): BaseEvent {\n    return BaseEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<BaseEvent>, I>>(object: I): BaseEvent {\n    const message = createBaseBaseEvent();\n    message.type = object.type ?? 0;\n    message.timestamp = object.timestamp ?? undefined;\n    message.rawEvent = object.rawEvent ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTextMessageStartEvent(): TextMessageStartEvent {\n  return { baseEvent: undefined, messageId: \"\", role: undefined };\n}\n\nexport const TextMessageStartEvent: MessageFns<TextMessageStartEvent> = {\n  encode(message: TextMessageStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.role !== undefined) {\n      writer.uint32(26).string(message.role);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageStartEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageStartEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(base?: I): TextMessageStartEvent {\n    return TextMessageStartEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageStartEvent>, I>>(object: I): TextMessageStartEvent {\n    const message = createBaseTextMessageStartEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    message.role = object.role ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseTextMessageContentEvent(): TextMessageContentEvent {\n  return { baseEvent: undefined, messageId: \"\", delta: \"\" };\n}\n\nexport const TextMessageContentEvent: MessageFns<TextMessageContentEvent> = {\n  encode(message: TextMessageContentEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.delta !== \"\") {\n      writer.uint32(26).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageContentEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageContentEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(base?: I): TextMessageContentEvent {\n    return TextMessageContentEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageContentEvent>, I>>(object: I): TextMessageContentEvent {\n    const message = createBaseTextMessageContentEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    message.delta = object.delta ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextMessageEndEvent(): TextMessageEndEvent {\n  return { baseEvent: undefined, messageId: \"\" };\n}\n\nexport const TextMessageEndEvent: MessageFns<TextMessageEndEvent> = {\n  encode(message: TextMessageEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== \"\") {\n      writer.uint32(18).string(message.messageId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageEndEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageEndEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(base?: I): TextMessageEndEvent {\n    return TextMessageEndEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageEndEvent>, I>>(object: I): TextMessageEndEvent {\n    const message = createBaseTextMessageEndEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseToolCallStartEvent(): ToolCallStartEvent {\n  return { baseEvent: undefined, toolCallId: \"\", toolCallName: \"\", parentMessageId: undefined };\n}\n\nexport const ToolCallStartEvent: MessageFns<ToolCallStartEvent> = {\n  encode(message: ToolCallStartEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.toolCallName !== \"\") {\n      writer.uint32(26).string(message.toolCallName);\n    }\n    if (message.parentMessageId !== undefined) {\n      writer.uint32(34).string(message.parentMessageId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallStartEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallStartEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.toolCallName = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.parentMessageId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(base?: I): ToolCallStartEvent {\n    return ToolCallStartEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallStartEvent>, I>>(object: I): ToolCallStartEvent {\n    const message = createBaseToolCallStartEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    message.toolCallName = object.toolCallName ?? \"\";\n    message.parentMessageId = object.parentMessageId ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCallArgsEvent(): ToolCallArgsEvent {\n  return { baseEvent: undefined, toolCallId: \"\", delta: \"\" };\n}\n\nexport const ToolCallArgsEvent: MessageFns<ToolCallArgsEvent> = {\n  encode(message: ToolCallArgsEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.delta !== \"\") {\n      writer.uint32(26).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallArgsEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallArgsEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(base?: I): ToolCallArgsEvent {\n    return ToolCallArgsEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallArgsEvent>, I>>(object: I): ToolCallArgsEvent {\n    const message = createBaseToolCallArgsEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    message.delta = object.delta ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseToolCallEndEvent(): ToolCallEndEvent {\n  return { baseEvent: undefined, toolCallId: \"\" };\n}\n\nexport const ToolCallEndEvent: MessageFns<ToolCallEndEvent> = {\n  encode(message: ToolCallEndEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== \"\") {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallEndEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallEndEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(base?: I): ToolCallEndEvent {\n    return ToolCallEndEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallEndEvent>, I>>(object: I): ToolCallEndEvent {\n    const message = createBaseToolCallEndEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStateSnapshotEvent(): StateSnapshotEvent {\n  return { baseEvent: undefined, snapshot: undefined };\n}\n\nexport const StateSnapshotEvent: MessageFns<StateSnapshotEvent> = {\n  encode(message: StateSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.snapshot !== undefined) {\n      Value.encode(Value.wrap(message.snapshot), writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StateSnapshotEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStateSnapshotEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.snapshot = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(base?: I): StateSnapshotEvent {\n    return StateSnapshotEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StateSnapshotEvent>, I>>(object: I): StateSnapshotEvent {\n    const message = createBaseStateSnapshotEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.snapshot = object.snapshot ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseStateDeltaEvent(): StateDeltaEvent {\n  return { baseEvent: undefined, delta: [] };\n}\n\nexport const StateDeltaEvent: MessageFns<StateDeltaEvent> = {\n  encode(message: StateDeltaEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    for (const v of message.delta) {\n      JsonPatchOperation.encode(v!, writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StateDeltaEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStateDeltaEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.delta.push(JsonPatchOperation.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(base?: I): StateDeltaEvent {\n    return StateDeltaEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StateDeltaEvent>, I>>(object: I): StateDeltaEvent {\n    const message = createBaseStateDeltaEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.delta = object.delta?.map((e) => JsonPatchOperation.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseMessagesSnapshotEvent(): MessagesSnapshotEvent {\n  return { baseEvent: undefined, messages: [] };\n}\n\nexport const MessagesSnapshotEvent: MessageFns<MessagesSnapshotEvent> = {\n  encode(message: MessagesSnapshotEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    for (const v of message.messages) {\n      Message.encode(v!, writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): MessagesSnapshotEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMessagesSnapshotEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messages.push(Message.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(base?: I): MessagesSnapshotEvent {\n    return MessagesSnapshotEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<MessagesSnapshotEvent>, I>>(object: I): MessagesSnapshotEvent {\n    const message = createBaseMessagesSnapshotEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseRawEvent(): RawEvent {\n  return { baseEvent: undefined, event: undefined, source: undefined };\n}\n\nexport const RawEvent: MessageFns<RawEvent> = {\n  encode(message: RawEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.event !== undefined) {\n      Value.encode(Value.wrap(message.event), writer.uint32(18).fork()).join();\n    }\n    if (message.source !== undefined) {\n      writer.uint32(26).string(message.source);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RawEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRawEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.event = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.source = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RawEvent>, I>>(base?: I): RawEvent {\n    return RawEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RawEvent>, I>>(object: I): RawEvent {\n    const message = createBaseRawEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.event = object.event ?? undefined;\n    message.source = object.source ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseCustomEvent(): CustomEvent {\n  return { baseEvent: undefined, name: \"\", value: undefined };\n}\n\nexport const CustomEvent: MessageFns<CustomEvent> = {\n  encode(message: CustomEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.name !== \"\") {\n      writer.uint32(18).string(message.name);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): CustomEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCustomEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<CustomEvent>, I>>(base?: I): CustomEvent {\n    return CustomEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<CustomEvent>, I>>(object: I): CustomEvent {\n    const message = createBaseCustomEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.name = object.name ?? \"\";\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseRunStartedEvent(): RunStartedEvent {\n  return { baseEvent: undefined, threadId: \"\", runId: \"\" };\n}\n\nexport const RunStartedEvent: MessageFns<RunStartedEvent> = {\n  encode(message: RunStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.threadId !== \"\") {\n      writer.uint32(18).string(message.threadId);\n    }\n    if (message.runId !== \"\") {\n      writer.uint32(26).string(message.runId);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunStartedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.threadId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.runId = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunStartedEvent>, I>>(base?: I): RunStartedEvent {\n    return RunStartedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunStartedEvent>, I>>(object: I): RunStartedEvent {\n    const message = createBaseRunStartedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.threadId = object.threadId ?? \"\";\n    message.runId = object.runId ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseRunFinishedEvent(): RunFinishedEvent {\n  return { baseEvent: undefined, threadId: \"\", runId: \"\", result: undefined };\n}\n\nexport const RunFinishedEvent: MessageFns<RunFinishedEvent> = {\n  encode(message: RunFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.threadId !== \"\") {\n      writer.uint32(18).string(message.threadId);\n    }\n    if (message.runId !== \"\") {\n      writer.uint32(26).string(message.runId);\n    }\n    if (message.result !== undefined) {\n      Value.encode(Value.wrap(message.result), writer.uint32(34).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunFinishedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunFinishedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.threadId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.runId = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.result = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(base?: I): RunFinishedEvent {\n    return RunFinishedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunFinishedEvent>, I>>(object: I): RunFinishedEvent {\n    const message = createBaseRunFinishedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.threadId = object.threadId ?? \"\";\n    message.runId = object.runId ?? \"\";\n    message.result = object.result ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseRunErrorEvent(): RunErrorEvent {\n  return { baseEvent: undefined, code: undefined, message: \"\" };\n}\n\nexport const RunErrorEvent: MessageFns<RunErrorEvent> = {\n  encode(message: RunErrorEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.code !== undefined) {\n      writer.uint32(18).string(message.code);\n    }\n    if (message.message !== \"\") {\n      writer.uint32(26).string(message.message);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): RunErrorEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseRunErrorEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.code = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.message = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<RunErrorEvent>, I>>(base?: I): RunErrorEvent {\n    return RunErrorEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<RunErrorEvent>, I>>(object: I): RunErrorEvent {\n    const message = createBaseRunErrorEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.code = object.code ?? undefined;\n    message.message = object.message ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStepStartedEvent(): StepStartedEvent {\n  return { baseEvent: undefined, stepName: \"\" };\n}\n\nexport const StepStartedEvent: MessageFns<StepStartedEvent> = {\n  encode(message: StepStartedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.stepName !== \"\") {\n      writer.uint32(18).string(message.stepName);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StepStartedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStepStartedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.stepName = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StepStartedEvent>, I>>(base?: I): StepStartedEvent {\n    return StepStartedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StepStartedEvent>, I>>(object: I): StepStartedEvent {\n    const message = createBaseStepStartedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.stepName = object.stepName ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseStepFinishedEvent(): StepFinishedEvent {\n  return { baseEvent: undefined, stepName: \"\" };\n}\n\nexport const StepFinishedEvent: MessageFns<StepFinishedEvent> = {\n  encode(message: StepFinishedEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.stepName !== \"\") {\n      writer.uint32(18).string(message.stepName);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): StepFinishedEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStepFinishedEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.stepName = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(base?: I): StepFinishedEvent {\n    return StepFinishedEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<StepFinishedEvent>, I>>(object: I): StepFinishedEvent {\n    const message = createBaseStepFinishedEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.stepName = object.stepName ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextMessageChunkEvent(): TextMessageChunkEvent {\n  return { baseEvent: undefined, messageId: undefined, role: undefined, delta: undefined };\n}\n\nexport const TextMessageChunkEvent: MessageFns<TextMessageChunkEvent> = {\n  encode(message: TextMessageChunkEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.messageId !== undefined) {\n      writer.uint32(18).string(message.messageId);\n    }\n    if (message.role !== undefined) {\n      writer.uint32(26).string(message.role);\n    }\n    if (message.delta !== undefined) {\n      writer.uint32(34).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextMessageChunkEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextMessageChunkEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.messageId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<TextMessageChunkEvent>, I>>(base?: I): TextMessageChunkEvent {\n    return TextMessageChunkEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextMessageChunkEvent>, I>>(object: I): TextMessageChunkEvent {\n    const message = createBaseTextMessageChunkEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.messageId = object.messageId ?? undefined;\n    message.role = object.role ?? undefined;\n    message.delta = object.delta ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCallChunkEvent(): ToolCallChunkEvent {\n  return {\n    baseEvent: undefined,\n    toolCallId: undefined,\n    toolCallName: undefined,\n    parentMessageId: undefined,\n    delta: undefined,\n  };\n}\n\nexport const ToolCallChunkEvent: MessageFns<ToolCallChunkEvent> = {\n  encode(message: ToolCallChunkEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.baseEvent !== undefined) {\n      BaseEvent.encode(message.baseEvent, writer.uint32(10).fork()).join();\n    }\n    if (message.toolCallId !== undefined) {\n      writer.uint32(18).string(message.toolCallId);\n    }\n    if (message.toolCallName !== undefined) {\n      writer.uint32(26).string(message.toolCallName);\n    }\n    if (message.parentMessageId !== undefined) {\n      writer.uint32(34).string(message.parentMessageId);\n    }\n    if (message.delta !== undefined) {\n      writer.uint32(42).string(message.delta);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCallChunkEvent {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCallChunkEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.baseEvent = BaseEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.toolCallName = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.parentMessageId = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.delta = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCallChunkEvent>, I>>(base?: I): ToolCallChunkEvent {\n    return ToolCallChunkEvent.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCallChunkEvent>, I>>(object: I): ToolCallChunkEvent {\n    const message = createBaseToolCallChunkEvent();\n    message.baseEvent = (object.baseEvent !== undefined && object.baseEvent !== null)\n      ? BaseEvent.fromPartial(object.baseEvent)\n      : undefined;\n    message.toolCallId = object.toolCallId ?? undefined;\n    message.toolCallName = object.toolCallName ?? undefined;\n    message.parentMessageId = object.parentMessageId ?? undefined;\n    message.delta = object.delta ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseEvent(): Event {\n  return {\n    textMessageStart: undefined,\n    textMessageContent: undefined,\n    textMessageEnd: undefined,\n    toolCallStart: undefined,\n    toolCallArgs: undefined,\n    toolCallEnd: undefined,\n    stateSnapshot: undefined,\n    stateDelta: undefined,\n    messagesSnapshot: undefined,\n    raw: undefined,\n    custom: undefined,\n    runStarted: undefined,\n    runFinished: undefined,\n    runError: undefined,\n    stepStarted: undefined,\n    stepFinished: undefined,\n    textMessageChunk: undefined,\n    toolCallChunk: undefined,\n  };\n}\n\nexport const Event: MessageFns<Event> = {\n  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.textMessageStart !== undefined) {\n      TextMessageStartEvent.encode(message.textMessageStart, writer.uint32(10).fork()).join();\n    }\n    if (message.textMessageContent !== undefined) {\n      TextMessageContentEvent.encode(message.textMessageContent, writer.uint32(18).fork()).join();\n    }\n    if (message.textMessageEnd !== undefined) {\n      TextMessageEndEvent.encode(message.textMessageEnd, writer.uint32(26).fork()).join();\n    }\n    if (message.toolCallStart !== undefined) {\n      ToolCallStartEvent.encode(message.toolCallStart, writer.uint32(34).fork()).join();\n    }\n    if (message.toolCallArgs !== undefined) {\n      ToolCallArgsEvent.encode(message.toolCallArgs, writer.uint32(42).fork()).join();\n    }\n    if (message.toolCallEnd !== undefined) {\n      ToolCallEndEvent.encode(message.toolCallEnd, writer.uint32(50).fork()).join();\n    }\n    if (message.stateSnapshot !== undefined) {\n      StateSnapshotEvent.encode(message.stateSnapshot, writer.uint32(58).fork()).join();\n    }\n    if (message.stateDelta !== undefined) {\n      StateDeltaEvent.encode(message.stateDelta, writer.uint32(66).fork()).join();\n    }\n    if (message.messagesSnapshot !== undefined) {\n      MessagesSnapshotEvent.encode(message.messagesSnapshot, writer.uint32(74).fork()).join();\n    }\n    if (message.raw !== undefined) {\n      RawEvent.encode(message.raw, writer.uint32(82).fork()).join();\n    }\n    if (message.custom !== undefined) {\n      CustomEvent.encode(message.custom, writer.uint32(90).fork()).join();\n    }\n    if (message.runStarted !== undefined) {\n      RunStartedEvent.encode(message.runStarted, writer.uint32(98).fork()).join();\n    }\n    if (message.runFinished !== undefined) {\n      RunFinishedEvent.encode(message.runFinished, writer.uint32(106).fork()).join();\n    }\n    if (message.runError !== undefined) {\n      RunErrorEvent.encode(message.runError, writer.uint32(114).fork()).join();\n    }\n    if (message.stepStarted !== undefined) {\n      StepStartedEvent.encode(message.stepStarted, writer.uint32(122).fork()).join();\n    }\n    if (message.stepFinished !== undefined) {\n      StepFinishedEvent.encode(message.stepFinished, writer.uint32(130).fork()).join();\n    }\n    if (message.textMessageChunk !== undefined) {\n      TextMessageChunkEvent.encode(message.textMessageChunk, writer.uint32(138).fork()).join();\n    }\n    if (message.toolCallChunk !== undefined) {\n      ToolCallChunkEvent.encode(message.toolCallChunk, writer.uint32(146).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Event {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseEvent();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.textMessageStart = TextMessageStartEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.textMessageContent = TextMessageContentEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.textMessageEnd = TextMessageEndEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.toolCallStart = ToolCallStartEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.toolCallArgs = ToolCallArgsEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.toolCallEnd = ToolCallEndEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.stateSnapshot = StateSnapshotEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.stateDelta = StateDeltaEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 9: {\n          if (tag !== 74) {\n            break;\n          }\n\n          message.messagesSnapshot = MessagesSnapshotEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 10: {\n          if (tag !== 82) {\n            break;\n          }\n\n          message.raw = RawEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 11: {\n          if (tag !== 90) {\n            break;\n          }\n\n          message.custom = CustomEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 12: {\n          if (tag !== 98) {\n            break;\n          }\n\n          message.runStarted = RunStartedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 13: {\n          if (tag !== 106) {\n            break;\n          }\n\n          message.runFinished = RunFinishedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 14: {\n          if (tag !== 114) {\n            break;\n          }\n\n          message.runError = RunErrorEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 15: {\n          if (tag !== 122) {\n            break;\n          }\n\n          message.stepStarted = StepStartedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 16: {\n          if (tag !== 130) {\n            break;\n          }\n\n          message.stepFinished = StepFinishedEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 17: {\n          if (tag !== 138) {\n            break;\n          }\n\n          message.textMessageChunk = TextMessageChunkEvent.decode(reader, reader.uint32());\n          continue;\n        }\n        case 18: {\n          if (tag !== 146) {\n            break;\n          }\n\n          message.toolCallChunk = ToolCallChunkEvent.decode(reader, reader.uint32());\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {\n    return Event.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {\n    const message = createBaseEvent();\n    message.textMessageStart = (object.textMessageStart !== undefined && object.textMessageStart !== null)\n      ? TextMessageStartEvent.fromPartial(object.textMessageStart)\n      : undefined;\n    message.textMessageContent = (object.textMessageContent !== undefined && object.textMessageContent !== null)\n      ? TextMessageContentEvent.fromPartial(object.textMessageContent)\n      : undefined;\n    message.textMessageEnd = (object.textMessageEnd !== undefined && object.textMessageEnd !== null)\n      ? TextMessageEndEvent.fromPartial(object.textMessageEnd)\n      : undefined;\n    message.toolCallStart = (object.toolCallStart !== undefined && object.toolCallStart !== null)\n      ? ToolCallStartEvent.fromPartial(object.toolCallStart)\n      : undefined;\n    message.toolCallArgs = (object.toolCallArgs !== undefined && object.toolCallArgs !== null)\n      ? ToolCallArgsEvent.fromPartial(object.toolCallArgs)\n      : undefined;\n    message.toolCallEnd = (object.toolCallEnd !== undefined && object.toolCallEnd !== null)\n      ? ToolCallEndEvent.fromPartial(object.toolCallEnd)\n      : undefined;\n    message.stateSnapshot = (object.stateSnapshot !== undefined && object.stateSnapshot !== null)\n      ? StateSnapshotEvent.fromPartial(object.stateSnapshot)\n      : undefined;\n    message.stateDelta = (object.stateDelta !== undefined && object.stateDelta !== null)\n      ? StateDeltaEvent.fromPartial(object.stateDelta)\n      : undefined;\n    message.messagesSnapshot = (object.messagesSnapshot !== undefined && object.messagesSnapshot !== null)\n      ? MessagesSnapshotEvent.fromPartial(object.messagesSnapshot)\n      : undefined;\n    message.raw = (object.raw !== undefined && object.raw !== null) ? RawEvent.fromPartial(object.raw) : undefined;\n    message.custom = (object.custom !== undefined && object.custom !== null)\n      ? CustomEvent.fromPartial(object.custom)\n      : undefined;\n    message.runStarted = (object.runStarted !== undefined && object.runStarted !== null)\n      ? RunStartedEvent.fromPartial(object.runStarted)\n      : undefined;\n    message.runFinished = (object.runFinished !== undefined && object.runFinished !== null)\n      ? RunFinishedEvent.fromPartial(object.runFinished)\n      : undefined;\n    message.runError = (object.runError !== undefined && object.runError !== null)\n      ? RunErrorEvent.fromPartial(object.runError)\n      : undefined;\n    message.stepStarted = (object.stepStarted !== undefined && object.stepStarted !== null)\n      ? StepStartedEvent.fromPartial(object.stepStarted)\n      : undefined;\n    message.stepFinished = (object.stepFinished !== undefined && object.stepFinished !== null)\n      ? StepFinishedEvent.fromPartial(object.stepFinished)\n      : undefined;\n    message.textMessageChunk = (object.textMessageChunk !== undefined && object.textMessageChunk !== null)\n      ? TextMessageChunkEvent.fromPartial(object.textMessageChunk)\n      : undefined;\n    message.toolCallChunk = (object.toolCallChunk !== undefined && object.toolCallChunk !== null)\n      ? ToolCallChunkEvent.fromPartial(object.toolCallChunk)\n      : undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction longToNumber(int64: { toString(): string }): number {\n  const num = globalThis.Number(int64.toString());\n  if (num > globalThis.Number.MAX_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n  }\n  if (num < globalThis.Number.MIN_SAFE_INTEGER) {\n    throw new globalThis.Error(\"Value is smaller than Number.MIN_SAFE_INTEGER\");\n  }\n  return num;\n}\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: google/protobuf/struct.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"google.protobuf\";\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n * The JSON representation for `NullValue` is JSON `null`.\n */\nexport enum NullValue {\n  /** NULL_VALUE - Null value. */\n  NULL_VALUE = 0,\n  UNRECOGNIZED = -1,\n}\n\n/**\n * `Struct` represents a structured data value, consisting of fields\n * which map to dynamically typed values. In some languages, `Struct`\n * might be supported by a native representation. For example, in\n * scripting languages like JS a struct is represented as an\n * object. The details of that representation are described together\n * with the proto support for the language.\n *\n * The JSON representation for `Struct` is JSON object.\n */\nexport interface Struct {\n  /** Unordered map of dynamically typed values. */\n  fields: { [key: string]: any | undefined };\n}\n\nexport interface Struct_FieldsEntry {\n  key: string;\n  value: any | undefined;\n}\n\n/**\n * `Value` represents a dynamically typed value which can be either\n * null, a number, a string, a boolean, a recursive struct value, or a\n * list of values. A producer of value is expected to set one of these\n * variants. Absence of any variant indicates an error.\n *\n * The JSON representation for `Value` is JSON value.\n */\nexport interface Value {\n  /** Represents a null value. */\n  nullValue?:\n    | NullValue\n    | undefined;\n  /** Represents a double value. */\n  numberValue?:\n    | number\n    | undefined;\n  /** Represents a string value. */\n  stringValue?:\n    | string\n    | undefined;\n  /** Represents a boolean value. */\n  boolValue?:\n    | boolean\n    | undefined;\n  /** Represents a structured value. */\n  structValue?:\n    | { [key: string]: any }\n    | undefined;\n  /** Represents a repeated `Value`. */\n  listValue?: Array<any> | undefined;\n}\n\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n * The JSON representation for `ListValue` is JSON array.\n */\nexport interface ListValue {\n  /** Repeated field of dynamically typed values. */\n  values: any[];\n}\n\nfunction createBaseStruct(): Struct {\n  return { fields: {} };\n}\n\nexport const Struct: MessageFns<Struct> & StructWrapperFns = {\n  encode(message: Struct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    Object.entries(message.fields).forEach(([key, value]) => {\n      if (value !== undefined) {\n        Struct_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();\n      }\n    });\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());\n          if (entry1.value !== undefined) {\n            message.fields[entry1.key] = entry1.value;\n          }\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Struct>, I>>(base?: I): Struct {\n    return Struct.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct>, I>>(object: I): Struct {\n    const message = createBaseStruct();\n    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: any | undefined }>(\n      (acc, [key, value]) => {\n        if (value !== undefined) {\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {},\n    );\n    return message;\n  },\n\n  wrap(object: { [key: string]: any } | undefined): Struct {\n    const struct = createBaseStruct();\n\n    if (object !== undefined) {\n      for (const key of Object.keys(object)) {\n        struct.fields[key] = object[key];\n      }\n    }\n    return struct;\n  },\n\n  unwrap(message: Struct): { [key: string]: any } {\n    const object: { [key: string]: any } = {};\n    if (message.fields) {\n      for (const key of Object.keys(message.fields)) {\n        object[key] = message.fields[key];\n      }\n    }\n    return object;\n  },\n};\n\nfunction createBaseStruct_FieldsEntry(): Struct_FieldsEntry {\n  return { key: \"\", value: undefined };\n}\n\nexport const Struct_FieldsEntry: MessageFns<Struct_FieldsEntry> = {\n  encode(message: Struct_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct_FieldsEntry {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct_FieldsEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.key = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(base?: I): Struct_FieldsEntry {\n    return Struct_FieldsEntry.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(object: I): Struct_FieldsEntry {\n    const message = createBaseStruct_FieldsEntry();\n    message.key = object.key ?? \"\";\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseValue(): Value {\n  return {\n    nullValue: undefined,\n    numberValue: undefined,\n    stringValue: undefined,\n    boolValue: undefined,\n    structValue: undefined,\n    listValue: undefined,\n  };\n}\n\nexport const Value: MessageFns<Value> & AnyValueWrapperFns = {\n  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.nullValue !== undefined) {\n      writer.uint32(8).int32(message.nullValue);\n    }\n    if (message.numberValue !== undefined) {\n      writer.uint32(17).double(message.numberValue);\n    }\n    if (message.stringValue !== undefined) {\n      writer.uint32(26).string(message.stringValue);\n    }\n    if (message.boolValue !== undefined) {\n      writer.uint32(32).bool(message.boolValue);\n    }\n    if (message.structValue !== undefined) {\n      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();\n    }\n    if (message.listValue !== undefined) {\n      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Value {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.nullValue = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 17) {\n            break;\n          }\n\n          message.numberValue = reader.double();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.stringValue = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 32) {\n            break;\n          }\n\n          message.boolValue = reader.bool();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {\n    return Value.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {\n    const message = createBaseValue();\n    message.nullValue = object.nullValue ?? undefined;\n    message.numberValue = object.numberValue ?? undefined;\n    message.stringValue = object.stringValue ?? undefined;\n    message.boolValue = object.boolValue ?? undefined;\n    message.structValue = object.structValue ?? undefined;\n    message.listValue = object.listValue ?? undefined;\n    return message;\n  },\n\n  wrap(value: any): Value {\n    const result = createBaseValue();\n    if (value === null) {\n      result.nullValue = NullValue.NULL_VALUE;\n    } else if (typeof value === \"boolean\") {\n      result.boolValue = value;\n    } else if (typeof value === \"number\") {\n      result.numberValue = value;\n    } else if (typeof value === \"string\") {\n      result.stringValue = value;\n    } else if (globalThis.Array.isArray(value)) {\n      result.listValue = value;\n    } else if (typeof value === \"object\") {\n      result.structValue = value;\n    } else if (typeof value !== \"undefined\") {\n      throw new globalThis.Error(\"Unsupported any value type: \" + typeof value);\n    }\n    return result;\n  },\n\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined {\n    if (message.stringValue !== undefined) {\n      return message.stringValue;\n    } else if (message?.numberValue !== undefined) {\n      return message.numberValue;\n    } else if (message?.boolValue !== undefined) {\n      return message.boolValue;\n    } else if (message?.structValue !== undefined) {\n      return message.structValue as any;\n    } else if (message?.listValue !== undefined) {\n      return message.listValue;\n    } else if (message?.nullValue !== undefined) {\n      return null;\n    }\n    return undefined;\n  },\n};\n\nfunction createBaseListValue(): ListValue {\n  return { values: [] };\n}\n\nexport const ListValue: MessageFns<ListValue> & ListValueWrapperFns = {\n  encode(message: ListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    for (const v of message.values) {\n      Value.encode(Value.wrap(v!), writer.uint32(10).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ListValue {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseListValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ListValue>, I>>(base?: I): ListValue {\n    return ListValue.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ListValue>, I>>(object: I): ListValue {\n    const message = createBaseListValue();\n    message.values = object.values?.map((e) => e) || [];\n    return message;\n  },\n\n  wrap(array: Array<any> | undefined): ListValue {\n    const result = createBaseListValue();\n    result.values = array ?? [];\n    return result;\n  },\n\n  unwrap(message: ListValue): Array<any> {\n    if (message?.hasOwnProperty(\"values\") && globalThis.Array.isArray(message.values)) {\n      return message.values;\n    } else {\n      return message as any;\n    }\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n\nexport interface StructWrapperFns {\n  wrap(object: { [key: string]: any } | undefined): Struct;\n  unwrap(message: Struct): { [key: string]: any };\n}\n\nexport interface AnyValueWrapperFns {\n  wrap(value: any): Value;\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined;\n}\n\nexport interface ListValueWrapperFns {\n  wrap(array: Array<any> | undefined): ListValue;\n  unwrap(message: ListValue): Array<any>;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: patch.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { Value } from \"./google/protobuf/struct\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport enum JsonPatchOperationType {\n  ADD = 0,\n  REMOVE = 1,\n  REPLACE = 2,\n  MOVE = 3,\n  COPY = 4,\n  TEST = 5,\n  UNRECOGNIZED = -1,\n}\n\nexport interface JsonPatchOperation {\n  op: JsonPatchOperationType;\n  path: string;\n  from?: string | undefined;\n  value?: any | undefined;\n}\n\nfunction createBaseJsonPatchOperation(): JsonPatchOperation {\n  return { op: 0, path: \"\", from: undefined, value: undefined };\n}\n\nexport const JsonPatchOperation: MessageFns<JsonPatchOperation> = {\n  encode(message: JsonPatchOperation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.op !== 0) {\n      writer.uint32(8).int32(message.op);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    if (message.from !== undefined) {\n      writer.uint32(26).string(message.from);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(34).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): JsonPatchOperation {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseJsonPatchOperation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.op = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.path = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.from = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<JsonPatchOperation>, I>>(base?: I): JsonPatchOperation {\n    return JsonPatchOperation.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<JsonPatchOperation>, I>>(object: I): JsonPatchOperation {\n    const message = createBaseJsonPatchOperation();\n    message.op = object.op ?? 0;\n    message.path = object.path ?? \"\";\n    message.from = object.from ?? undefined;\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.7.7\n//   protoc               v5.29.3\n// source: types.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"ag_ui\";\n\nexport interface ToolCall {\n  id: string;\n  type: string;\n  function: ToolCall_Function | undefined;\n}\n\nexport interface ToolCall_Function {\n  name: string;\n  arguments: string;\n}\n\nexport interface Message {\n  id: string;\n  role: string;\n  content?: string | undefined;\n  name?: string | undefined;\n  toolCalls: ToolCall[];\n  toolCallId?: string | undefined;\n  error?: string | undefined;\n}\n\nfunction createBaseToolCall(): ToolCall {\n  return { id: \"\", type: \"\", function: undefined };\n}\n\nexport const ToolCall: MessageFns<ToolCall> = {\n  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.type !== \"\") {\n      writer.uint32(18).string(message.type);\n    }\n    if (message.function !== undefined) {\n      ToolCall_Function.encode(message.function, writer.uint32(26).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCall();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.id = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.type = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.function = ToolCall_Function.decode(reader, reader.uint32());\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {\n    return ToolCall.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {\n    const message = createBaseToolCall();\n    message.id = object.id ?? \"\";\n    message.type = object.type ?? \"\";\n    message.function = (object.function !== undefined && object.function !== null)\n      ? ToolCall_Function.fromPartial(object.function)\n      : undefined;\n    return message;\n  },\n};\n\nfunction createBaseToolCall_Function(): ToolCall_Function {\n  return { name: \"\", arguments: \"\" };\n}\n\nexport const ToolCall_Function: MessageFns<ToolCall_Function> = {\n  encode(message: ToolCall_Function, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.arguments !== \"\") {\n      writer.uint32(18).string(message.arguments);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall_Function {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseToolCall_Function();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.arguments = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<ToolCall_Function>, I>>(base?: I): ToolCall_Function {\n    return ToolCall_Function.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ToolCall_Function>, I>>(object: I): ToolCall_Function {\n    const message = createBaseToolCall_Function();\n    message.name = object.name ?? \"\";\n    message.arguments = object.arguments ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseMessage(): Message {\n  return {\n    id: \"\",\n    role: \"\",\n    content: undefined,\n    name: undefined,\n    toolCalls: [],\n    toolCallId: undefined,\n    error: undefined,\n  };\n}\n\nexport const Message: MessageFns<Message> = {\n  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.role !== \"\") {\n      writer.uint32(18).string(message.role);\n    }\n    if (message.content !== undefined) {\n      writer.uint32(26).string(message.content);\n    }\n    if (message.name !== undefined) {\n      writer.uint32(34).string(message.name);\n    }\n    for (const v of message.toolCalls) {\n      ToolCall.encode(v!, writer.uint32(42).fork()).join();\n    }\n    if (message.toolCallId !== undefined) {\n      writer.uint32(50).string(message.toolCallId);\n    }\n    if (message.error !== undefined) {\n      writer.uint32(58).string(message.error);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Message {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    const end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.id = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.content = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.name = reader.string();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.toolCalls.push(ToolCall.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.toolCallId = reader.string();\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.error = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {\n    return Message.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {\n    const message = createBaseMessage();\n    message.id = object.id ?? \"\";\n    message.role = object.role ?? \"\";\n    message.content = object.content ?? undefined;\n    message.name = object.name ?? undefined;\n    message.toolCalls = object.toolCalls?.map((e) => ToolCall.fromPartial(e)) || [];\n    message.toolCallId = object.toolCallId ?? undefined;\n    message.error = object.error ?? undefined;\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n", "export { encode, decode } from \"./proto\";\n\nexport const AGUI_MEDIA_TYPE = \"application/vnd.ag-ui.event+proto\";\n", "import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  DeveloperMessage,\n  SystemMessage,\n  AssistantMessage,\n  UserMessage,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(agent.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role = \"assistant\" } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            // Text messages can be developer, system, assistant, or user (not tool)\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const { messageId, delta } = event as TextMessageContentEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append content to the correct message by ID\n            const existingContent =\n              typeof targetMessage.content === \"string\" ? targetMessage.content : \"\";\n            targetMessage.content = `${existingContent}${delta}`;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const { messageId } = event as TextMessageEndEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_END: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: targetMessage,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const { toolCallId, delta } = event as ToolCallArgsEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_ARGS: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallBuffer = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append the arguments to the correct tool call by ID\n            targetToolCall.function.arguments += delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const { toolCallId } = event as ToolCallEndEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_END: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_END: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallArgsString = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: targetToolCall,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_SNAPSHOT: {\n          const activityEvent = event as ActivitySnapshotEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          const existingMessage = existingIndex >= 0 ? messages[existingIndex] : undefined;\n          const existingActivityMessage =\n            existingMessage?.role === \"activity\" ? (existingMessage as ActivityMessage) : undefined;\n          const replace = activityEvent.replace ?? true;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivitySnapshotEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n                existingMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const activityMessage: ActivityMessage = {\n              id: activityEvent.messageId,\n              role: \"activity\",\n              activityType: activityEvent.activityType,\n              content: structuredClone_(activityEvent.content),\n            };\n\n            let createdMessage: ActivityMessage | undefined;\n\n            if (existingIndex === -1) {\n              messages.push(activityMessage);\n              createdMessage = activityMessage;\n            } else if (existingActivityMessage) {\n              if (replace) {\n                messages[existingIndex] = {\n                  ...existingActivityMessage,\n                  activityType: activityEvent.activityType,\n                  content: structuredClone_(activityEvent.content),\n                };\n              }\n            } else if (replace) {\n              messages[existingIndex] = activityMessage;\n              createdMessage = activityMessage;\n            }\n\n            applyMutation({ messages });\n\n            if (createdMessage) {\n              await Promise.all(\n                subscribers.map((subscriber) =>\n                  subscriber.onNewMessage?.({\n                    message: createdMessage,\n                    messages,\n                    state,\n                    agent,\n                    input,\n                  }),\n                ),\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_DELTA: {\n          const activityEvent = event as ActivityDeltaEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          if (existingIndex === -1) {\n            console.warn(\n              `ACTIVITY_DELTA: No message found with ID '${activityEvent.messageId}' to apply patch`,\n            );\n            return emitUpdates();\n          }\n\n          const existingMessage = messages[existingIndex];\n          if (existingMessage.role !== \"activity\") {\n            console.warn(\n              `ACTIVITY_DELTA: Message '${activityEvent.messageId}' is not an activity message`,\n            );\n            return emitUpdates();\n          }\n\n          const existingActivityMessage = existingMessage as ActivityMessage;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivityDeltaEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            try {\n              const baseContent = structuredClone_(existingActivityMessage.content ?? {});\n\n              const result = applyPatch(\n                baseContent,\n                activityEvent.patch ?? [],\n                true,\n                false,\n              );\n              const updatedContent = result.newDocument as ActivityMessage[\"content\"];\n\n              messages[existingIndex] = {\n                ...existingActivityMessage,\n                content: structuredClone_(updatedContent),\n                activityType: activityEvent.activityType,\n              };\n\n              applyMutation({ messages });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply activity patch for '${activityEvent.messageId}': ${errorMessage}`,\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          // Handle input.messages if present and stopPropagation is not set\n          if (mutation.stopPropagation !== true) {\n            const runStartedEvent = event as RunStartedEvent;\n\n            // Check if the event contains input with messages\n            if (runStartedEvent.input?.messages) {\n              // Add messages that aren't already present (checked by ID)\n              for (const message of runStartedEvent.input.messages) {\n                const existingMessage = messages.find((m) => m.id === message.id);\n                if (!existingMessage) {\n                  messages.push(message);\n                }\n              }\n\n              // Apply mutation to emit the updated messages\n              applyMutation({ messages });\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n", "import { v4 as uuidv4 } from \"uuid\";\n\nexport const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n\n/**\n * Generate a random UUID v4\n * Cross-platform compatible (Node.js, browsers, React Native)\n */\nexport function randomUUID(): string {\n  return uuidv4();\n}\n\n// Note: semver helpers were removed in favor of using\n// the external `compare-versions` library directly at call sites.\n\n\n/**\n * Parses a semantic version string into its numeric components.\n * Supports incomplete versions (e.g. \"1\", \"1.2\") by defaulting missing segments to zero.\n *\n * @throws If the version string is not a valid semantic version.\n */\n// (Intentionally left minimal.)\n", "import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivitySnapshotEvent?(\n    params: {\n      event: ActivitySnapshotEvent;\n      activityMessage?: ActivityMessage;\n      existingMessage?: Message;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivityDeltaEvent?(\n    params: {\n      event: ActivityDeltaEvent;\n      activityMessage?: ActivityMessage;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned  keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n", "import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessages = new Map<string, boolean>(); // Map of message ID -> active status\n    let activeToolCalls = new Map<string, boolean>(); // Map of tool call ID -> active status\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n    let runStarted = false; // Track if a run has started\n\n    // Function to reset state for a new run\n    const resetRunState = () => {\n      activeMessages.clear();\n      activeToolCalls.clear();\n      activeSteps.clear();\n      activeThinkingStep = false;\n      activeThinkingStepMessage = false;\n      runFinished = false;\n      runError = false;\n      runStarted = true;\n    };\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished (but allow new RUN_STARTED to start a new run)\n        if (runFinished && eventType !== EventType.RUN_ERROR && eventType !== EventType.RUN_STARTED) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Handle first event requirement and sequential RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Allow RUN_STARTED after RUN_FINISHED (new run), but not during an active run\n          if (runStarted && !runFinished) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run.`,\n                ),\n            );\n          }\n          // If we're here, it's either the first RUN_STARTED or a new run after RUN_FINISHED\n          if (runFinished) {\n            // This is a new run after the previous one finished, reset state\n            resetRunState();\n          }\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            const messageId = (event as any).messageId;\n\n            // Check if this message is already in progress\n            if (activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${messageId}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessages.set(messageId, true);\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${messageId}'. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${messageId}'. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove message from active set\n            activeMessages.delete(messageId);\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Check if this tool call is already in progress\n            if (activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call with ID '${toolCallId}' is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCalls.set(toolCallId, true);\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${toolCallId}'. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${toolCallId}'. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove tool call from active set\n            activeToolCalls.delete(toolCallId);\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            runStarted = true;\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            // Check that all messages are finished before run ends\n            if (activeMessages.size > 0) {\n              const unfinishedMessages = Array.from(activeMessages.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while text messages are still active: ${unfinishedMessages}`,\n                  ),\n              );\n            }\n\n            // Check that all tool calls are finished before run ends\n            if (activeToolCalls.size > 0) {\n              const unfinishedToolCalls = Array.from(activeToolCalls.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while tool calls are still active: ${unfinishedToolCalls}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n", "import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\nimport { EventType } from \"@ag-ui/core\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => {\n              if ((err as DOMException)?.name === \"AbortError\") {\n                eventSubject.next({\n                  type: EventType.RUN_ERROR,\n                  rawEvent: err,\n                });\n                eventSubject.complete();\n                return;\n              }\n              return eventSubject.error(err)\n            },\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n", "import { Observable, from, defer, throwError } from \"rxjs\";\nimport { mergeMap, switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        // Read the (small) error body once, then error the stream\n        return from(response.text()).pipe(\n          mergeMap((text) => {\n            let payload: unknown = text;\n            if (contentType.includes(\"application/json\")) {\n              try { payload = JSON.parse(text); } catch {/* keep raw text */}\n            }\n            const err: any = new Error(\n              `HTTP ${response.status}: ${typeof payload === \"string\" ? payload : JSON.stringify(payload)}`\n            );\n            err.status = response.status;\n            err.payload = payload;\n            return throwError(() => err);\n          })\n        );\n      }\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel().catch((error) => {\n            if ((error as DOMException)?.name === \"AbortError\") {\n              return;\n            }\n\n            throw error;\n          });\n        };\n      });\n    }),\n  );\n};\n", "import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * Follows the SSE spec by only processing 'data:' prefixed lines.\n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data: \")) {\n        // Extract data content (remove 'data: ' prefix)\n        dataLines.push(line.slice(6));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n", "import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n", "import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n  RunErrorEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n  LegacyRunError\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\nconst flattenMessageContentToText = (content: Message[\"content\"]) => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return undefined;\n  }\n\n  const textParts = content\n    .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\n    .map((part) => part.text)\n    .filter((text) => text.length > 0);\n\n  if (textParts.length === 0) {\n    return undefined;\n  }\n\n  return textParts.join(\"\\n\");\n};\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n                role: startEvent.role,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            // Find the tool call by ID instead of using the last one\n            const currentToolCall = currentToolCalls.find((tc) => tc.id === argsEvent.toolCallId);\n            if (!currentToolCall) {\n              console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${argsEvent.toolCallId}'`);\n              return [];\n            }\n\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            // Only do an update if state is not empty\n            if (Object.keys(currentState).length === 0) {\n              return [];\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            const errorEvent = event as RunErrorEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.RunError,\n                message: errorEvent.message,\n                code: errorEvent.code,\n              } as LegacyRunError,\n            ];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      const textContent = flattenMessageContentToText(message.content);\n      if (textContent) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: textContent,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n", "import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n  role: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\n\nexport const LegacyRunError = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.RunError),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n  LegacyRunError,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\nexport type LegacyRunError = z.infer<typeof LegacyRunError>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n", "import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { compareVersions } from \"compare-versions\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { takeUntil } from \"rxjs/operators\";\nimport { pipe, Observable, from, of, EMPTY, Subject } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\nimport { AGUIConnectNotImplementedError } from \"@ag-ui/core\";\nimport {\n  Middleware,\n  MiddlewareFunction,\n  FunctionMiddleware,\n  BackwardCompatibility_0_0_39,\n} from \"@/middleware\";\nimport packageJson from \"../../package.json\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n  public isRunning: boolean = false;\n  private middlewares: Middleware[] = [];\n  // Emits to immediately detach from the active run (stop processing its stream)\n  private activeRunDetach$?: Subject<void>;\n  private activeRunCompletionPromise?: Promise<void>;\n\n  get maxVersion() {\n    return packageJson.version;\n  }\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n\n    if (compareVersions(this.maxVersion, \"0.0.39\") <= 0) {\n      this.middlewares.unshift(new BackwardCompatibility_0_0_39());\n    }\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public use(...middlewares: (Middleware | MiddlewareFunction)[]): this {\n    const normalizedMiddlewares = middlewares.map((middleware) =>\n      typeof middleware === \"function\" ? new FunctionMiddleware(middleware) : middleware,\n    );\n    this.middlewares.push(...normalizedMiddlewares);\n    return this;\n  }\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => {\n          // Build middleware chain using reduceRight so middlewares can intercept runs.\n          if (this.middlewares.length === 0) {\n            return this.run(input);\n          }\n\n          const chainedAgent = this.middlewares.reduceRight(\n            (nextAgent: AbstractAgent, middleware) =>\n              ({\n                run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n              }) as AbstractAgent,\n            this, // Original agent is the final 'next'\n          );\n\n          return chainedAgent.run(input);\n        },\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          return this.onError(input, error, subscribers);\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null)));\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  protected connect(input: RunAgentInput): Observable<BaseEvent> {\n    throw new AGUIConnectNotImplementedError();\n  }\n  public async connectAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => this.connect(input),\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          if (!(error instanceof AGUIConnectNotImplementedError)) {\n            return this.onError(input, error, subscribers);\n          }\n          return EMPTY;\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null))); // wait for stream completion before toggling isRunning\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  public abortRun() {}\n\n  public async detachActiveRun(): Promise<void> {\n    if (!this.activeRunDetach$) {\n      return;\n    }\n    const completion = this.activeRunCompletionPromise ?? Promise.resolve();\n    this.activeRunDetach$.next();\n    this.activeRunDetach$?.complete();\n    await completion;\n  }\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    const clonedMessages = structuredClone_(this.messages) as Message[];\n    const messagesWithoutActivity = clonedMessages.filter((message) => message.role !== \"activity\");\n\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: messagesWithoutActivity,\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    cloned.agentId = this.agentId;\n    cloned.description = this.description;\n    cloned.threadId = this.threadId;\n    cloned.messages = structuredClone_(this.messages);\n    cloned.state = structuredClone_(this.state);\n    cloned.debug = this.debug;\n    cloned.isRunning = this.isRunning;\n    cloned.subscribers = [...this.subscribers];\n    cloned.middlewares = [...this.middlewares];\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    // Build middleware chain for legacy bridge\n    const runObservable = (() => {\n      if (this.middlewares.length === 0) {\n        return this.run(input);\n      }\n\n      const chainedAgent = this.middlewares.reduceRight(\n        (nextAgent: AbstractAgent, middleware) =>\n          ({\n            run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n          }) as AbstractAgent,\n        this,\n      );\n\n      return chainedAgent.run(input);\n    })();\n\n    return runObservable.pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n", "import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n          case EventType.ACTIVITY_SNAPSHOT:\n          case EventType.ACTIVITY_DELTA:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: messageChunkEvent.role || \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n        return [];\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        closePendingEvent();\n      }),\n    );\n  };\n", "import { AbstractAgent } from \"@/agent\";\nimport { RunAgentInput, BaseEvent, Message } from \"@ag-ui/core\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport { concatMap } from \"rxjs/operators\";\nimport { transformChunks } from \"@/chunks\";\nimport { defaultApplyEvents } from \"@/apply\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport type MiddlewareFunction = (\n  input: RunAgentInput,\n  next: AbstractAgent,\n) => Observable<BaseEvent>;\n\nexport interface EventWithState {\n  event: BaseEvent;\n  messages: Message[];\n  state: any;\n}\n\nexport abstract class Middleware {\n  abstract run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent>;\n\n  /**\n   * Runs the next agent in the chain with automatic chunk transformation.\n   */\n  protected runNext(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return next.run(input).pipe(\n      transformChunks(false), // Always transform chunks to full events\n    );\n  }\n\n  /**\n   * Runs the next agent and tracks state, providing current messages and state with each event.\n   * The messages and state represent the state AFTER the event has been applied.\n   */\n  protected runNextWithState(\n    input: RunAgentInput,\n    next: AbstractAgent,\n  ): Observable<EventWithState> {\n    let currentMessages = structuredClone_(input.messages || []);\n    let currentState = structuredClone_(input.state || {});\n\n    // Use a ReplaySubject to feed events one by one\n    const eventSubject = new ReplaySubject<BaseEvent>();\n\n    // Set up defaultApplyEvents to process events\n    const mutations$ = defaultApplyEvents(input, eventSubject, next, []);\n\n    // Subscribe to track state changes\n    mutations$.subscribe((mutation) => {\n      if (mutation.messages !== undefined) {\n        currentMessages = mutation.messages;\n      }\n      if (mutation.state !== undefined) {\n        currentState = mutation.state;\n      }\n    });\n\n    return this.runNext(input, next).pipe(\n      concatMap(async (event) => {\n        // Feed the event to defaultApplyEvents and wait for it to process\n        eventSubject.next(event);\n\n        // Give defaultApplyEvents a chance to process\n        await new Promise((resolve) => setTimeout(resolve, 0));\n\n        // Return event with current state\n        return {\n          event,\n          messages: structuredClone_(currentMessages),\n          state: structuredClone_(currentState),\n        };\n      }),\n    );\n  }\n}\n\n// Wrapper class to convert a function into a Middleware instance\nexport class FunctionMiddleware extends Middleware {\n  constructor(private fn: MiddlewareFunction) {\n    super();\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return this.fn(input, next);\n  }\n}\n", "import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport {\n  RunAgentInput,\n  BaseEvent,\n  EventType,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport { filter } from \"rxjs/operators\";\n\ntype FilterToolCallsConfig =\n  | { allowedToolCalls: string[]; disallowedToolCalls?: never }\n  | { disallowedToolCalls: string[]; allowedToolCalls?: never };\n\nexport class FilterToolCallsMiddleware extends Middleware {\n  private blockedToolCallIds = new Set<string>();\n  private readonly allowedTools?: Set<string>;\n  private readonly disallowedTools?: Set<string>;\n\n  constructor(config: FilterToolCallsConfig) {\n    super();\n\n    // Runtime validation (belt and suspenders approach)\n    if (config.allowedToolCalls && config.disallowedToolCalls) {\n      throw new Error(\"Cannot specify both allowedToolCalls and disallowedToolCalls\");\n    }\n\n    if (!config.allowedToolCalls && !config.disallowedToolCalls) {\n      throw new Error(\"Must specify either allowedToolCalls or disallowedToolCalls\");\n    }\n\n    if (config.allowedToolCalls) {\n      this.allowedTools = new Set(config.allowedToolCalls);\n    } else if (config.disallowedToolCalls) {\n      this.disallowedTools = new Set(config.disallowedToolCalls);\n    }\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    // Use runNext which already includes transformChunks\n    return this.runNext(input, next).pipe(\n      filter((event) => {\n        // Handle TOOL_CALL_START events\n        if (event.type === EventType.TOOL_CALL_START) {\n          const toolCallStartEvent = event as ToolCallStartEvent;\n          const shouldFilter = this.shouldFilterTool(toolCallStartEvent.toolCallName);\n\n          if (shouldFilter) {\n            // Track this tool call ID as blocked\n            this.blockedToolCallIds.add(toolCallStartEvent.toolCallId);\n            return false; // Filter out this event\n          }\n\n          return true; // Allow this event\n        }\n\n        // Handle TOOL_CALL_ARGS events\n        if (event.type === EventType.TOOL_CALL_ARGS) {\n          const toolCallArgsEvent = event as ToolCallArgsEvent;\n          return !this.blockedToolCallIds.has(toolCallArgsEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_END events\n        if (event.type === EventType.TOOL_CALL_END) {\n          const toolCallEndEvent = event as ToolCallEndEvent;\n          return !this.blockedToolCallIds.has(toolCallEndEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_RESULT events\n        if (event.type === EventType.TOOL_CALL_RESULT) {\n          const toolCallResultEvent = event as ToolCallResultEvent;\n          const isBlocked = this.blockedToolCallIds.has(toolCallResultEvent.toolCallId);\n\n          if (isBlocked) {\n            // Clean up the blocked ID after the last event\n            this.blockedToolCallIds.delete(toolCallResultEvent.toolCallId);\n            return false;\n          }\n\n          return true;\n        }\n\n        // Allow all other events through\n        return true;\n      }),\n    );\n  }\n\n  private shouldFilterTool(toolName: string): boolean {\n    if (this.allowedTools) {\n      // If using allowed list, filter out tools NOT in the list\n      return !this.allowedTools.has(toolName);\n    } else if (this.disallowedTools) {\n      // If using disallowed list, filter out tools IN the list\n      return this.disallowedTools.has(toolName);\n    }\n\n    return false;\n  }\n}\n", "import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport type { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport type { Observable } from \"rxjs\";\n\ntype InputMessage = RunAgentInput[\"messages\"][number];\n\nfunction sanitizeMessageContent(message: InputMessage): InputMessage {\n  const rawContent = (message as { content?: unknown }).content;\n\n  if (Array.isArray(rawContent)) {\n    const concatenatedContent = rawContent\n      .filter(\n        (part): part is { type: \"text\"; text: string } =>\n          typeof part === \"object\" &&\n          part !== null &&\n          \"type\" in part &&\n          (part as { type: unknown }).type === \"text\" &&\n          typeof (part as { text?: unknown }).text === \"string\",\n      )\n      .map((part) => part.text)\n      .join(\"\");\n\n    return {\n      ...message,\n      content: concatenatedContent,\n    } as InputMessage;\n  }\n\n  if (typeof rawContent === \"string\") {\n    return message;\n  }\n\n  return {\n    ...message,\n    content: \"\",\n  } as InputMessage;\n}\n\n/**\n * Middleware placeholder that maintains compatibility with AG-UI 0.0.39 flows.\n * Currently it simply forwards all events to the next middleware/agent.\n */\nexport class BackwardCompatibility_0_0_39 extends Middleware {\n  override run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    const { parentRunId: _parentRunId, ...rest } = input;\n    const sanitizedInput: RunAgentInput = {\n      ...rest,\n      messages: rest.messages.map(sanitizeMessageContent),\n    } as RunAgentInput;\n\n    return this.runNext(sanitizedInput, next);\n  }\n}\n", "{\n  \"name\": \"@ag-ui/client\",\n  \"author\": \"Markus Ecker <markus.ecker@gmail.com>\",\n  \"version\": \"0.0.42\",\n  \"private\": false,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"files\": [\n    \"dist/**\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"clean\": \"rm -rf dist .turbo node_modules\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\",\n    \"link:global\": \"pnpm link --global\",\n    \"unlink:global\": \"pnpm unlink --global\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/core\": \"workspace:*\",\n    \"@ag-ui/encoder\": \"workspace:*\",\n    \"@ag-ui/proto\": \"workspace:*\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"compare-versions\": \"^6.1.1\",\n    \"fast-json-patch\": \"^3.1.1\",\n    \"rxjs\": \"7.8.1\",\n    \"untruncate-json\": \"^0.0.1\",\n    \"uuid\": \"^11.1.0\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^20.11.19\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.2\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n", "import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public clone(): HttpAgent {\n    const cloned = super.clone() as HttpAgent;\n    cloned.url = this.url;\n    cloned.headers = structuredClone_(this.headers ?? {});\n\n    const newController = new AbortController();\n    const originalSignal = this.abortController.signal as AbortSignal & { reason?: unknown };\n    if (originalSignal.aborted) {\n      newController.abort(originalSignal.reason);\n    }\n    cloned.abortController = newController;\n\n    return cloned;\n  }\n}\n", "import {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n} from \"@ag-ui/core\";\n\n/**\n * Compacts streaming events by consolidating multiple deltas into single events.\n * For text messages: multiple content deltas become one concatenated delta.\n * For tool calls: multiple args deltas become one concatenated delta.\n * Events between related streaming events are reordered to keep streaming events together.\n *\n * @param events - Array of events to compact\n * @returns Compacted array of events\n */\nexport function compactEvents(events: BaseEvent[]): BaseEvent[] {\n  const compacted: BaseEvent[] = [];\n  const pendingTextMessages = new Map<\n    string,\n    {\n      start?: TextMessageStartEvent;\n      contents: TextMessageContentEvent[];\n      end?: TextMessageEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n  const pendingToolCalls = new Map<\n    string,\n    {\n      start?: ToolCallStartEvent;\n      args: ToolCallArgsEvent[];\n      end?: ToolCallEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n\n  for (const event of events) {\n    // Handle text message streaming events\n    if (event.type === EventType.TEXT_MESSAGE_START) {\n      const startEvent = event as TextMessageStartEvent;\n      const messageId = startEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TEXT_MESSAGE_CONTENT) {\n      const contentEvent = event as TextMessageContentEvent;\n      const messageId = contentEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.contents.push(contentEvent);\n    } else if (event.type === EventType.TEXT_MESSAGE_END) {\n      const endEvent = event as TextMessageEndEvent;\n      const messageId = endEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.end = endEvent;\n\n      // Flush this message's events\n      flushTextMessage(messageId, pending, compacted);\n      pendingTextMessages.delete(messageId);\n    } else if (event.type === EventType.TOOL_CALL_START) {\n      const startEvent = event as ToolCallStartEvent;\n      const toolCallId = startEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TOOL_CALL_ARGS) {\n      const argsEvent = event as ToolCallArgsEvent;\n      const toolCallId = argsEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.args.push(argsEvent);\n    } else if (event.type === EventType.TOOL_CALL_END) {\n      const endEvent = event as ToolCallEndEvent;\n      const toolCallId = endEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.end = endEvent;\n\n      // Flush this tool call's events\n      flushToolCall(toolCallId, pending, compacted);\n      pendingToolCalls.delete(toolCallId);\n    } else {\n      // For non-streaming events, check if we're in the middle of any streaming sequences\n      let addedToBuffer = false;\n\n      // Check text messages\n      for (const [messageId, pending] of pendingTextMessages) {\n        // If we have a start but no end yet, this event is \"in between\"\n        if (pending.start && !pending.end) {\n          pending.otherEvents.push(event);\n          addedToBuffer = true;\n          break;\n        }\n      }\n\n      // Check tool calls if not already buffered\n      if (!addedToBuffer) {\n        for (const [toolCallId, pending] of pendingToolCalls) {\n          // If we have a start but no end yet, this event is \"in between\"\n          if (pending.start && !pending.end) {\n            pending.otherEvents.push(event);\n            addedToBuffer = true;\n            break;\n          }\n        }\n      }\n\n      // If not in the middle of any streaming sequence, add directly to compacted\n      if (!addedToBuffer) {\n        compacted.push(event);\n      }\n    }\n  }\n\n  // Flush any remaining incomplete messages\n  for (const [messageId, pending] of pendingTextMessages) {\n    flushTextMessage(messageId, pending, compacted);\n  }\n\n  // Flush any remaining incomplete tool calls\n  for (const [toolCallId, pending] of pendingToolCalls) {\n    flushToolCall(toolCallId, pending, compacted);\n  }\n\n  return compacted;\n}\n\nfunction flushTextMessage(\n  messageId: string,\n  pending: {\n    start?: TextMessageStartEvent;\n    contents: TextMessageContentEvent[];\n    end?: TextMessageEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all content events into one\n  if (pending.contents.length > 0) {\n    const concatenatedDelta = pending.contents.map((c) => c.delta).join(\"\");\n\n    const compactedContent: TextMessageContentEvent = {\n      type: EventType.TEXT_MESSAGE_CONTENT,\n      messageId: messageId,\n      delta: concatenatedDelta,\n    };\n\n    compacted.push(compactedContent);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n\nfunction flushToolCall(\n  toolCallId: string,\n  pending: {\n    start?: ToolCallStartEvent;\n    args: ToolCallArgsEvent[];\n    end?: ToolCallEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all args events into one\n  if (pending.args.length > 0) {\n    const concatenatedArgs = pending.args.map((a) => a.delta).join(\"\");\n\n    const compactedArgs: ToolCallArgsEvent = {\n      type: EventType.TOOL_CALL_ARGS,\n      toolCallId: toolCallId,\n      delta: concatenatedArgs,\n    };\n\n    compacted.push(compactedArgs);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n", "export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"./utils\";\nexport * from \"./compact\";\nexport * from \"@ag-ui/core\";\nexport * from \"./chunks\";\nexport * from \"./middleware\";\n\nexport { Middleware, FilterToolCallsMiddleware } from \"./middleware\";\nexport type { MiddlewareFunction } from \"./middleware\";\n", "export const ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nexport const jsonDescription = (jsonSchema, def) => {\n    if (def.description) {\n        try {\n            return {\n                ...jsonSchema,\n                ...JSON.parse(def.description),\n            };\n        }\n        catch { }\n    }\n    return jsonSchema;\n};\nexport const defaultOptions = {\n    name: undefined,\n    $refStrategy: \"root\",\n    basePath: [\"#\"],\n    effectStrategy: \"input\",\n    pipeStrategy: \"all\",\n    dateStrategy: \"format:date-time\",\n    mapStrategy: \"entries\",\n    removeAdditionalStrategy: \"passthrough\",\n    allowedAdditionalProperties: true,\n    rejectedAdditionalProperties: false,\n    definitionPath: \"definitions\",\n    target: \"jsonSchema7\",\n    strictUnions: false,\n    definitions: {},\n    errorMessages: false,\n    markdownDescription: false,\n    patternStrategy: \"escape\",\n    applyRegexFlags: false,\n    emailStrategy: \"format:email\",\n    base64Strategy: \"contentEncoding:base64\",\n    nameStrategy: \"ref\",\n    openAiAnyTypeName: \"OpenAiAnyType\"\n};\nexport const getDefaultOptions = (options) => (typeof options === \"string\"\n    ? {\n        ...defaultOptions,\n        name: options,\n    }\n    : {\n        ...defaultOptions,\n        ...options,\n    });\n", "import { getDefaultOptions } from \"./Options.js\";\nexport const getRefs = (options) => {\n    const _options = getDefaultOptions(options);\n    const currentPath = _options.name !== undefined\n        ? [..._options.basePath, _options.definitionPath, _options.name]\n        : _options.basePath;\n    return {\n        ..._options,\n        flags: { hasReferencedOpenAiAnyType: false },\n        currentPath: currentPath,\n        propertyPath: undefined,\n        seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n            def._def,\n            {\n                def: def._def,\n                path: [..._options.basePath, _options.definitionPath, name],\n                // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.\n                jsonSchema: undefined,\n            },\n        ])),\n    };\n};\n", "export function addErrorMessage(res, key, errorMessage, refs) {\n    if (!refs?.errorMessages)\n        return;\n    if (errorMessage) {\n        res.errorMessage = {\n            ...res.errorMessage,\n            [key]: errorMessage,\n        };\n    }\n}\nexport function setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n    res[key] = value;\n    addErrorMessage(res, key, errorMessage, refs);\n}\n", "export const getRelativePath = (pathA, pathB) => {\n    let i = 0;\n    for (; i < pathA.length && i < pathB.length; i++) {\n        if (pathA[i] !== pathB[i])\n            break;\n    }\n    return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\n", "import { getRelativePath } from \"../getRelativePath.js\";\nexport function parseAnyDef(refs) {\n    if (refs.target !== \"openAi\") {\n        return {};\n    }\n    const anyDefinitionPath = [\n        ...refs.basePath,\n        refs.definitionPath,\n        refs.openAiAnyTypeName,\n    ];\n    refs.flags.hasReferencedOpenAiAnyType = true;\n    return {\n        $ref: refs.$refStrategy === \"relative\"\n            ? getRelativePath(anyDefinitionPath, refs.currentPath)\n            : anyDefinitionPath.join(\"/\"),\n    };\n}\n", "import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseArrayDef(def, refs) {\n    const res = {\n        type: \"array\",\n    };\n    if (def.type?._def &&\n        def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n        res.items = parseDef(def.type._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\"],\n        });\n    }\n    if (def.minLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n    }\n    if (def.maxLength) {\n        setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n    }\n    if (def.exactLength) {\n        setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n        setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n    }\n    return res;\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseBigintDef(def, refs) {\n    const res = {\n        type: \"integer\",\n        format: \"int64\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "export function parseBooleanDef() {\n    return {\n        type: \"boolean\",\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseBrandedDef(_def, refs) {\n    return parseDef(_def.type._def, refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseCatchDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nexport function parseDateDef(def, refs, overrideDateStrategy) {\n    const strategy = overrideDateStrategy ?? refs.dateStrategy;\n    if (Array.isArray(strategy)) {\n        return {\n            anyOf: strategy.map((item, i) => parseDateDef(def, refs, item)),\n        };\n    }\n    switch (strategy) {\n        case \"string\":\n        case \"format:date-time\":\n            return {\n                type: \"string\",\n                format: \"date-time\",\n            };\n        case \"format:date\":\n            return {\n                type: \"string\",\n                format: \"date\",\n            };\n        case \"integer\":\n            return integerDateParser(def, refs);\n    }\n}\nconst integerDateParser = (def, refs) => {\n    const res = {\n        type: \"integer\",\n        format: \"unix-time\",\n    };\n    if (refs.target === \"openApi3\") {\n        return res;\n    }\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"min\":\n                setResponseValueAndErrors(res, \"minimum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n            case \"max\":\n                setResponseValueAndErrors(res, \"maximum\", check.value, // This is in milliseconds\n                check.message, refs);\n                break;\n        }\n    }\n    return res;\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseDefaultDef(_def, refs) {\n    return {\n        ...parseDef(_def.innerType._def, refs),\n        default: _def.defaultValue(),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseEffectsDef(_def, refs) {\n    return refs.effectStrategy === \"input\"\n        ? parseDef(_def.schema._def, refs)\n        : parseAnyDef(refs);\n}\n", "export function parseEnumDef(def) {\n    return {\n        type: \"string\",\n        enum: Array.from(def.values),\n    };\n}\n", "import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n", "export function parseLiteralDef(def, refs) {\n    const parsedType = typeof def.value;\n    if (parsedType !== \"bigint\" &&\n        parsedType !== \"number\" &&\n        parsedType !== \"boolean\" &&\n        parsedType !== \"string\") {\n        return {\n            type: Array.isArray(def.value) ? \"array\" : \"object\",\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        return {\n            type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n            enum: [def.value],\n        };\n    }\n    return {\n        type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n        const: def.value,\n    };\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n", "import { ZodFirstPartyTypeKind, } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseRecordDef(def, refs) {\n    if (refs.target === \"openAi\") {\n        console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n    }\n    if (refs.target === \"openApi3\" &&\n        def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            type: \"object\",\n            required: def.keyType._def.values,\n            properties: def.keyType._def.values.reduce((acc, key) => ({\n                ...acc,\n                [key]: parseDef(def.valueType._def, {\n                    ...refs,\n                    currentPath: [...refs.currentPath, \"properties\", key],\n                }) ?? parseAnyDef(refs),\n            }), {}),\n            additionalProperties: refs.rejectedAdditionalProperties,\n        };\n    }\n    const schema = {\n        type: \"object\",\n        additionalProperties: parseDef(def.valueType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        }) ?? refs.allowedAdditionalProperties,\n    };\n    if (refs.target === \"openApi3\") {\n        return schema;\n    }\n    if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.checks?.length) {\n        const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n        return {\n            ...schema,\n            propertyNames: {\n                enum: def.keyType._def.values,\n            },\n        };\n    }\n    else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n        def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n        def.keyType._def.type._def.checks?.length) {\n        const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n        return {\n            ...schema,\n            propertyNames: keyType,\n        };\n    }\n    return schema;\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseRecordDef } from \"./record.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport function parseMapDef(def, refs) {\n    if (refs.mapStrategy === \"record\") {\n        return parseRecordDef(def, refs);\n    }\n    const keys = parseDef(def.keyType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"],\n    }) || parseAnyDef(refs);\n    const values = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"],\n    }) || parseAnyDef(refs);\n    return {\n        type: \"array\",\n        maxItems: 125,\n        items: {\n            type: \"array\",\n            items: [keys, values],\n            minItems: 2,\n            maxItems: 2,\n        },\n    };\n}\n", "export function parseNativeEnumDef(def) {\n    const object = def.values;\n    const actualKeys = Object.keys(def.values).filter((key) => {\n        return typeof object[object[key]] !== \"number\";\n    });\n    const actualValues = actualKeys.map((key) => object[key]);\n    const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n    return {\n        type: parsedTypes.length === 1\n            ? parsedTypes[0] === \"string\"\n                ? \"string\"\n                : \"number\"\n            : [\"string\", \"number\"],\n        enum: actualValues,\n    };\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseNeverDef(refs) {\n    return refs.target === \"openAi\"\n        ? undefined\n        : {\n            not: parseAnyDef({\n                ...refs,\n                currentPath: [...refs.currentPath, \"not\"],\n            }),\n        };\n}\n", "export function parseNullDef(refs) {\n    return refs.target === \"openApi3\"\n        ? {\n            enum: [\"null\"],\n            nullable: true,\n        }\n        : {\n            type: \"null\",\n        };\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n", "import { parseDef } from \"../parseDef.js\";\nimport { primitiveMappings } from \"./union.js\";\nexport function parseNullableDef(def, refs) {\n    if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) &&\n        (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n        if (refs.target === \"openApi3\") {\n            return {\n                type: primitiveMappings[def.innerType._def.typeName],\n                nullable: true,\n            };\n        }\n        return {\n            type: [\n                primitiveMappings[def.innerType._def.typeName],\n                \"null\",\n            ],\n        };\n    }\n    if (refs.target === \"openApi3\") {\n        const base = parseDef(def.innerType._def, {\n            ...refs,\n            currentPath: [...refs.currentPath],\n        });\n        if (base && \"$ref\" in base)\n            return { allOf: [base], nullable: true };\n        return base && { ...base, nullable: true };\n    }\n    const base = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n    });\n    return base && { anyOf: [base, { type: \"null\" }] };\n}\n", "import { addErrorMessage, setResponseValueAndErrors, } from \"../errorMessages.js\";\nexport function parseNumberDef(def, refs) {\n    const res = {\n        type: \"number\",\n    };\n    if (!def.checks)\n        return res;\n    for (const check of def.checks) {\n        switch (check.kind) {\n            case \"int\":\n                res.type = \"integer\";\n                addErrorMessage(res, \"type\", check.message, refs);\n                break;\n            case \"min\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMinimum = true;\n                    }\n                    setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n                }\n                break;\n            case \"max\":\n                if (refs.target === \"jsonSchema7\") {\n                    if (check.inclusive) {\n                        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                    }\n                    else {\n                        setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n                    }\n                }\n                else {\n                    if (!check.inclusive) {\n                        res.exclusiveMaximum = true;\n                    }\n                    setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n                }\n                break;\n            case \"multipleOf\":\n                setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n                break;\n        }\n    }\n    return res;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseObjectDef(def, refs) {\n    const forceOptionalIntoNullable = refs.target === \"openAi\";\n    const result = {\n        type: \"object\",\n        properties: {},\n    };\n    const required = [];\n    const shape = def.shape();\n    for (const propName in shape) {\n        let propDef = shape[propName];\n        if (propDef === undefined || propDef._def === undefined) {\n            continue;\n        }\n        let propOptional = safeIsOptional(propDef);\n        if (propOptional && forceOptionalIntoNullable) {\n            if (propDef._def.typeName === \"ZodOptional\") {\n                propDef = propDef._def.innerType;\n            }\n            if (!propDef.isNullable()) {\n                propDef = propDef.nullable();\n            }\n            propOptional = false;\n        }\n        const parsedDef = parseDef(propDef._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"properties\", propName],\n            propertyPath: [...refs.currentPath, \"properties\", propName],\n        });\n        if (parsedDef === undefined) {\n            continue;\n        }\n        result.properties[propName] = parsedDef;\n        if (!propOptional) {\n            required.push(propName);\n        }\n    }\n    if (required.length) {\n        result.required = required;\n    }\n    const additionalProperties = decideAdditionalProperties(def, refs);\n    if (additionalProperties !== undefined) {\n        result.additionalProperties = additionalProperties;\n    }\n    return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n    if (def.catchall._def.typeName !== \"ZodNever\") {\n        return parseDef(def.catchall._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"additionalProperties\"],\n        });\n    }\n    switch (def.unknownKeys) {\n        case \"passthrough\":\n            return refs.allowedAdditionalProperties;\n        case \"strict\":\n            return refs.rejectedAdditionalProperties;\n        case \"strip\":\n            return refs.removeAdditionalStrategy === \"strict\"\n                ? refs.allowedAdditionalProperties\n                : refs.rejectedAdditionalProperties;\n    }\n}\nfunction safeIsOptional(schema) {\n    try {\n        return schema.isOptional();\n    }\n    catch {\n        return true;\n    }\n}\n", "import { parseDef } from \"../parseDef.js\";\nimport { parseAnyDef } from \"./any.js\";\nexport const parseOptionalDef = (def, refs) => {\n    if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n        return parseDef(def.innerType._def, refs);\n    }\n    const innerSchema = parseDef(def.innerType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n    });\n    return innerSchema\n        ? {\n            anyOf: [\n                {\n                    not: parseAnyDef(refs),\n                },\n                innerSchema,\n            ],\n        }\n        : parseAnyDef(refs);\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport const parsePipelineDef = (def, refs) => {\n    if (refs.pipeStrategy === \"input\") {\n        return parseDef(def.in._def, refs);\n    }\n    else if (refs.pipeStrategy === \"output\") {\n        return parseDef(def.out._def, refs);\n    }\n    const a = parseDef(def.in._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    });\n    const b = parseDef(def.out._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n    });\n    return {\n        allOf: [a, b].filter((x) => x !== undefined),\n    };\n};\n", "import { parseDef } from \"../parseDef.js\";\nexport function parsePromiseDef(def, refs) {\n    return parseDef(def.type._def, refs);\n}\n", "import { setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nexport function parseSetDef(def, refs) {\n    const items = parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\"],\n    });\n    const schema = {\n        type: \"array\",\n        uniqueItems: true,\n        items,\n    };\n    if (def.minSize) {\n        setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n    }\n    if (def.maxSize) {\n        setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n    }\n    return schema;\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport function parseTupleDef(def, refs) {\n    if (def.rest) {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n            additionalItems: parseDef(def.rest._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"additionalItems\"],\n            }),\n        };\n    }\n    else {\n        return {\n            type: \"array\",\n            minItems: def.items.length,\n            maxItems: def.items.length,\n            items: def.items\n                .map((x, i) => parseDef(x._def, {\n                ...refs,\n                currentPath: [...refs.currentPath, \"items\", `${i}`],\n            }))\n                .reduce((acc, x) => (x === undefined ? acc : [...acc, x]), []),\n        };\n    }\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseUndefinedDef(refs) {\n    return {\n        not: parseAnyDef(refs),\n    };\n}\n", "import { parseAnyDef } from \"./any.js\";\nexport function parseUnknownDef(refs) {\n    return parseAnyDef(refs);\n}\n", "import { parseDef } from \"../parseDef.js\";\nexport const parseReadonlyDef = (def, refs) => {\n    return parseDef(def.innerType._def, refs);\n};\n", "import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nexport const selectParser = (def, typeName, refs) => {\n    switch (typeName) {\n        case ZodFirstPartyTypeKind.ZodString:\n            return parseStringDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNumber:\n            return parseNumberDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodObject:\n            return parseObjectDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBigInt:\n            return parseBigintDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBoolean:\n            return parseBooleanDef();\n        case ZodFirstPartyTypeKind.ZodDate:\n            return parseDateDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUndefined:\n            return parseUndefinedDef(refs);\n        case ZodFirstPartyTypeKind.ZodNull:\n            return parseNullDef(refs);\n        case ZodFirstPartyTypeKind.ZodArray:\n            return parseArrayDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodUnion:\n        case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n            return parseUnionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodIntersection:\n            return parseIntersectionDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodTuple:\n            return parseTupleDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodRecord:\n            return parseRecordDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLiteral:\n            return parseLiteralDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodEnum:\n            return parseEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNativeEnum:\n            return parseNativeEnumDef(def);\n        case ZodFirstPartyTypeKind.ZodNullable:\n            return parseNullableDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodOptional:\n            return parseOptionalDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodMap:\n            return parseMapDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodSet:\n            return parseSetDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodLazy:\n            return () => def.getter()._def;\n        case ZodFirstPartyTypeKind.ZodPromise:\n            return parsePromiseDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodNaN:\n        case ZodFirstPartyTypeKind.ZodNever:\n            return parseNeverDef(refs);\n        case ZodFirstPartyTypeKind.ZodEffects:\n            return parseEffectsDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodAny:\n            return parseAnyDef(refs);\n        case ZodFirstPartyTypeKind.ZodUnknown:\n            return parseUnknownDef(refs);\n        case ZodFirstPartyTypeKind.ZodDefault:\n            return parseDefaultDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodBranded:\n            return parseBrandedDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodReadonly:\n            return parseReadonlyDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodCatch:\n            return parseCatchDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodPipeline:\n            return parsePipelineDef(def, refs);\n        case ZodFirstPartyTypeKind.ZodFunction:\n        case ZodFirstPartyTypeKind.ZodVoid:\n        case ZodFirstPartyTypeKind.ZodSymbol:\n            return undefined;\n        default:\n            return ((_) => undefined)(typeName);\n    }\n};\n", "import { ignoreOverride } from \"./Options.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nexport function parseDef(def, refs, forceResolution = false) {\n    const seenItem = refs.seen.get(def);\n    if (refs.override) {\n        const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n        if (overrideResult !== ignoreOverride) {\n            return overrideResult;\n        }\n    }\n    if (seenItem && !forceResolution) {\n        const seenSchema = get$ref(seenItem, refs);\n        if (seenSchema !== undefined) {\n            return seenSchema;\n        }\n    }\n    const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n    refs.seen.set(def, newItem);\n    const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n    // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n    const jsonSchema = typeof jsonSchemaOrGetter === \"function\"\n        ? parseDef(jsonSchemaOrGetter(), refs)\n        : jsonSchemaOrGetter;\n    if (jsonSchema) {\n        addMeta(def, refs, jsonSchema);\n    }\n    if (refs.postProcess) {\n        const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n        newItem.jsonSchema = jsonSchema;\n        return postProcessResult;\n    }\n    newItem.jsonSchema = jsonSchema;\n    return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n    switch (refs.$refStrategy) {\n        case \"root\":\n            return { $ref: item.path.join(\"/\") };\n        case \"relative\":\n            return { $ref: getRelativePath(refs.currentPath, item.path) };\n        case \"none\":\n        case \"seen\": {\n            if (item.path.length < refs.currentPath.length &&\n                item.path.every((value, index) => refs.currentPath[index] === value)) {\n                console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n                return parseAnyDef(refs);\n            }\n            return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n        }\n    }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n    if (def.description) {\n        jsonSchema.description = def.description;\n        if (refs.markdownDescription) {\n            jsonSchema.markdownDescription = def.description;\n        }\n    }\n    return jsonSchema;\n};\n", "import { parseDef } from \"./parseDef.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nconst zodToJsonSchema = (schema, options) => {\n    const refs = getRefs(options);\n    let definitions = typeof options === \"object\" && options.definitions\n        ? Object.entries(options.definitions).reduce((acc, [name, schema]) => ({\n            ...acc,\n            [name]: parseDef(schema._def, {\n                ...refs,\n                currentPath: [...refs.basePath, refs.definitionPath, name],\n            }, true) ?? parseAnyDef(refs),\n        }), {})\n        : undefined;\n    const name = typeof options === \"string\"\n        ? options\n        : options?.nameStrategy === \"title\"\n            ? undefined\n            : options?.name;\n    const main = parseDef(schema._def, name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n        }, false) ?? parseAnyDef(refs);\n    const title = typeof options === \"object\" &&\n        options.name !== undefined &&\n        options.nameStrategy === \"title\"\n        ? options.name\n        : undefined;\n    if (title !== undefined) {\n        main.title = title;\n    }\n    if (refs.flags.hasReferencedOpenAiAnyType) {\n        if (!definitions) {\n            definitions = {};\n        }\n        if (!definitions[refs.openAiAnyTypeName]) {\n            definitions[refs.openAiAnyTypeName] = {\n                // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n                type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n                items: {\n                    $ref: refs.$refStrategy === \"relative\"\n                        ? \"1\"\n                        : [\n                            ...refs.basePath,\n                            refs.definitionPath,\n                            refs.openAiAnyTypeName,\n                        ].join(\"/\"),\n                },\n            };\n        }\n    }\n    const combined = name === undefined\n        ? definitions\n            ? {\n                ...main,\n                [refs.definitionPath]: definitions,\n            }\n            : main\n        : {\n            $ref: [\n                ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n                refs.definitionPath,\n                name,\n            ].join(\"/\"),\n            [refs.definitionPath]: {\n                ...definitions,\n                [name]: main,\n            },\n        };\n    if (refs.target === \"jsonSchema7\") {\n        combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n    }\n    else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n        combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n    }\n    if (refs.target === \"openAi\" &&\n        (\"anyOf\" in combined ||\n            \"oneOf\" in combined ||\n            \"allOf\" in combined ||\n            (\"type\" in combined && Array.isArray(combined.type)))) {\n        console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n    }\n    return combined;\n};\nexport { zodToJsonSchema };\n", "import { AbstractAgent, HttpAgent } from \"@ag-ui/client\";\nimport { logger, RuntimeInfo, AgentDescription } from \"@copilotkitnext/shared\";\nimport { ProxiedCopilotRuntimeAgent } from \"../agent\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreErrorCode, CopilotKitCoreRuntimeConnectionStatus, CopilotKitCoreFriendsAccess } from \"./core\";\nimport { CopilotRuntimeTransport } from \"../types\";\n\nexport interface CopilotKitCoreAddAgentParams {\n  id: string;\n  agent: AbstractAgent;\n}\n\n/**\n * Manages agent registration, lifecycle, and runtime connectivity for CopilotKitCore.\n * Handles both local development agents and remote runtime agents.\n */\nexport class AgentRegistry {\n  private _agents: Record<string, AbstractAgent> = {};\n  private localAgents: Record<string, AbstractAgent> = {};\n  private remoteAgents: Record<string, AbstractAgent> = {};\n\n  private _runtimeUrl?: string;\n  private _runtimeVersion?: string;\n  private _runtimeConnectionStatus: CopilotKitCoreRuntimeConnectionStatus =\n    CopilotKitCoreRuntimeConnectionStatus.Disconnected;\n  private _runtimeTransport: CopilotRuntimeTransport = \"rest\";\n  private _audioFileTranscriptionEnabled: boolean = false;\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all agents as a readonly record\n   */\n  get agents(): Readonly<Record<string, AbstractAgent>> {\n    return this._agents;\n  }\n\n  get runtimeUrl(): string | undefined {\n    return this._runtimeUrl;\n  }\n\n  get runtimeVersion(): string | undefined {\n    return this._runtimeVersion;\n  }\n\n  get runtimeConnectionStatus(): CopilotKitCoreRuntimeConnectionStatus {\n    return this._runtimeConnectionStatus;\n  }\n\n  get runtimeTransport(): CopilotRuntimeTransport {\n    return this._runtimeTransport;\n  }\n\n  get audioFileTranscriptionEnabled(): boolean {\n    return this._audioFileTranscriptionEnabled;\n  }\n\n  /**\n   * Initialize agents from configuration\n   */\n  initialize(agents: Record<string, AbstractAgent>): void {\n    this.localAgents = this.assignAgentIds(agents);\n    this.applyHeadersToAgents(this.localAgents);\n    this._agents = this.localAgents;\n  }\n\n  /**\n   * Set the runtime URL and update connection\n   */\n  setRuntimeUrl(runtimeUrl: string | undefined): void {\n    const normalizedRuntimeUrl = runtimeUrl ? runtimeUrl.replace(/\\/$/, \"\") : undefined;\n\n    if (this._runtimeUrl === normalizedRuntimeUrl) {\n      return;\n    }\n\n    this._runtimeUrl = normalizedRuntimeUrl;\n    void this.updateRuntimeConnection();\n  }\n\n  setRuntimeTransport(runtimeTransport: CopilotRuntimeTransport): void {\n    if (this._runtimeTransport === runtimeTransport) {\n      return;\n    }\n\n    this._runtimeTransport = runtimeTransport;\n    void this.updateRuntimeConnection();\n  }\n\n  /**\n   * Set all agents at once (for development use)\n   */\n  setAgents__unsafe_dev_only(agents: Record<string, AbstractAgent>): void {\n    // Validate all agents before making any changes\n    Object.entries(agents).forEach(([id, agent]) => {\n      if (agent) {\n        this.validateAndAssignAgentId(id, agent);\n      }\n    });\n    this.localAgents = agents;\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    this.applyHeadersToAgents(this._agents);\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Add a single agent (for development use)\n   */\n  addAgent__unsafe_dev_only({ id, agent }: CopilotKitCoreAddAgentParams): void {\n    this.validateAndAssignAgentId(id, agent);\n    this.localAgents[id] = agent;\n    this.applyHeadersToAgent(agent);\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Remove an agent by ID (for development use)\n   */\n  removeAgent__unsafe_dev_only(id: string): void {\n    delete this.localAgents[id];\n    this._agents = { ...this.localAgents, ...this.remoteAgents };\n    void this.notifyAgentsChanged();\n  }\n\n  /**\n   * Get an agent by ID\n   */\n  getAgent(id: string): AbstractAgent | undefined {\n    if (id in this._agents) {\n      return this._agents[id] as AbstractAgent;\n    }\n\n    // Silently return undefined if we're still loading runtime agents\n    if (\n      this.runtimeUrl !== undefined &&\n      (this.runtimeConnectionStatus === CopilotKitCoreRuntimeConnectionStatus.Disconnected ||\n        this.runtimeConnectionStatus === CopilotKitCoreRuntimeConnectionStatus.Connecting)\n    ) {\n      return undefined;\n    }\n\n    console.warn(`Agent ${id} not found`);\n    return undefined;\n  }\n\n  /**\n   * Apply current headers to an agent\n   */\n  applyHeadersToAgent(agent: AbstractAgent): void {\n    if (agent instanceof HttpAgent) {\n      agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n    }\n  }\n\n  /**\n   * Apply current headers to all agents\n   */\n  applyHeadersToAgents(agents: Record<string, AbstractAgent>): void {\n    Object.values(agents).forEach((agent) => {\n      this.applyHeadersToAgent(agent);\n    });\n  }\n\n  /**\n   * Apply current credentials to an agent\n   */\n  applyCredentialsToAgent(agent: AbstractAgent): void {\n    if (agent instanceof ProxiedCopilotRuntimeAgent) {\n      agent.credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n    }\n  }\n\n  /**\n   * Apply current credentials to all agents\n   */\n  applyCredentialsToAgents(agents: Record<string, AbstractAgent>): void {\n    Object.values(agents).forEach((agent) => {\n      this.applyCredentialsToAgent(agent);\n    });\n  }\n\n  /**\n   * Update runtime connection and fetch remote agents\n   */\n  private async updateRuntimeConnection(): Promise<void> {\n    // Skip fetching on the server (SSR)\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (!this.runtimeUrl) {\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Disconnected;\n      this._runtimeVersion = undefined;\n      this._audioFileTranscriptionEnabled = false;\n      this.remoteAgents = {};\n      this._agents = this.localAgents;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Disconnected);\n      await this.notifyAgentsChanged();\n      return;\n    }\n\n    this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Connecting;\n    await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Connecting);\n\n    try {\n      const runtimeInfoResponse = await this.fetchRuntimeInfo();\n      const {\n        version,\n        ...runtimeInfo\n      }: {\n        agents: Record<string, AgentDescription>;\n        version: string;\n      } = runtimeInfoResponse;\n\n      const credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n      const agents: Record<string, AbstractAgent> = Object.fromEntries(\n        Object.entries(runtimeInfo.agents).map(([id, { description }]) => {\n          const agent = new ProxiedCopilotRuntimeAgent({\n            runtimeUrl: this.runtimeUrl,\n            agentId: id, // Runtime agents always have their ID set correctly\n            description: description,\n            transport: this._runtimeTransport,\n            credentials,\n          });\n          this.applyHeadersToAgent(agent);\n          return [id, agent];\n        }),\n      );\n\n      this.remoteAgents = agents;\n      this._agents = { ...this.localAgents, ...this.remoteAgents };\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Connected;\n      this._runtimeVersion = version;\n      this._audioFileTranscriptionEnabled = runtimeInfoResponse.audioFileTranscriptionEnabled ?? false;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Connected);\n      await this.notifyAgentsChanged();\n    } catch (error) {\n      this._runtimeConnectionStatus = CopilotKitCoreRuntimeConnectionStatus.Error;\n      this._runtimeVersion = undefined;\n      this._audioFileTranscriptionEnabled = false;\n      this.remoteAgents = {};\n      this._agents = this.localAgents;\n\n      await this.notifyRuntimeStatusChanged(CopilotKitCoreRuntimeConnectionStatus.Error);\n      await this.notifyAgentsChanged();\n\n      const message = error instanceof Error ? error.message : JSON.stringify(error);\n      logger.warn(`Failed to load runtime info (${this.runtimeUrl}/info): ${message}`);\n      const runtimeError = error instanceof Error ? error : new Error(String(error));\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: runtimeError,\n        code: CopilotKitCoreErrorCode.RUNTIME_INFO_FETCH_FAILED,\n        context: {\n          runtimeUrl: this.runtimeUrl,\n        },\n      });\n    }\n  }\n\n  private async fetchRuntimeInfo(): Promise<RuntimeInfo> {\n    if (!this.runtimeUrl) {\n      throw new Error(\"Runtime URL is not set\");\n    }\n\n    const baseHeaders = (this.core as unknown as CopilotKitCoreFriendsAccess).headers;\n    const credentials = (this.core as unknown as CopilotKitCoreFriendsAccess).credentials;\n    const headers: Record<string, string> = {\n      ...baseHeaders,\n    };\n\n    if (this._runtimeTransport === \"single\") {\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"application/json\";\n      }\n      const response = await fetch(this.runtimeUrl, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({ method: \"info\" }),\n        ...(credentials ? { credentials } : {}),\n      });\n      if (\"ok\" in response && !(response as Response).ok) {\n        throw new Error(`Runtime info request failed with status ${response.status}`);\n      }\n      return (await response.json()) as RuntimeInfo;\n    }\n\n    const response = await fetch(`${this.runtimeUrl}/info`, {\n      headers,\n      ...(credentials ? { credentials } : {}),\n    });\n    if (\"ok\" in response && !(response as Response).ok) {\n      throw new Error(`Runtime info request failed with status ${response.status}`);\n    }\n    return (await response.json()) as RuntimeInfo;\n  }\n\n  /**\n   * Assign agent IDs to a record of agents\n   */\n  private assignAgentIds(agents: Record<string, AbstractAgent>): Record<string, AbstractAgent> {\n    Object.entries(agents).forEach(([id, agent]) => {\n      if (agent) {\n        this.validateAndAssignAgentId(id, agent);\n      }\n    });\n    return agents;\n  }\n\n  /**\n   * Validate and assign an agent ID\n   */\n  private validateAndAssignAgentId(registrationId: string, agent: AbstractAgent): void {\n    if (agent.agentId && agent.agentId !== registrationId) {\n      throw new Error(\n        `Agent registration mismatch: Agent with ID \"${agent.agentId}\" cannot be registered under key \"${registrationId}\". ` +\n          `The agent ID must match the registration key or be undefined.`,\n      );\n    }\n    if (!agent.agentId) {\n      agent.agentId = registrationId;\n    }\n  }\n\n  /**\n   * Notify subscribers of runtime status changes\n   */\n  private async notifyRuntimeStatusChanged(status: CopilotKitCoreRuntimeConnectionStatus): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onRuntimeConnectionStatusChanged?.({\n          copilotkit: this.core,\n          status,\n        }),\n      \"Error in CopilotKitCore subscriber (onRuntimeConnectionStatusChanged):\",\n    );\n  }\n\n  /**\n   * Notify subscribers of agent changes\n   */\n  private async notifyAgentsChanged(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onAgentsChanged?.({\n          copilotkit: this.core,\n          agents: this._agents,\n        }),\n      \"Subscriber onAgentsChanged error:\",\n    );\n  }\n}\n", "import {\n  BaseEvent,\n  HttpAgent,\n  HttpAgentConfig,\n  RunAgentInput,\n  runHttpRequest,\n  transformHttpEventStream,\n} from \"@ag-ui/client\";\nimport { Observable } from \"rxjs\";\nimport { CopilotRuntimeTransport } from \"./types\";\n\nexport interface ProxiedCopilotRuntimeAgentConfig extends Omit<HttpAgentConfig, \"url\"> {\n  runtimeUrl?: string;\n  transport?: CopilotRuntimeTransport;\n  credentials?: RequestCredentials;\n}\n\nexport class ProxiedCopilotRuntimeAgent extends HttpAgent {\n  runtimeUrl?: string;\n  credentials?: RequestCredentials;\n  private transport: CopilotRuntimeTransport;\n  private singleEndpointUrl?: string;\n\n  constructor(config: ProxiedCopilotRuntimeAgentConfig) {\n    const normalizedRuntimeUrl = config.runtimeUrl ? config.runtimeUrl.replace(/\\/$/, \"\") : undefined;\n    const transport = config.transport ?? \"rest\";\n    const runUrl =\n      transport === \"single\"\n        ? normalizedRuntimeUrl ?? config.runtimeUrl ?? \"\"\n        : `${normalizedRuntimeUrl ?? config.runtimeUrl}/agent/${encodeURIComponent(config.agentId ?? \"\")}/run`;\n\n    if (!runUrl) {\n      throw new Error(\"ProxiedCopilotRuntimeAgent requires a runtimeUrl when transport is set to 'single'.\");\n    }\n\n    super({\n      ...config,\n      url: runUrl,\n    });\n    this.runtimeUrl = normalizedRuntimeUrl ?? config.runtimeUrl;\n    this.credentials = config.credentials;\n    this.transport = transport;\n    if (this.transport === \"single\") {\n      this.singleEndpointUrl = this.runtimeUrl;\n    }\n  }\n\n  abortRun(): void {\n    if (!this.agentId || !this.threadId) {\n      return;\n    }\n\n    if (typeof fetch === \"undefined\") {\n      return;\n    }\n\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        return;\n      }\n\n      const headers = new Headers({ ...this.headers, \"Content-Type\": \"application/json\" });\n      void fetch(this.singleEndpointUrl, {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify({\n          method: \"agent/stop\",\n          params: {\n            agentId: this.agentId,\n            threadId: this.threadId,\n          },\n        }),\n        ...(this.credentials ? { credentials: this.credentials } : {}),\n      }).catch((error) => {\n        console.error(\"ProxiedCopilotRuntimeAgent: stop request failed\", error);\n      });\n      return;\n    }\n\n    if (!this.runtimeUrl) {\n      return;\n    }\n\n    const stopPath = `${this.runtimeUrl}/agent/${encodeURIComponent(this.agentId)}/stop/${encodeURIComponent(this.threadId)}`;\n    const origin = typeof window !== \"undefined\" && window.location ? window.location.origin : \"http://localhost\";\n    const base = new URL(this.runtimeUrl, origin);\n    const stopUrl = new URL(stopPath, base);\n\n    void fetch(stopUrl.toString(), {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...this.headers,\n      },\n      ...(this.credentials ? { credentials: this.credentials } : {}),\n    }).catch((error) => {\n      console.error(\"ProxiedCopilotRuntimeAgent: stop request failed\", error);\n    });\n  }\n\n  connect(input: RunAgentInput): Observable<BaseEvent> {\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        throw new Error(\"Single endpoint transport requires a runtimeUrl\");\n      }\n\n      const requestInit = this.createSingleRouteRequestInit(input, \"agent/connect\", {\n        agentId: this.agentId!,\n      });\n      const httpEvents = runHttpRequest(this.singleEndpointUrl, requestInit);\n      return transformHttpEventStream(httpEvents);\n    }\n\n    const httpEvents = runHttpRequest(`${this.runtimeUrl}/agent/${this.agentId}/connect`, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public run(input: RunAgentInput): Observable<BaseEvent> {\n    if (this.transport === \"single\") {\n      if (!this.singleEndpointUrl) {\n        throw new Error(\"Single endpoint transport requires a runtimeUrl\");\n      }\n\n      const requestInit = this.createSingleRouteRequestInit(input, \"agent/run\", {\n        agentId: this.agentId!,\n      });\n      const httpEvents = runHttpRequest(this.singleEndpointUrl, requestInit);\n      return transformHttpEventStream(httpEvents);\n    }\n\n    return super.run(input);\n  }\n\n  public override clone(): ProxiedCopilotRuntimeAgent {\n    const cloned = super.clone() as ProxiedCopilotRuntimeAgent;\n    cloned.runtimeUrl = this.runtimeUrl;\n    cloned.credentials = this.credentials;\n    cloned.transport = this.transport;\n    cloned.singleEndpointUrl = this.singleEndpointUrl;\n    return cloned;\n  }\n\n  private createSingleRouteRequestInit(input: RunAgentInput, method: string, params?: Record<string, string>): RequestInit {\n    if (!this.agentId) {\n      throw new Error(\"ProxiedCopilotRuntimeAgent requires agentId to make runtime requests\");\n    }\n\n    const baseInit = super.requestInit(input);\n    const headers = new Headers(baseInit.headers ?? {});\n    headers.set(\"Content-Type\", \"application/json\");\n    headers.set(\"Accept\", headers.get(\"Accept\") ?? \"text/event-stream\");\n\n    let originalBody: unknown = undefined;\n    if (typeof baseInit.body === \"string\") {\n      try {\n        originalBody = JSON.parse(baseInit.body);\n      } catch (error) {\n        console.warn(\"ProxiedCopilotRuntimeAgent: failed to parse request body for single route transport\", error);\n        originalBody = undefined;\n      }\n    }\n\n    const envelope: Record<string, unknown> = {\n      method,\n    };\n\n    if (params && Object.keys(params).length > 0) {\n      envelope.params = params;\n    }\n\n    if (originalBody !== undefined) {\n      envelope.body = originalBody;\n    }\n\n    return {\n      ...baseInit,\n      headers,\n      body: JSON.stringify(envelope),\n      ...(this.credentials ? { credentials: this.credentials } : {}),\n    };\n  }\n}\n", "import { Context } from \"@ag-ui/client\";\nimport { randomUUID } from \"@copilotkitnext/shared\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreFriendsAccess } from \"./core\";\n\n/**\n * Manages context storage and lifecycle for CopilotKitCore.\n * Context represents additional information available to agents during execution.\n */\nexport class ContextStore {\n  private _context: Record<string, Context> = {};\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all context entries as a readonly record\n   */\n  get context(): Readonly<Record<string, Context>> {\n    return this._context;\n  }\n\n  /**\n   * Add a new context entry\n   * @returns The ID of the created context entry\n   */\n  addContext({ description, value }: Context): string {\n    const id = randomUUID();\n    this._context[id] = { description, value };\n    void this.notifySubscribers();\n    return id;\n  }\n\n  /**\n   * Remove a context entry by ID\n   */\n  removeContext(id: string): void {\n    delete this._context[id];\n    void this.notifySubscribers();\n  }\n\n  /**\n   * Notify all subscribers of context changes\n   */\n  private async notifySubscribers(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onContextChanged?.({\n          copilotkit: this.core,\n          context: this._context,\n        }),\n      \"Subscriber onContextChanged error:\",\n    );\n  }\n}\n", "import { AbstractAgent, Message, Tool, Context } from \"@ag-ui/client\";\nimport { randomUUID, partialJSONParse } from \"@copilotkitnext/shared\";\nimport type { CopilotKitCore } from \"./core\";\nimport type { CopilotKitCoreGetSuggestionsResult } from \"./core\";\nimport { CopilotKitCoreFriendsAccess } from \"./core\";\nimport { DynamicSuggestionsConfig, StaticSuggestionsConfig, Suggestion, SuggestionsConfig } from \"../types\";\n\n/**\n * Manages suggestion generation, streaming, and lifecycle for CopilotKitCore.\n * Handles both dynamic (AI-generated) and static suggestions.\n */\nexport class SuggestionEngine {\n  private _suggestionsConfig: Record<string, SuggestionsConfig> = {};\n  private _suggestions: Record<string, Record<string, Suggestion[]>> = {};\n  private _runningSuggestions: Record<string, AbstractAgent[]> = {};\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Initialize with suggestion configs\n   */\n  initialize(suggestionsConfig: SuggestionsConfig[]): void {\n    for (const config of suggestionsConfig) {\n      this._suggestionsConfig[randomUUID()] = config;\n    }\n  }\n\n  /**\n   * Add a suggestion configuration\n   * @returns The ID of the created config\n   */\n  addSuggestionsConfig(config: SuggestionsConfig): string {\n    const id = randomUUID();\n    this._suggestionsConfig[id] = config;\n    void this.notifySuggestionsConfigChanged();\n    return id;\n  }\n\n  /**\n   * Remove a suggestion configuration by ID\n   */\n  removeSuggestionsConfig(id: string): void {\n    delete this._suggestionsConfig[id];\n    void this.notifySuggestionsConfigChanged();\n  }\n\n  /**\n   * Reload suggestions for a specific agent\n   * This triggers generation of new suggestions based on current configs\n   */\n  public reloadSuggestions(agentId: string): void {\n    this.clearSuggestions(agentId);\n\n    // Get agent to check message count for availability filtering\n    const agent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(agentId);\n    if (!agent) {\n      return;\n    }\n\n    const messageCount = agent.messages?.length ?? 0;\n    let hasAnySuggestions = false;\n\n    for (const config of Object.values(this._suggestionsConfig)) {\n      // Check if config applies to this agent\n      if (\n        config.consumerAgentId !== undefined &&\n        config.consumerAgentId !== \"*\" &&\n        config.consumerAgentId !== agentId\n      ) {\n        continue;\n      }\n\n      // Check availability based on message count\n      if (!this.shouldShowSuggestions(config, messageCount)) {\n        continue;\n      }\n\n      const suggestionId = randomUUID();\n\n      if (isDynamicSuggestionsConfig(config)) {\n        if (!hasAnySuggestions) {\n          hasAnySuggestions = true;\n          void this.notifySuggestionsStartedLoading(agentId);\n        }\n        void this.generateSuggestions(suggestionId, config, agentId);\n      } else if (isStaticSuggestionsConfig(config)) {\n        this.addStaticSuggestions(suggestionId, config, agentId);\n      }\n    }\n  }\n\n  /**\n   * Clear all suggestions for a specific agent\n   */\n  public clearSuggestions(agentId: string): void {\n    const runningAgents = this._runningSuggestions[agentId];\n    if (runningAgents) {\n      for (const agent of runningAgents) {\n        agent.abortRun();\n      }\n      delete this._runningSuggestions[agentId];\n    }\n    this._suggestions[agentId] = {};\n\n    void this.notifySuggestionsChanged(agentId, []);\n  }\n\n  /**\n   * Get current suggestions for an agent\n   */\n  public getSuggestions(agentId: string): CopilotKitCoreGetSuggestionsResult {\n    const suggestions = Object.values(this._suggestions[agentId] ?? {}).flat();\n    const isLoading = (this._runningSuggestions[agentId]?.length ?? 0) > 0;\n    return { suggestions, isLoading };\n  }\n\n  /**\n   * Generate suggestions using a provider agent\n   */\n  private async generateSuggestions(\n    suggestionId: string,\n    config: DynamicSuggestionsConfig,\n    consumerAgentId: string,\n  ): Promise<void> {\n    let agent: AbstractAgent | undefined = undefined;\n    try {\n      const suggestionsProviderAgent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(\n        config.providerAgentId ?? \"default\",\n      );\n      if (!suggestionsProviderAgent) {\n        throw new Error(`Suggestions provider agent not found: ${config.providerAgentId}`);\n      }\n      const suggestionsConsumerAgent = (this.core as unknown as CopilotKitCoreFriendsAccess).getAgent(consumerAgentId);\n      if (!suggestionsConsumerAgent) {\n        throw new Error(`Suggestions consumer agent not found: ${consumerAgentId}`);\n      }\n\n      const clonedAgent: AbstractAgent = suggestionsProviderAgent.clone();\n      agent = clonedAgent;\n      //agent.agentId = suggestionId;\n      agent.threadId = suggestionId;\n      agent.messages = JSON.parse(JSON.stringify(suggestionsConsumerAgent.messages));\n      agent.state = JSON.parse(JSON.stringify(suggestionsConsumerAgent.state));\n\n      // Initialize suggestion storage for this agent/suggestion combo\n      this._suggestions[consumerAgentId] = {\n        ...(this._suggestions[consumerAgentId] ?? {}),\n        [suggestionId]: [],\n      };\n      this._runningSuggestions[consumerAgentId] = [...(this._runningSuggestions[consumerAgentId] ?? []), agent];\n\n      agent.addMessage({\n        id: suggestionId,\n        role: \"user\",\n        content: [\n          `Suggest what the user could say next. Provide clear, highly relevant suggestions by calling the \\`copilotkitSuggest\\` tool.`,\n          `Provide at least ${config.minSuggestions ?? 1} and at most ${config.maxSuggestions ?? 3} suggestions.`,\n          `The user has the following tools available: ${JSON.stringify((this.core as unknown as CopilotKitCoreFriendsAccess).buildFrontendTools(consumerAgentId))}.`,\n          ` ${config.instructions}`,\n        ].join(\"\\n\"),\n      });\n\n      await agent.runAgent(\n        {\n          context: Object.values((this.core as unknown as CopilotKitCoreFriendsAccess).context),\n          forwardedProps: {\n            ...(this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n            toolChoice: { type: \"function\", function: { name: \"copilotkitSuggest\" } },\n          },\n          tools: [SUGGEST_TOOL],\n        },\n        {\n          onMessagesChanged: ({ messages }: { messages: Message[] }) => {\n            this.extractSuggestions(messages, suggestionId, consumerAgentId, true);\n          },\n        },\n      );\n    } catch (error) {\n      console.warn(\"Error generating suggestions:\", error);\n    } finally {\n      // Finalize suggestions by marking them as no longer loading\n      this.finalizeSuggestions(suggestionId, consumerAgentId);\n\n      // Remove this agent from running suggestions\n      const runningAgents = this._runningSuggestions[consumerAgentId];\n      if (agent && runningAgents) {\n        const filteredAgents = runningAgents.filter((a) => a !== agent);\n        this._runningSuggestions[consumerAgentId] = filteredAgents;\n\n        // If no more suggestions are running, emit loading end event\n        if (filteredAgents.length === 0) {\n          delete this._runningSuggestions[consumerAgentId];\n          await this.notifySuggestionsFinishedLoading(consumerAgentId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Finalize suggestions by marking them as no longer loading\n   */\n  private finalizeSuggestions(suggestionId: string, consumerAgentId: string): void {\n    const agentSuggestions = this._suggestions[consumerAgentId];\n    const currentSuggestions = agentSuggestions?.[suggestionId];\n\n    if (agentSuggestions && currentSuggestions && currentSuggestions.length > 0) {\n      // Filter out empty suggestions and mark remaining as no longer loading\n      const finalizedSuggestions = currentSuggestions\n        .filter((suggestion) => suggestion.title !== \"\" || suggestion.message !== \"\")\n        .map((suggestion) => ({\n          ...suggestion,\n          isLoading: false,\n        }));\n\n      if (finalizedSuggestions.length > 0) {\n        agentSuggestions[suggestionId] = finalizedSuggestions;\n      } else {\n        delete agentSuggestions[suggestionId];\n      }\n\n      // Get all aggregated suggestions for this agent\n      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"finalized\");\n    }\n  }\n\n  /**\n   * Extract suggestions from messages (called during streaming)\n   */\n  extractSuggestions(messages: Message[], suggestionId: string, consumerAgentId: string, isRunning: boolean): void {\n    const idx = messages.findIndex((message) => message.id === suggestionId);\n    if (idx == -1) {\n      return;\n    }\n\n    const suggestions: Suggestion[] = [];\n    const newMessages = messages.slice(idx + 1);\n\n    for (const message of newMessages) {\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          if (toolCall.function.name === \"copilotkitSuggest\") {\n            // Join all argument chunks into a single string for parsing\n            // arguments can be either a string or an array of strings\n            const fullArgs = Array.isArray(toolCall.function.arguments)\n              ? toolCall.function.arguments.join(\"\")\n              : toolCall.function.arguments;\n            const parsed = partialJSONParse(fullArgs);\n            if (parsed && typeof parsed === \"object\" && \"suggestions\" in parsed) {\n              const parsedSuggestions = (parsed as any).suggestions;\n              if (Array.isArray(parsedSuggestions)) {\n                for (const item of parsedSuggestions) {\n                  if (item && typeof item === \"object\" && \"title\" in item) {\n                    suggestions.push({\n                      title: item.title ?? \"\",\n                      message: item.message ?? \"\",\n                      isLoading: false, // Will be set correctly below\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Set isLoading for the last suggestion if still running\n    if (isRunning && suggestions.length > 0) {\n      suggestions[suggestions.length - 1]!.isLoading = true;\n    }\n\n    const agentSuggestions = this._suggestions[consumerAgentId];\n    if (agentSuggestions) {\n      agentSuggestions[suggestionId] = suggestions;\n\n      // Get all aggregated suggestions for this agent\n      const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n      void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"suggestions changed\");\n    }\n  }\n\n  /**\n   * Notify subscribers of suggestions config changes\n   */\n  private async notifySuggestionsConfigChanged(): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsConfigChanged?.({\n          copilotkit: this.core,\n          suggestionsConfig: this._suggestionsConfig,\n        }),\n      \"Subscriber onSuggestionsConfigChanged error:\",\n    );\n  }\n\n  /**\n   * Notify subscribers of suggestions changes\n   */\n  private async notifySuggestionsChanged(\n    agentId: string,\n    suggestions: Suggestion[],\n    context: string = \"\",\n  ): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsChanged?.({\n          copilotkit: this.core,\n          agentId,\n          suggestions,\n        }),\n      `Subscriber onSuggestionsChanged error: ${context}`,\n    );\n  }\n\n  /**\n   * Notify subscribers that suggestions started loading\n   */\n  private async notifySuggestionsStartedLoading(agentId: string): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsStartedLoading?.({\n          copilotkit: this.core,\n          agentId,\n        }),\n      \"Subscriber onSuggestionsStartedLoading error:\",\n    );\n  }\n\n  /**\n   * Notify subscribers that suggestions finished loading\n   */\n  private async notifySuggestionsFinishedLoading(agentId: string): Promise<void> {\n    await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n      (subscriber) =>\n        subscriber.onSuggestionsFinishedLoading?.({\n          copilotkit: this.core,\n          agentId,\n        }),\n      \"Subscriber onSuggestionsFinishedLoading error:\",\n    );\n  }\n\n  /**\n   * Check if suggestions should be shown based on availability and message count\n   */\n  private shouldShowSuggestions(config: SuggestionsConfig, messageCount: number): boolean {\n    const availability = config.available;\n\n    // Default behavior if no availability specified\n    if (!availability) {\n      if (isDynamicSuggestionsConfig(config)) {\n        return messageCount > 0; // Default: after-first-message\n      } else {\n        return messageCount === 0; // Default: before-first-message\n      }\n    }\n\n    switch (availability) {\n      case \"disabled\":\n        return false;\n      case \"before-first-message\":\n        return messageCount === 0;\n      case \"after-first-message\":\n        return messageCount > 0;\n      case \"always\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Add static suggestions directly without AI generation\n   */\n  private addStaticSuggestions(suggestionId: string, config: StaticSuggestionsConfig, consumerAgentId: string): void {\n    // Mark all as not loading since they're static\n    const suggestions = config.suggestions.map((s) => ({\n      ...s,\n      isLoading: false,\n    }));\n\n    // Store suggestions\n    this._suggestions[consumerAgentId] = {\n      ...(this._suggestions[consumerAgentId] ?? {}),\n      [suggestionId]: suggestions,\n    };\n\n    // Notify subscribers\n    const allSuggestions = Object.values(this._suggestions[consumerAgentId] ?? {}).flat();\n\n    void this.notifySuggestionsChanged(consumerAgentId, allSuggestions, \"static suggestions added\");\n  }\n}\n\n/**\n * Type guard for dynamic suggestions config\n */\nfunction isDynamicSuggestionsConfig(config: SuggestionsConfig): config is DynamicSuggestionsConfig {\n  return \"instructions\" in config;\n}\n\n/**\n * Type guard for static suggestions config\n */\nfunction isStaticSuggestionsConfig(config: SuggestionsConfig): config is StaticSuggestionsConfig {\n  return \"suggestions\" in config;\n}\n\n/**\n * The tool definition for AI-generated suggestions\n */\nconst SUGGEST_TOOL: Tool = {\n  name: \"copilotkitSuggest\",\n  description: \"Suggest what the user could say next\",\n  parameters: {\n    type: \"object\",\n    properties: {\n      suggestions: {\n        type: \"array\",\n        description: \"List of suggestions shown to the user as buttons.\",\n        items: {\n          type: \"object\",\n          properties: {\n            title: {\n              type: \"string\",\n              description: \"The title of the suggestion. This is shown as a button and should be short.\",\n            },\n            message: {\n              type: \"string\",\n              description:\n                \"The message to send when the suggestion is clicked. This should be a clear, complete sentence \" +\n                \"and will be sent as an instruction to the AI.\",\n            },\n          },\n          required: [\"title\", \"message\"],\n        },\n      },\n    },\n    required: [\"suggestions\"],\n  },\n};\n", "import { AbstractAgent, AgentSubscriber, HttpAgent, Message, RunAgentResult, Tool } from \"@ag-ui/client\";\nimport { randomUUID, logger } from \"@copilotkitnext/shared\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport type { CopilotKitCore } from \"./core\";\nimport { CopilotKitCoreErrorCode, CopilotKitCoreFriendsAccess } from \"./core\";\nimport { FrontendTool } from \"../types\";\n\nexport interface CopilotKitCoreRunAgentParams {\n  agent: AbstractAgent;\n}\n\nexport interface CopilotKitCoreConnectAgentParams {\n  agent: AbstractAgent;\n}\n\nexport interface CopilotKitCoreGetToolParams {\n  toolName: string;\n  agentId?: string;\n}\n\n/**\n * Handles agent execution, tool calling, and agent connectivity for CopilotKitCore.\n * Manages the complete lifecycle of agent runs including tool execution and follow-ups.\n */\nexport class RunHandler {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private _tools: FrontendTool<any>[] = [];\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Get all tools as a readonly array\n   */\n  get tools(): Readonly<FrontendTool<any>[]> {\n    return this._tools;\n  }\n\n  /**\n   * Initialize with tools\n   */\n  initialize(tools: FrontendTool<any>[]): void {\n    this._tools = tools;\n  }\n\n  /**\n   * Add a tool to the registry\n   */\n  addTool<T extends Record<string, unknown> = Record<string, unknown>>(tool: FrontendTool<T>): void {\n    // Check if a tool with the same name and agentId already exists\n    const existingToolIndex = this._tools.findIndex((t) => t.name === tool.name && t.agentId === tool.agentId);\n\n    if (existingToolIndex !== -1) {\n      logger.warn(`Tool already exists: '${tool.name}' for agent '${tool.agentId || \"global\"}', skipping.`);\n      return;\n    }\n\n    this._tools.push(tool);\n  }\n\n  /**\n   * Remove a tool by name and optionally by agentId\n   */\n  removeTool(id: string, agentId?: string): void {\n    this._tools = this._tools.filter((tool) => {\n      // Remove tool if both name and agentId match\n      if (agentId !== undefined) {\n        return !(tool.name === id && tool.agentId === agentId);\n      }\n      // If no agentId specified, only remove global tools with matching name\n      return !(tool.name === id && !tool.agentId);\n    });\n  }\n\n  /**\n   * Get a tool by name and optionally by agentId.\n   * If agentId is provided, it will first look for an agent-specific tool,\n   * then fall back to a global tool with the same name.\n   */\n  getTool(params: CopilotKitCoreGetToolParams): FrontendTool<any> | undefined {\n    const { toolName, agentId } = params;\n\n    // If agentId is provided, first look for agent-specific tool\n    if (agentId) {\n      const agentTool = this._tools.find((tool) => tool.name === toolName && tool.agentId === agentId);\n      if (agentTool) {\n        return agentTool;\n      }\n    }\n\n    // Fall back to global tool (no agentId)\n    return this._tools.find((tool) => tool.name === toolName && !tool.agentId);\n  }\n\n  /**\n   * Set all tools at once. Replaces existing tools.\n   */\n  setTools(tools: FrontendTool<any>[]): void {\n    this._tools = [...tools];\n  }\n\n  /**\n   * Connect an agent (establish initial connection)\n   */\n  async connectAgent({ agent }: CopilotKitCoreConnectAgentParams): Promise<RunAgentResult> {\n    try {\n      // Detach any active run before connecting to avoid previous runs interfering\n      await agent.detachActiveRun();\n      agent.setMessages([]);\n      agent.setState({});\n\n      if (agent instanceof HttpAgent) {\n        agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n      }\n\n      const runAgentResult = await agent.connectAgent(\n        {\n          forwardedProps: (this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n          tools: this.buildFrontendTools(agent.agentId),\n        },\n        this.createAgentErrorSubscriber(agent),\n      );\n\n      return this.processAgentResult({ runAgentResult, agent });\n    } catch (error) {\n      const connectError = error instanceof Error ? error : new Error(String(error));\n      const context: Record<string, any> = {};\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: connectError,\n        code: CopilotKitCoreErrorCode.AGENT_CONNECT_FAILED,\n        context,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Run an agent\n   */\n  async runAgent({ agent }: CopilotKitCoreRunAgentParams): Promise<RunAgentResult> {\n    // Agent ID is guaranteed to be set by validateAndAssignAgentId\n    if (agent.agentId) {\n      void (this.core as unknown as CopilotKitCoreFriendsAccess).suggestionEngine.clearSuggestions(agent.agentId);\n    }\n\n    if (agent instanceof HttpAgent) {\n      agent.headers = { ...(this.core as unknown as CopilotKitCoreFriendsAccess).headers };\n    }\n\n    try {\n      const runAgentResult = await agent.runAgent(\n        {\n          forwardedProps: (this.core as unknown as CopilotKitCoreFriendsAccess).properties,\n          tools: this.buildFrontendTools(agent.agentId),\n          context: Object.values((this.core as unknown as CopilotKitCoreFriendsAccess).context),\n        },\n        this.createAgentErrorSubscriber(agent),\n      );\n      return this.processAgentResult({ runAgentResult, agent });\n    } catch (error) {\n      const runError = error instanceof Error ? error : new Error(String(error));\n      const context: Record<string, any> = {};\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error: runError,\n        code: CopilotKitCoreErrorCode.AGENT_RUN_FAILED,\n        context,\n      });\n      throw error;\n    }\n  }\n\n  /**\n   * Process agent result and execute tools\n   */\n  private async processAgentResult({\n    runAgentResult,\n    agent,\n  }: {\n    runAgentResult: RunAgentResult;\n    agent: AbstractAgent;\n  }): Promise<RunAgentResult> {\n    const { newMessages } = runAgentResult;\n    // Agent ID is guaranteed to be set by validateAndAssignAgentId\n    const agentId = agent.agentId!;\n\n    let needsFollowUp = false;\n\n    for (const message of newMessages) {\n      if (message.role === \"assistant\") {\n        for (const toolCall of message.toolCalls || []) {\n          if (newMessages.findIndex((m) => m.role === \"tool\" && m.toolCallId === toolCall.id) === -1) {\n            const tool = this.getTool({\n              toolName: toolCall.function.name,\n              agentId: agent.agentId,\n            });\n            if (tool) {\n              const followUp = await this.executeSpecificTool(tool, toolCall, message, agent, agentId);\n              if (followUp) {\n                needsFollowUp = true;\n              }\n            } else {\n              // Wildcard fallback for undefined tools\n              const wildcardTool = this.getTool({ toolName: \"*\", agentId: agent.agentId });\n              if (wildcardTool) {\n                const followUp = await this.executeWildcardTool(wildcardTool, toolCall, message, agent, agentId);\n                if (followUp) {\n                  needsFollowUp = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (needsFollowUp) {\n      return await this.runAgent({ agent });\n    }\n\n    void (this.core as unknown as CopilotKitCoreFriendsAccess).suggestionEngine.reloadSuggestions(agentId);\n\n    return runAgentResult;\n  }\n\n  /**\n   * Execute a specific tool\n   */\n  private async executeSpecificTool(\n    tool: FrontendTool<any>,\n    toolCall: any,\n    message: Message,\n    agent: AbstractAgent,\n    agentId: string,\n  ): Promise<boolean> {\n    // Check if tool is constrained to a specific agent\n    if (tool?.agentId && tool.agentId !== agent.agentId) {\n      // Tool is not available for this agent, skip it\n      return false;\n    }\n\n    let toolCallResult = \"\";\n    let errorMessage: string | undefined;\n    let isArgumentError = false;\n\n    if (tool?.handler) {\n      let parsedArgs: unknown;\n      try {\n        parsedArgs = JSON.parse(toolCall.function.arguments);\n      } catch (error) {\n        const parseError = error instanceof Error ? error : new Error(String(error));\n        errorMessage = parseError.message;\n        isArgumentError = true;\n        await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n          error: parseError,\n          code: CopilotKitCoreErrorCode.TOOL_ARGUMENT_PARSE_FAILED,\n          context: {\n            agentId: agentId,\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            rawArguments: toolCall.function.arguments,\n            toolType: \"specific\",\n            messageId: message.id,\n          },\n        });\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionStart?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            args: parsedArgs,\n          }),\n        \"Subscriber onToolExecutionStart error:\",\n      );\n\n      if (!errorMessage) {\n        try {\n          const result = await tool.handler(parsedArgs as any, toolCall);\n          if (result === undefined || result === null) {\n            toolCallResult = \"\";\n          } else if (typeof result === \"string\") {\n            toolCallResult = result;\n          } else {\n            toolCallResult = JSON.stringify(result);\n          }\n        } catch (error) {\n          const handlerError = error instanceof Error ? error : new Error(String(error));\n          errorMessage = handlerError.message;\n          await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n            error: handlerError,\n            code: CopilotKitCoreErrorCode.TOOL_HANDLER_FAILED,\n            context: {\n              agentId: agentId,\n              toolCallId: toolCall.id,\n              toolName: toolCall.function.name,\n              parsedArgs,\n              toolType: \"specific\",\n              messageId: message.id,\n            },\n          });\n        }\n      }\n\n      if (errorMessage) {\n        toolCallResult = `Error: ${errorMessage}`;\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionEnd?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            result: errorMessage ? \"\" : toolCallResult,\n            error: errorMessage,\n          }),\n        \"Subscriber onToolExecutionEnd error:\",\n      );\n\n      if (isArgumentError) {\n        throw new Error(errorMessage ?? \"Tool execution failed\");\n      }\n    }\n\n    if (!errorMessage || !isArgumentError) {\n      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);\n      const toolMessage = {\n        id: randomUUID(),\n        role: \"tool\" as const,\n        toolCallId: toolCall.id,\n        content: toolCallResult,\n      };\n      agent.messages.splice(messageIndex + 1, 0, toolMessage);\n\n      if (!errorMessage && tool?.followUp !== false) {\n        return true; // Needs follow-up\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute a wildcard tool\n   */\n  private async executeWildcardTool(\n    wildcardTool: FrontendTool<any>,\n    toolCall: any,\n    message: Message,\n    agent: AbstractAgent,\n    agentId: string,\n  ): Promise<boolean> {\n    // Check if wildcard tool is constrained to a specific agent\n    if (wildcardTool?.agentId && wildcardTool.agentId !== agent.agentId) {\n      // Wildcard tool is not available for this agent, skip it\n      return false;\n    }\n\n    let toolCallResult = \"\";\n    let errorMessage: string | undefined;\n    let isArgumentError = false;\n\n    if (wildcardTool?.handler) {\n      let parsedArgs: unknown;\n      try {\n        parsedArgs = JSON.parse(toolCall.function.arguments);\n      } catch (error) {\n        const parseError = error instanceof Error ? error : new Error(String(error));\n        errorMessage = parseError.message;\n        isArgumentError = true;\n        await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n          error: parseError,\n          code: CopilotKitCoreErrorCode.TOOL_ARGUMENT_PARSE_FAILED,\n          context: {\n            agentId: agentId,\n            toolCallId: toolCall.id,\n            toolName: toolCall.function.name,\n            rawArguments: toolCall.function.arguments,\n            toolType: \"wildcard\",\n            messageId: message.id,\n          },\n        });\n      }\n\n      const wildcardArgs = {\n        toolName: toolCall.function.name,\n        args: parsedArgs,\n      };\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionStart?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            args: wildcardArgs,\n          }),\n        \"Subscriber onToolExecutionStart error:\",\n      );\n\n      if (!errorMessage) {\n        try {\n          const result = await wildcardTool.handler(wildcardArgs as any, toolCall);\n          if (result === undefined || result === null) {\n            toolCallResult = \"\";\n          } else if (typeof result === \"string\") {\n            toolCallResult = result;\n          } else {\n            toolCallResult = JSON.stringify(result);\n          }\n        } catch (error) {\n          const handlerError = error instanceof Error ? error : new Error(String(error));\n          errorMessage = handlerError.message;\n          await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n            error: handlerError,\n            code: CopilotKitCoreErrorCode.TOOL_HANDLER_FAILED,\n            context: {\n              agentId: agentId,\n              toolCallId: toolCall.id,\n              toolName: toolCall.function.name,\n              parsedArgs: wildcardArgs,\n              toolType: \"wildcard\",\n              messageId: message.id,\n            },\n          });\n        }\n      }\n\n      if (errorMessage) {\n        toolCallResult = `Error: ${errorMessage}`;\n      }\n\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).notifySubscribers(\n        (subscriber) =>\n          subscriber.onToolExecutionEnd?.({\n            copilotkit: this.core,\n            toolCallId: toolCall.id,\n            agentId: agentId,\n            toolName: toolCall.function.name,\n            result: errorMessage ? \"\" : toolCallResult,\n            error: errorMessage,\n          }),\n        \"Subscriber onToolExecutionEnd error:\",\n      );\n\n      if (isArgumentError) {\n        throw new Error(errorMessage ?? \"Tool execution failed\");\n      }\n    }\n\n    if (!errorMessage || !isArgumentError) {\n      const messageIndex = agent.messages.findIndex((m) => m.id === message.id);\n      const toolMessage = {\n        id: randomUUID(),\n        role: \"tool\" as const,\n        toolCallId: toolCall.id,\n        content: toolCallResult,\n      };\n      agent.messages.splice(messageIndex + 1, 0, toolMessage);\n\n      if (!errorMessage && wildcardTool?.followUp !== false) {\n        return true; // Needs follow-up\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Build frontend tools for an agent\n   */\n  buildFrontendTools(agentId?: string): Tool[] {\n    return this._tools\n      .filter((tool) => !tool.agentId || tool.agentId === agentId)\n      .map((tool) => ({\n        name: tool.name,\n        description: tool.description ?? \"\",\n        parameters: createToolSchema(tool),\n      }));\n  }\n\n  /**\n   * Create an agent error subscriber\n   */\n  private createAgentErrorSubscriber(agent: AbstractAgent): AgentSubscriber {\n    const emitAgentError = async (\n      error: Error,\n      code: CopilotKitCoreErrorCode,\n      extraContext: Record<string, any> = {},\n    ) => {\n      const context: Record<string, any> = { ...extraContext };\n      if (agent.agentId) {\n        context.agentId = agent.agentId;\n      }\n      await (this.core as unknown as CopilotKitCoreFriendsAccess).emitError({\n        error,\n        code,\n        context,\n      });\n    };\n\n    return {\n      onRunFailed: async ({ error }: { error: Error }) => {\n        await emitAgentError(error, CopilotKitCoreErrorCode.AGENT_RUN_FAILED_EVENT, {\n          source: \"onRunFailed\",\n        });\n      },\n      onRunErrorEvent: async ({ event }) => {\n        const eventError =\n          event?.rawEvent instanceof Error\n            ? event.rawEvent\n            : event?.rawEvent?.error instanceof Error\n              ? event.rawEvent.error\n              : undefined;\n\n        const errorMessage =\n          typeof event?.rawEvent?.error === \"string\" ? event.rawEvent.error : (event?.message ?? \"Agent run error\");\n\n        const rawError = eventError ?? new Error(errorMessage);\n\n        if (event?.code && !(rawError as any).code) {\n          (rawError as any).code = event.code;\n        }\n\n        await emitAgentError(rawError, CopilotKitCoreErrorCode.AGENT_RUN_ERROR_EVENT, {\n          source: \"onRunErrorEvent\",\n          event,\n          runtimeErrorCode: event?.code,\n        });\n      },\n    };\n  }\n}\n\n/**\n * Empty tool schema constant\n */\nconst EMPTY_TOOL_SCHEMA = {\n  type: \"object\",\n  properties: {},\n} as const satisfies Record<string, unknown>;\n\n/**\n * Create a JSON schema from a tool's parameters\n */\nfunction createToolSchema(tool: FrontendTool<any>): Record<string, unknown> {\n  if (!tool.parameters) {\n    return { ...EMPTY_TOOL_SCHEMA };\n  }\n\n  const rawSchema = zodToJsonSchema(tool.parameters, {\n    $refStrategy: \"none\",\n  });\n\n  if (!rawSchema || typeof rawSchema !== \"object\") {\n    return { ...EMPTY_TOOL_SCHEMA };\n  }\n\n  const { $schema, ...schema } = rawSchema as Record<string, unknown>;\n\n  if (typeof schema.type !== \"string\") {\n    schema.type = \"object\";\n  }\n  if (typeof schema.properties !== \"object\" || schema.properties === null) {\n    schema.properties = {};\n  }\n\n  stripAdditionalProperties(schema);\n  return schema;\n}\n\nfunction stripAdditionalProperties(schema: unknown): void {\n  if (!schema || typeof schema !== \"object\") {\n    return;\n  }\n\n  if (Array.isArray(schema)) {\n    schema.forEach(stripAdditionalProperties);\n    return;\n  }\n\n  const record = schema as Record<string, unknown>;\n\n  if (record.additionalProperties !== undefined) {\n    delete record.additionalProperties;\n  }\n\n  for (const value of Object.values(record)) {\n    stripAdditionalProperties(value);\n  }\n}\n", "import {\n  AbstractAgent,\n  Message,\n  State,\n  RunAgentInput,\n  RunStartedEvent,\n  RunFinishedEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n} from \"@ag-ui/client\";\nimport type { CopilotKitCore } from \"./core\";\n\n/**\n * Manages state and message tracking by run for CopilotKitCore.\n * Tracks agent state snapshots and message-to-run associations.\n */\nexport class StateManager {\n  // State tracking: agentId -> threadId -> runId -> state\n  private stateByRun: Map<string, Map<string, Map<string, State>>> = new Map();\n\n  // Message tracking: agentId -> threadId -> messageId -> runId\n  private messageToRun: Map<string, Map<string, Map<string, string>>> = new Map();\n\n  // Agent subscriptions for cleanup\n  private agentSubscriptions: Map<string, () => void> = new Map();\n\n  constructor(private core: CopilotKitCore) {}\n\n  /**\n   * Initialize state tracking for an agent\n   */\n  initialize(): void {\n    // Will be called when CopilotKitCore is initialized\n  }\n\n  /**\n   * Subscribe to an agent's events to track state and messages\n   */\n  subscribeToAgent(agent: AbstractAgent): void {\n    if (!agent.agentId) {\n      return; // Skip agents without IDs\n    }\n\n    const agentId = agent.agentId;\n\n    // Unsubscribe existing subscription if any\n    this.unsubscribeFromAgent(agentId);\n\n    // Subscribe to agent events\n    const { unsubscribe } = agent.subscribe({\n      onRunStartedEvent: ({ event, state }) => {\n        this.handleRunStarted(agent, event, state);\n      },\n      onRunFinishedEvent: ({ event, state }) => {\n        this.handleRunFinished(agent, event, state);\n      },\n      onStateSnapshotEvent: ({ event, input, state }) => {\n        this.handleStateSnapshot(agent, event, input, state);\n      },\n      onStateDeltaEvent: ({ event, input, state }) => {\n        this.handleStateDelta(agent, event, input, state);\n      },\n      onMessagesSnapshotEvent: ({ event, input, messages }) => {\n        this.handleMessagesSnapshot(agent, event, input, messages);\n      },\n      onNewMessage: ({ message, input }) => {\n        this.handleNewMessage(agent, message, input);\n      },\n    });\n\n    this.agentSubscriptions.set(agentId, unsubscribe);\n  }\n\n  /**\n   * Unsubscribe from an agent's events\n   */\n  unsubscribeFromAgent(agentId: string): void {\n    const unsubscribe = this.agentSubscriptions.get(agentId);\n    if (unsubscribe) {\n      unsubscribe();\n      this.agentSubscriptions.delete(agentId);\n    }\n  }\n\n  /**\n   * Get state for a specific run\n   * Returns a deep copy to prevent external mutations\n   */\n  getStateByRun(agentId: string, threadId: string, runId: string): State | undefined {\n    const state = this.stateByRun.get(agentId)?.get(threadId)?.get(runId);\n    if (!state) return undefined;\n    // Return a deep copy to prevent mutations\n    return JSON.parse(JSON.stringify(state));\n  }\n\n  /**\n   * Get runId associated with a message\n   */\n  getRunIdForMessage(agentId: string, threadId: string, messageId: string): string | undefined {\n    return this.messageToRun.get(agentId)?.get(threadId)?.get(messageId);\n  }\n\n  /**\n   * Get all states for an agent's thread\n   */\n  getStatesForThread(agentId: string, threadId: string): Map<string, State> {\n    return this.stateByRun.get(agentId)?.get(threadId) ?? new Map();\n  }\n\n  /**\n   * Get all run IDs for an agent's thread\n   */\n  getRunIdsForThread(agentId: string, threadId: string): string[] {\n    const threadStates = this.stateByRun.get(agentId)?.get(threadId);\n    return threadStates ? Array.from(threadStates.keys()) : [];\n  }\n\n  /**\n   * Handle run started event\n   */\n  private handleRunStarted(agent: AbstractAgent, event: RunStartedEvent, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = event;\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle run finished event\n   */\n  private handleRunFinished(agent: AbstractAgent, event: RunFinishedEvent, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = event;\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle state snapshot event\n   */\n  private handleStateSnapshot(\n    agent: AbstractAgent,\n    event: StateSnapshotEvent,\n    input: RunAgentInput,\n    state: State,\n  ): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n    // Merge snapshot into current state\n    const mergedState = { ...state, ...event.snapshot };\n    this.saveState(agent.agentId, threadId, runId, mergedState);\n  }\n\n  /**\n   * Handle state delta event\n   */\n  private handleStateDelta(agent: AbstractAgent, event: StateDeltaEvent, input: RunAgentInput, state: State): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n    // State is already updated by the agent, just save it\n    this.saveState(agent.agentId, threadId, runId, state);\n  }\n\n  /**\n   * Handle messages snapshot event\n   */\n  private handleMessagesSnapshot(\n    agent: AbstractAgent,\n    event: MessagesSnapshotEvent,\n    input: RunAgentInput,\n    messages: Message[],\n  ): void {\n    if (!agent.agentId) return;\n\n    const { threadId, runId } = input;\n\n    // Associate all messages in the snapshot with this run\n    for (const message of event.messages) {\n      this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);\n    }\n  }\n\n  /**\n   * Handle new message event\n   */\n  private handleNewMessage(agent: AbstractAgent, message: Message, input?: RunAgentInput): void {\n    if (!agent.agentId || !input) return;\n\n    const { threadId, runId } = input;\n    this.associateMessageWithRun(agent.agentId, threadId, message.id, runId);\n  }\n\n  /**\n   * Save state for a specific run\n   */\n  private saveState(agentId: string, threadId: string, runId: string, state: State): void {\n    // Ensure nested maps exist\n    if (!this.stateByRun.has(agentId)) {\n      this.stateByRun.set(agentId, new Map());\n    }\n    const agentStates = this.stateByRun.get(agentId)!;\n\n    if (!agentStates.has(threadId)) {\n      agentStates.set(threadId, new Map());\n    }\n    const threadStates = agentStates.get(threadId)!;\n\n    // Deep copy the state to prevent mutations\n    threadStates.set(runId, JSON.parse(JSON.stringify(state)));\n  }\n\n  /**\n   * Associate a message with a run\n   */\n  private associateMessageWithRun(agentId: string, threadId: string, messageId: string, runId: string): void {\n    // Ensure nested maps exist\n    if (!this.messageToRun.has(agentId)) {\n      this.messageToRun.set(agentId, new Map());\n    }\n    const agentMessages = this.messageToRun.get(agentId)!;\n\n    if (!agentMessages.has(threadId)) {\n      agentMessages.set(threadId, new Map());\n    }\n    const threadMessages = agentMessages.get(threadId)!;\n\n    threadMessages.set(messageId, runId);\n  }\n\n  /**\n   * Clear all state for an agent\n   */\n  clearAgentState(agentId: string): void {\n    this.stateByRun.delete(agentId);\n    this.messageToRun.delete(agentId);\n  }\n\n  /**\n   * Clear all state for a thread\n   */\n  clearThreadState(agentId: string, threadId: string): void {\n    this.stateByRun.get(agentId)?.delete(threadId);\n    this.messageToRun.get(agentId)?.delete(threadId);\n  }\n}\n", "import { AbstractAgent, Context, State } from \"@ag-ui/client\";\nimport { FrontendTool, SuggestionsConfig, Suggestion, CopilotRuntimeTransport } from \"../types\";\nimport { AgentRegistry, CopilotKitCoreAddAgentParams } from \"./agent-registry\";\nimport { ContextStore } from \"./context-store\";\nimport { SuggestionEngine } from \"./suggestion-engine\";\nimport {\n  RunHandler,\n  CopilotKitCoreRunAgentParams,\n  CopilotKitCoreConnectAgentParams,\n  CopilotKitCoreGetToolParams,\n} from \"./run-handler\";\nimport { StateManager } from \"./state-manager\";\n\n/** Configuration options for `CopilotKitCore`. */\nexport interface CopilotKitCoreConfig {\n  /** The endpoint of the CopilotRuntime. */\n  runtimeUrl?: string;\n  /** Transport style for CopilotRuntime endpoints. Defaults to REST. */\n  runtimeTransport?: CopilotRuntimeTransport;\n  /** Mapping from agent name to its `AbstractAgent` instance. For development only - production requires CopilotRuntime. */\n  agents__unsafe_dev_only?: Record<string, AbstractAgent>;\n  /** Headers appended to every HTTP request made by `CopilotKitCore`. */\n  headers?: Record<string, string>;\n  /** Credentials mode for fetch requests (e.g., \"include\" for HTTP-only cookies). */\n  credentials?: RequestCredentials;\n  /** Properties sent as `forwardedProps` to the AG-UI agent. */\n  properties?: Record<string, unknown>;\n  /** Ordered collection of frontend tools available to the core. */\n  tools?: FrontendTool<any>[];\n  /** Suggestions config for the core. */\n  suggestionsConfig?: SuggestionsConfig[];\n}\n\nexport type { CopilotKitCoreAddAgentParams };\nexport type { CopilotKitCoreRunAgentParams, CopilotKitCoreConnectAgentParams, CopilotKitCoreGetToolParams };\n\nexport interface CopilotKitCoreStopAgentParams {\n  agent: AbstractAgent;\n}\n\nexport type CopilotKitCoreGetSuggestionsResult = {\n  suggestions: Suggestion[];\n  isLoading: boolean;\n};\n\nexport enum CopilotKitCoreErrorCode {\n  RUNTIME_INFO_FETCH_FAILED = \"runtime_info_fetch_failed\",\n  AGENT_CONNECT_FAILED = \"agent_connect_failed\",\n  AGENT_RUN_FAILED = \"agent_run_failed\",\n  AGENT_RUN_FAILED_EVENT = \"agent_run_failed_event\",\n  AGENT_RUN_ERROR_EVENT = \"agent_run_error_event\",\n  TOOL_ARGUMENT_PARSE_FAILED = \"tool_argument_parse_failed\",\n  TOOL_HANDLER_FAILED = \"tool_handler_failed\",\n  // Transcription errors\n  TRANSCRIPTION_FAILED = \"transcription_failed\",\n  TRANSCRIPTION_SERVICE_NOT_CONFIGURED = \"transcription_service_not_configured\",\n  TRANSCRIPTION_INVALID_AUDIO = \"transcription_invalid_audio\",\n  TRANSCRIPTION_RATE_LIMITED = \"transcription_rate_limited\",\n  TRANSCRIPTION_AUTH_FAILED = \"transcription_auth_failed\",\n  TRANSCRIPTION_NETWORK_ERROR = \"transcription_network_error\",\n}\n\nexport interface CopilotKitCoreSubscriber {\n  onRuntimeConnectionStatusChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    status: CopilotKitCoreRuntimeConnectionStatus;\n  }) => void | Promise<void>;\n  onToolExecutionStart?: (event: {\n    copilotkit: CopilotKitCore;\n    toolCallId: string;\n    agentId: string;\n    toolName: string;\n    args: unknown;\n  }) => void | Promise<void>;\n  onToolExecutionEnd?: (event: {\n    copilotkit: CopilotKitCore;\n    toolCallId: string;\n    agentId: string;\n    toolName: string;\n    result: string;\n    error?: string;\n  }) => void | Promise<void>;\n  onAgentsChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    agents: Readonly<Record<string, AbstractAgent>>;\n  }) => void | Promise<void>;\n  onContextChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    context: Readonly<Record<string, Context>>;\n  }) => void | Promise<void>;\n  onSuggestionsConfigChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    suggestionsConfig: Readonly<Record<string, SuggestionsConfig>>;\n  }) => void | Promise<void>;\n  onSuggestionsChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    agentId: string;\n    suggestions: Suggestion[];\n  }) => void | Promise<void>;\n  onSuggestionsStartedLoading?: (event: { copilotkit: CopilotKitCore; agentId: string }) => void | Promise<void>;\n  onSuggestionsFinishedLoading?: (event: { copilotkit: CopilotKitCore; agentId: string }) => void | Promise<void>;\n  onPropertiesChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    properties: Readonly<Record<string, unknown>>;\n  }) => void | Promise<void>;\n  onHeadersChanged?: (event: {\n    copilotkit: CopilotKitCore;\n    headers: Readonly<Record<string, string>>;\n  }) => void | Promise<void>;\n  onError?: (event: {\n    copilotkit: CopilotKitCore;\n    error: Error;\n    code: CopilotKitCoreErrorCode;\n    context: Record<string, any>;\n  }) => void | Promise<void>;\n}\n\n// Subscription object returned by subscribe()\nexport interface CopilotKitCoreSubscription {\n  unsubscribe: () => void;\n}\n\nexport enum CopilotKitCoreRuntimeConnectionStatus {\n  Disconnected = \"disconnected\",\n  Connected = \"connected\",\n  Connecting = \"connecting\",\n  Error = \"error\",\n}\n\n/**\n * Internal interface for delegate classes to access CopilotKitCore methods.\n * This provides type safety while allowing controlled access to private functionality.\n */\nexport interface CopilotKitCoreFriendsAccess {\n  // Notification methods\n  notifySubscribers(\n    handler: (subscriber: CopilotKitCoreSubscriber) => void | Promise<void>,\n    errorMessage: string,\n  ): Promise<void>;\n\n  emitError(params: { error: Error; code: CopilotKitCoreErrorCode; context?: Record<string, any> }): Promise<void>;\n\n  // Getters for internal state\n  readonly headers: Readonly<Record<string, string>>;\n  readonly credentials: RequestCredentials | undefined;\n  readonly properties: Readonly<Record<string, unknown>>;\n  readonly context: Readonly<Record<string, Context>>;\n\n  // Internal methods\n  buildFrontendTools(agentId?: string): import(\"@ag-ui/client\").Tool[];\n  getAgent(id: string): AbstractAgent | undefined;\n\n  // References to delegate subsystems\n  readonly suggestionEngine: {\n    clearSuggestions(agentId: string): void;\n    reloadSuggestions(agentId: string): void;\n  };\n}\n\nexport class CopilotKitCore {\n  private _headers: Record<string, string>;\n  private _credentials?: RequestCredentials;\n  private _properties: Record<string, unknown>;\n\n  private subscribers: Set<CopilotKitCoreSubscriber> = new Set();\n\n  // Delegate classes\n  private agentRegistry: AgentRegistry;\n  private contextStore: ContextStore;\n  private suggestionEngine: SuggestionEngine;\n  private runHandler: RunHandler;\n  private stateManager: StateManager;\n\n  constructor({\n    runtimeUrl,\n    runtimeTransport = \"rest\",\n    headers = {},\n    credentials,\n    properties = {},\n    agents__unsafe_dev_only = {},\n    tools = [],\n    suggestionsConfig = [],\n  }: CopilotKitCoreConfig) {\n    this._headers = headers;\n    this._credentials = credentials;\n    this._properties = properties;\n\n    // Initialize delegate classes\n    this.agentRegistry = new AgentRegistry(this);\n    this.contextStore = new ContextStore(this);\n    this.suggestionEngine = new SuggestionEngine(this);\n    this.runHandler = new RunHandler(this);\n    this.stateManager = new StateManager(this);\n\n    // Initialize each subsystem\n    this.agentRegistry.initialize(agents__unsafe_dev_only);\n    this.runHandler.initialize(tools);\n    this.suggestionEngine.initialize(suggestionsConfig);\n    this.stateManager.initialize();\n\n    this.agentRegistry.setRuntimeTransport(runtimeTransport);\n    this.agentRegistry.setRuntimeUrl(runtimeUrl);\n\n    // Subscribe to agent changes to track state for new agents\n    this.subscribe({\n      onAgentsChanged: ({ agents }) => {\n        Object.values(agents).forEach((agent) => {\n          if (agent.agentId) {\n            this.stateManager.subscribeToAgent(agent);\n          }\n        });\n      },\n    });\n  }\n\n  /**\n   * Internal method used by delegate classes and subclasses to notify subscribers\n   */\n  protected async notifySubscribers(\n    handler: (subscriber: CopilotKitCoreSubscriber) => void | Promise<void>,\n    errorMessage: string,\n  ): Promise<void> {\n    await Promise.all(\n      Array.from(this.subscribers).map(async (subscriber) => {\n        try {\n          await handler(subscriber);\n        } catch (error) {\n          console.error(errorMessage, error);\n        }\n      }),\n    );\n  }\n\n  /**\n   * Internal method used by delegate classes to emit errors\n   */\n  private async emitError({\n    error,\n    code,\n    context = {},\n  }: {\n    error: Error;\n    code: CopilotKitCoreErrorCode;\n    context?: Record<string, any>;\n  }): Promise<void> {\n    await this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onError?.({\n          copilotkit: this,\n          error,\n          code,\n          context,\n        }),\n      \"Subscriber onError error:\",\n    );\n  }\n\n  /**\n   * Snapshot accessors\n   */\n  get context(): Readonly<Record<string, Context>> {\n    return this.contextStore.context;\n  }\n\n  get agents(): Readonly<Record<string, AbstractAgent>> {\n    return this.agentRegistry.agents;\n  }\n\n  get tools(): Readonly<FrontendTool<any>[]> {\n    return this.runHandler.tools;\n  }\n\n  get runtimeUrl(): string | undefined {\n    return this.agentRegistry.runtimeUrl;\n  }\n\n  setRuntimeUrl(runtimeUrl: string | undefined): void {\n    this.agentRegistry.setRuntimeUrl(runtimeUrl);\n  }\n\n  get runtimeTransport(): CopilotRuntimeTransport {\n    return this.agentRegistry.runtimeTransport;\n  }\n\n  setRuntimeTransport(runtimeTransport: CopilotRuntimeTransport): void {\n    this.agentRegistry.setRuntimeTransport(runtimeTransport);\n  }\n\n  get runtimeVersion(): string | undefined {\n    return this.agentRegistry.runtimeVersion;\n  }\n\n  get headers(): Readonly<Record<string, string>> {\n    return this._headers;\n  }\n\n  get credentials(): RequestCredentials | undefined {\n    return this._credentials;\n  }\n\n  get properties(): Readonly<Record<string, unknown>> {\n    return this._properties;\n  }\n\n  get runtimeConnectionStatus(): CopilotKitCoreRuntimeConnectionStatus {\n    return this.agentRegistry.runtimeConnectionStatus;\n  }\n\n  get audioFileTranscriptionEnabled(): boolean {\n    return this.agentRegistry.audioFileTranscriptionEnabled;\n  }\n\n  /**\n   * Configuration updates\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this._headers = headers;\n    this.agentRegistry.applyHeadersToAgents(this.agentRegistry.agents as Record<string, AbstractAgent>);\n    void this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onHeadersChanged?.({\n          copilotkit: this,\n          headers: this.headers,\n        }),\n      \"Subscriber onHeadersChanged error:\",\n    );\n  }\n\n  setCredentials(credentials: RequestCredentials | undefined): void {\n    this._credentials = credentials;\n    this.agentRegistry.applyCredentialsToAgents(this.agentRegistry.agents as Record<string, AbstractAgent>);\n  }\n\n  setProperties(properties: Record<string, unknown>): void {\n    this._properties = properties;\n    void this.notifySubscribers(\n      (subscriber) =>\n        subscriber.onPropertiesChanged?.({\n          copilotkit: this,\n          properties: this.properties,\n        }),\n      \"Subscriber onPropertiesChanged error:\",\n    );\n  }\n\n  /**\n   * Agent management (delegated to AgentRegistry)\n   */\n  setAgents__unsafe_dev_only(agents: Record<string, AbstractAgent>): void {\n    this.agentRegistry.setAgents__unsafe_dev_only(agents);\n  }\n\n  addAgent__unsafe_dev_only(params: CopilotKitCoreAddAgentParams): void {\n    this.agentRegistry.addAgent__unsafe_dev_only(params);\n  }\n\n  removeAgent__unsafe_dev_only(id: string): void {\n    this.agentRegistry.removeAgent__unsafe_dev_only(id);\n  }\n\n  getAgent(id: string): AbstractAgent | undefined {\n    return this.agentRegistry.getAgent(id);\n  }\n\n  /**\n   * Context management (delegated to ContextStore)\n   */\n  addContext(context: Context): string {\n    return this.contextStore.addContext(context);\n  }\n\n  removeContext(id: string): void {\n    this.contextStore.removeContext(id);\n  }\n\n  /**\n   * Suggestions management (delegated to SuggestionEngine)\n   */\n  addSuggestionsConfig(config: SuggestionsConfig): string {\n    return this.suggestionEngine.addSuggestionsConfig(config);\n  }\n\n  removeSuggestionsConfig(id: string): void {\n    this.suggestionEngine.removeSuggestionsConfig(id);\n  }\n\n  reloadSuggestions(agentId: string): void {\n    this.suggestionEngine.reloadSuggestions(agentId);\n  }\n\n  clearSuggestions(agentId: string): void {\n    this.suggestionEngine.clearSuggestions(agentId);\n  }\n\n  getSuggestions(agentId: string): CopilotKitCoreGetSuggestionsResult {\n    return this.suggestionEngine.getSuggestions(agentId);\n  }\n\n  /**\n   * Tool management (delegated to RunHandler)\n   */\n  addTool<T extends Record<string, unknown> = Record<string, unknown>>(tool: FrontendTool<T>): void {\n    this.runHandler.addTool(tool);\n  }\n\n  removeTool(id: string, agentId?: string): void {\n    this.runHandler.removeTool(id, agentId);\n  }\n\n  getTool(params: CopilotKitCoreGetToolParams): FrontendTool<any> | undefined {\n    return this.runHandler.getTool(params);\n  }\n\n  setTools(tools: FrontendTool<any>[]): void {\n    this.runHandler.setTools(tools);\n  }\n\n  /**\n   * Subscription lifecycle\n   */\n  subscribe(subscriber: CopilotKitCoreSubscriber): CopilotKitCoreSubscription {\n    this.subscribers.add(subscriber);\n\n    // Return subscription with unsubscribe method\n    return {\n      unsubscribe: () => {\n        this.subscribers.delete(subscriber);\n      },\n    };\n  }\n\n  /**\n   * Agent connectivity (delegated to RunHandler)\n   */\n  async connectAgent(params: CopilotKitCoreConnectAgentParams): Promise<import(\"@ag-ui/client\").RunAgentResult> {\n    return this.runHandler.connectAgent(params);\n  }\n\n  stopAgent(params: CopilotKitCoreStopAgentParams): void {\n    params.agent.abortRun();\n  }\n\n  async runAgent(params: CopilotKitCoreRunAgentParams): Promise<import(\"@ag-ui/client\").RunAgentResult> {\n    return this.runHandler.runAgent(params);\n  }\n\n  /**\n   * State management (delegated to StateManager)\n   */\n  getStateByRun(agentId: string, threadId: string, runId: string): State | undefined {\n    return this.stateManager.getStateByRun(agentId, threadId, runId);\n  }\n\n  getRunIdForMessage(agentId: string, threadId: string, messageId: string): string | undefined {\n    return this.stateManager.getRunIdForMessage(agentId, threadId, messageId);\n  }\n\n  getRunIdsForThread(agentId: string, threadId: string): string[] {\n    return this.stateManager.getRunIdsForThread(agentId, threadId);\n  }\n\n  /**\n   * Internal method used by RunHandler to build frontend tools\n   */\n  private buildFrontendTools(agentId?: string): import(\"@ag-ui/client\").Tool[] {\n    return this.runHandler.buildFrontendTools(agentId);\n  }\n}\n", "import { ToolCall } from \"@ag-ui/client\";\nimport { z } from \"zod\";\n\n/**\n * Status of a tool call execution\n */\nexport enum ToolCallStatus {\n  InProgress = \"inProgress\",\n  Executing = \"executing\",\n  Complete = \"complete\",\n}\n\nexport type CopilotRuntimeTransport = \"rest\" | \"single\";\n\nexport type FrontendTool<T extends Record<string, unknown> = Record<string, unknown>> = {\n  name: string;\n  description?: string;\n  parameters?: z.ZodType<T>;\n  handler?: (args: T, toolCall: ToolCall) => Promise<unknown>;\n  followUp?: boolean;\n  /**\n   * Optional agent ID to constrain this tool to a specific agent.\n   * If specified, this tool will only be available to the specified agent.\n   */\n  agentId?: string;\n};\n\nexport type Suggestion = {\n  title: string;\n  message: string;\n  /** Indicates whether this suggestion is still being generated. */\n  isLoading: boolean;\n};\n\nexport type SuggestionAvailability = \"before-first-message\" | \"after-first-message\" | \"always\" | \"disabled\";\n\nexport type DynamicSuggestionsConfig = {\n  /**\n   * A prompt or instructions for the GPT to generate suggestions.\n   */\n  instructions: string;\n  /**\n   * The minimum number of suggestions to generate. Defaults to `1`.\n   * @default 1\n   */\n  minSuggestions?: number;\n  /**\n   * The maximum number of suggestions to generate. Defaults to `3`.\n   * @default 1\n   */\n  maxSuggestions?: number;\n\n  /**\n   * When the suggestions are available. Defaults to \"after-first-message\".\n   */\n  available?: SuggestionAvailability;\n\n  /**\n   * The agent ID of the provider of the suggestions. Defaults to `\"default\"`.\n   */\n  providerAgentId?: string;\n\n  /**\n   * The agent ID of the consumer of the suggestions. Defaults to `\"*\"` (all agents).\n   */\n  consumerAgentId?: string;\n};\n\nexport type StaticSuggestionsConfig = {\n  /**\n   * The suggestions to display.\n   */\n  suggestions: Omit<Suggestion, \"isLoading\">[];\n\n  /**\n   * When the suggestions are available. Defaults to \"before-first-message\".\n   */\n  available?: SuggestionAvailability;\n\n  /**\n   * The agent ID of the consumer of the suggestions. Defaults to `\"*\"` (all agents).\n   */\n  consumerAgentId?: string;\n};\n\nexport type SuggestionsConfig = DynamicSuggestionsConfig | StaticSuggestionsConfig;\n", "export function completePartialMarkdown(input: string): string {\n  let s = input;\n\n  // Handle code fences first - use FIRST unmatched fence for proper nesting\n  const fenceMatches = Array.from(s.matchAll(/^(\\s*)(`{3,}|~{3,})/gm));\n  if (fenceMatches.length % 2 === 1) {\n    const [, indent, fence] = fenceMatches[0]!;\n    s += `\\n${indent}${fence}`;\n  }\n\n  // Identify incomplete links at the end and close them\n  const incompleteLinkMatch = s.match(/\\[([^\\]]*)\\]\\(([^)]*)$/);\n  if (incompleteLinkMatch) {\n    s += \")\";\n  }\n\n  // State-based parsing\n  interface OpenElement {\n    type: string;\n    marker: string;\n    position: number;\n  }\n\n  const openElements: OpenElement[] = [];\n  const chars = Array.from(s);\n\n  // First pass: identify code block boundaries and inline code to avoid processing their content\n  const codeBlockRanges: Array<{ start: number; end: number }> = [];\n  const inlineCodeRanges: Array<{ start: number; end: number }> = [];\n\n  // Find code block ranges\n  let tempCodeFenceCount = 0;\n  let currentCodeBlockStart = -1;\n\n  for (let i = 0; i < chars.length; i++) {\n    if (i === 0 || chars[i - 1] === \"\\n\") {\n      const lineMatch = s.substring(i).match(/^(\\s*)(`{3,}|~{3,})/);\n      if (lineMatch) {\n        tempCodeFenceCount++;\n        if (tempCodeFenceCount % 2 === 1) {\n          currentCodeBlockStart = i;\n        } else if (currentCodeBlockStart !== -1) {\n          codeBlockRanges.push({\n            start: currentCodeBlockStart,\n            end: i + lineMatch[0].length,\n          });\n          currentCodeBlockStart = -1;\n        }\n        i += lineMatch[0].length - 1;\n      }\n    }\n  }\n\n  // Find inline code ranges\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === \"`\") {\n      // Check if escaped\n      let backslashCount = 0;\n      for (let j = i - 1; j >= 0 && chars[j] === \"\\\\\"; j--) {\n        backslashCount++;\n      }\n      if (backslashCount % 2 === 0) {\n        // Not escaped - find the closing backtick\n        for (let j = i + 1; j < chars.length; j++) {\n          if (chars[j] === \"`\") {\n            let closingBackslashCount = 0;\n            for (let k = j - 1; k >= 0 && chars[k] === \"\\\\\"; k--) {\n              closingBackslashCount++;\n            }\n            if (closingBackslashCount % 2 === 0) {\n              inlineCodeRanges.push({ start: i, end: j + 1 });\n              i = j;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Helper function to check if position is in code\n  const isInCode = (pos: number): boolean => {\n    return (\n      codeBlockRanges.some((range) => pos >= range.start && pos < range.end) ||\n      inlineCodeRanges.some((range) => pos >= range.start && pos < range.end)\n    );\n  };\n\n  // Second pass: process markdown elements, skipping code regions\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    const nextChar = chars[i + 1];\n    const prevChar = chars[i - 1];\n\n    if (isInCode(i)) {\n      continue;\n    }\n\n    // Handle brackets (but not if they're part of already-complete links)\n    if (char === \"[\") {\n      // Check if this is part of a complete link [text](url)\n      let isCompleteLink = false;\n      let bracketDepth = 1;\n      let j = i + 1;\n\n      // Find the matching ]\n      while (j < chars.length && bracketDepth > 0) {\n        if (chars[j] === \"[\" && !isInCode(j)) bracketDepth++;\n        if (chars[j] === \"]\" && !isInCode(j)) bracketDepth--;\n        j++;\n      }\n\n      // Check if followed by (\n      if (bracketDepth === 0 && chars[j] === \"(\") {\n        // Find the closing )\n        let parenDepth = 1;\n        j++;\n        while (j < chars.length && parenDepth > 0) {\n          if (chars[j] === \"(\" && !isInCode(j)) parenDepth++;\n          if (chars[j] === \")\" && !isInCode(j)) parenDepth--;\n          j++;\n        }\n        if (parenDepth === 0) {\n          isCompleteLink = true;\n          i = j - 1;\n          continue;\n        }\n      }\n\n      // This is a standalone bracket, treat as markdown\n      if (!isCompleteLink) {\n        const existingIndex = openElements.findIndex(\n          (el) => el.type === \"bracket\"\n        );\n        if (existingIndex !== -1) {\n          openElements.splice(existingIndex, 1);\n        } else {\n          openElements.push({ type: \"bracket\", marker: \"[\", position: i });\n        }\n      }\n    }\n\n    // Handle double emphasis first (**, __, ~~) - these take precedence\n    else if (char === \"*\" && nextChar === \"*\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"bold_star\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"bold_star\", marker: \"**\", position: i });\n      }\n      i++; // Skip next character\n    } else if (char === \"_\" && nextChar === \"_\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"bold_underscore\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({\n          type: \"bold_underscore\",\n          marker: \"__\",\n          position: i,\n        });\n      }\n      i++; // Skip next character\n    } else if (char === \"~\" && nextChar === \"~\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"strike\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"strike\", marker: \"~~\", position: i });\n      }\n      i++; // Skip next character\n    }\n\n    // Handle single emphasis (*, _) - only if not part of double\n    else if (char === \"*\" && prevChar !== \"*\" && nextChar !== \"*\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"italic_star\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({ type: \"italic_star\", marker: \"*\", position: i });\n      }\n    } else if (char === \"_\" && prevChar !== \"_\" && nextChar !== \"_\") {\n      const existingIndex = openElements.findIndex(\n        (el) => el.type === \"italic_underscore\"\n      );\n      if (existingIndex !== -1) {\n        openElements.splice(existingIndex, 1);\n      } else {\n        openElements.push({\n          type: \"italic_underscore\",\n          marker: \"_\",\n          position: i,\n        });\n      }\n    }\n  }\n\n  // Handle remaining unmatched backticks (outside of inline code ranges)\n  let backtickCount = 0;\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] === \"`\" && !isInCode(i)) {\n      backtickCount++;\n    }\n  }\n  if (backtickCount % 2 === 1) {\n    s += \"`\";\n  }\n\n  // Close remaining open elements in reverse order (LIFO stack semantics)\n  openElements.sort((a, b) => b.position - a.position);\n\n  const closers = openElements.map((el) => {\n    switch (el.type) {\n      case \"bracket\":\n        return \"]\";\n      case \"bold_star\":\n        return \"**\";\n      case \"bold_underscore\":\n        return \"__\";\n      case \"strike\":\n        return \"~~\";\n      case \"italic_star\":\n        return \"*\";\n      case \"italic_underscore\":\n        return \"_\";\n      default:\n        return \"\";\n    }\n  });\n\n  let result = s + closers.join(\"\");\n\n  // Handle parentheses ONLY if not inside code\n  const finalFenceMatches = Array.from(\n    result.matchAll(/^(\\s*)(`{3,}|~{3,})/gm)\n  );\n  const hasUnclosedBacktick = (result.match(/`/g) || []).length % 2 === 1;\n  const hasUnclosedCodeFence = finalFenceMatches.length % 2 === 1;\n\n  let shouldCloseParens = !hasUnclosedBacktick && !hasUnclosedCodeFence;\n\n  if (shouldCloseParens) {\n    const lastOpenParen = result.lastIndexOf(\"(\");\n    if (lastOpenParen !== -1) {\n      // Check if this paren is inside a backtick pair\n      const beforeParen = result.substring(0, lastOpenParen);\n      const backticksBeforeParen = (beforeParen.match(/`/g) || []).length;\n      if (backticksBeforeParen % 2 === 1) {\n        shouldCloseParens = false;\n      }\n    }\n  }\n\n  if (shouldCloseParens) {\n    const openParens = (result.match(/\\(/g) || []).length;\n    const closeParens = (result.match(/\\)/g) || []).length;\n    if (openParens > closeParens) {\n      result += \")\".repeat(openParens - closeParens);\n    }\n  }\n\n  return result;\n}"],
  "mappings": "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",
  "names": ["k", "k2", "exports", "PartialJSON", "e", "parse", "util", "k", "objectUtil", "first", "map", "map", "x", "pairs", "errorUtil", "errorMap", "ctx", "min", "max", "result", "pairs", "issues", "x", "first", "elements", "me", "processed", "result", "r", "ZodFirstPartyTypeKind", "z", "EventType", "d", "b", "__assign", "y", "__values", "from", "__values", "v", "x", "Subscription", "__values", "empty", "timeout", "Subscriber", "ConsumerObserver", "SafeSubscriber", "x", "Observable", "observable", "x", "__values", "process", "OperatorSubscriber", "err", "Action", "delay", "timeout", "AsyncAction", "delay", "Scheduler", "delay", "AsyncScheduler", "delay", "repeat", "delay", "delay", "iterator", "iterator", "expand", "buffer", "Subject", "__values", "observable", "AnonymousSubject", "NotificationKind", "Notification", "ConnectableObservable", "BehaviorSubject", "AsyncSubject", "ReplaySubject", "last", "_a", "timestamp", "timestamp", "AsapAction", "delay", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "AnimationFrameScheduler", "VirtualTimeScheduler", "VirtualAction", "delay", "config", "NEVER", "__extends", "extendStatics", "d", "b", "k", "__extends", "PatchError", "generate", "Mirror", "ObserverInfo", "generate", "context", "char", "te", "WireType", "ScalarType", "JsonPatchOperationType", "BinaryWriter", "BinaryReader", "EventType", "EventType", "structuredClone_", "obj", "err", "__spreadValues", "runSubscribersWithMutation", "subscribers", "initialMessages", "initialState", "executor", "messages", "state", "stopPropagation", "subscriber", "mutation", "structuredClone_", "error", "__spreadValues", "defaultApplyEvents", "input", "events$", "agent", "currentMutation", "applyMutation", "emitUpdates", "result", "of", "EMPTY", "concatMap", "event", "_a", "_b", "_c", "_d", "_e", "EventType", "messageId", "role", "newMessage", "delta", "targetMessage", "m", "existingContent", "toolCallId", "toolCallName", "parentMessageId", "tc", "targetToolCall", "toolCallBuffer", "partialToolCallArgs", "untruncateJson", "toolCallArgsString", "toolCallArgs", "content", "toolMessage", "snapshot", "applyPatch", "errorMessage", "newMessages", "activityEvent", "existingIndex", "existingMessage", "existingActivityMessage", "replace", "activityMessage", "createdMessage", "__spreadProps", "baseContent", "updatedContent", "runStartedEvent", "message", "_exhaustiveCheck", "mergeAll", "defaultIfEmpty", "stream", "verifyEvents", "debug", "source$", "activeMessages", "activeToolCalls", "runFinished", "runError", "firstEventReceived", "activeSteps", "activeThinkingStep", "activeThinkingStepMessage", "runStarted", "resetRunState", "mergeMap", "eventType", "throwError", "AGUIError", "stepName", "unfinishedSteps", "unfinishedMessages", "unfinishedToolCalls", "runHttpRequest", "url", "requestInit", "defer", "from", "switchMap", "response", "contentType", "text", "payload", "e", "err", "headersEvent", "reader", "Observable", "done", "value", "dataEvent", "parseSSEStream", "jsonSubject", "Subject", "decoder", "buffer", "events", "processSSEEvent", "eventText", "lines", "dataLines", "line", "jsonStr", "json", "parseProtoStream", "eventSubject", "newBuffer", "processBuffer", "totalLength", "transformHttpEventStream", "bufferSubject", "ReplaySubject", "parserInitialized", "parsedEvent", "EventSchemas", "LegacyRuntimeEventTypes", "z", "LegacyRuntimeMetaEventName", "LegacyTextMessageStart", "LegacyTextMessageContent", "LegacyTextMessageEnd", "LegacyActionExecutionStart", "LegacyActionExecutionArgs", "LegacyActionExecutionEnd", "LegacyActionExecutionResult", "LegacyAgentStateMessage", "LegacyMetaEvent", "LegacyRunError", "LegacyRuntimeProtocolEvent", "LegacyTextMessageSchema", "LegacyActionExecutionMessageSchema", "LegacyResultMessageSchema", "flattenMessageContentToText", "textParts", "part", "convertToLegacyEvents", "threadId", "runId", "agentName", "currentState", "running", "active", "nodeName", "syncedMessages", "predictState", "currentToolCalls", "toolCallNames", "updateCurrentState", "newState", "startEvent", "contentEvent", "endEvent", "argsEvent", "currentToolCall", "didUpdateState", "currentPredictState", "s", "currentArgs", "resultEvent", "customEvent", "convertMessagesToLegacyFormat", "errorEvent", "textContent", "textMessage", "toolCall", "actionExecutionMessage", "actionName", "transformChunks", "textMessageFields", "toolCallFields", "mode", "closeTextMessage", "closeToolCall", "closePendingEvent", "messageChunkEvent", "textMessageResult", "textMessageStartEvent", "textMessageContentEvent", "toolCallChunkEvent", "toolMessageResult", "toolCallStartEvent", "toolCallArgsEvent", "finalize", "Middleware", "next", "currentMessages", "resolve", "FunctionMiddleware", "fn", "sanitizeMessageContent", "message", "rawContent", "concatenatedContent", "part", "__spreadProps", "__spreadValues", "BackwardCompatibility_0_0_39", "Middleware", "input", "next", "_a", "_parentRunId", "rest", "__objRest", "sanitizedInput", "package_default", "AbstractAgent", "agentId", "description", "threadId", "initialMessages", "initialState", "debug", "uuidv4", "structuredClone_", "compareVersions", "subscriber", "s", "middlewares", "normalizedMiddlewares", "middleware", "FunctionMiddleware", "parameters", "result", "currentMessageIds", "subscribers", "params", "Subject", "resolveActiveRunCompletion", "resolve", "pipeline", "pipe", "nextAgent", "i", "transformChunks", "verifyEvents", "source$", "takeUntil", "catchError", "error", "finalize", "lastValueFrom", "of", "newMessages", "AGUIConnectNotImplementedError", "EMPTY", "_b", "completion", "events$", "defaultApplyEvents", "tap", "event", "_c", "messagesWithoutActivity", "onRunInitializedMutation", "runSubscribersWithMutation", "messages", "state", "from", "map", "onRunFailedMutation", "mutation", "onRunFinalizedMutation", "cloned", "toolCall", "config", "convertToLegacyEvents", "HttpAgent", "httpEvents", "runHttpRequest", "transformHttpEventStream", "newController", "originalSignal", "FunctionCallSchema", "ToolCallSchema", "BaseMessageSchema", "TextInputContentSchema", "BinaryInputContentObjectSchema", "ensureBinaryPayload", "BinaryInputContentSchema", "InputContentBaseSchema", "InputContentSchema", "DeveloperMessageSchema", "SystemMessageSchema", "AssistantMessageSchema", "UserMessageSchema", "ToolMessageSchema", "ActivityMessageSchema", "MessageSchema", "RoleSchema", "ContextSchema", "ToolSchema", "RunAgentInputSchema", "StateSchema", "TextMessageRoleSchema", "z", "EventType", "BaseEventSchema", "TextMessageStartEventSchema", "TextMessageContentEventSchema", "TextMessageEndEventSchema", "TextMessageChunkEventSchema", "ThinkingTextMessageStartEventSchema", "ThinkingTextMessageContentEventSchema", "ThinkingTextMessageEndEventSchema", "ToolCallStartEventSchema", "ToolCallArgsEventSchema", "ToolCallEndEventSchema", "ToolCallResultEventSchema", "ToolCallChunkEventSchema", "ThinkingStartEventSchema", "ThinkingEndEventSchema", "StateSnapshotEventSchema", "StateSchema", "StateDeltaEventSchema", "MessagesSnapshotEventSchema", "MessageSchema", "ActivitySnapshotEventSchema", "ActivityDeltaEventSchema", "RawEventSchema", "CustomEventSchema", "RunStartedEventSchema", "RunAgentInputSchema", "RunFinishedEventSchema", "RunErrorEventSchema", "StepStartedEventSchema", "StepFinishedEventSchema", "EventSchemas", "JsonPatchOperationType", "EventType", "LegacyRuntimeEventTypes", "z", "LegacyRuntimeMetaEventName", "LegacyTextMessageStart", "LegacyTextMessageContent", "LegacyTextMessageEnd", "LegacyActionExecutionStart", "LegacyActionExecutionArgs", "LegacyActionExecutionEnd", "LegacyActionExecutionResult", "LegacyAgentStateMessage", "LegacyMetaEvent", "LegacyRunError", "LegacyRuntimeProtocolEvent", "LegacyTextMessageSchema", "LegacyActionExecutionMessageSchema", "LegacyResultMessageSchema", "TranscriptionErrorCode", "x", "emojiRegex", "x", "x", "types", "base", "x", "x", "name", "schema", "config", "httpEvents", "HttpAgent", "response", "randomUUID", "context", "logger", "CopilotKitCoreErrorCode", "CopilotKitCoreRuntimeConnectionStatus", "ToolCallStatus"]
}
